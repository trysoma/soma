/* tslint:disable */
/* eslint-disable */
/**
 * soma
 * An open source AI agent runtime
 *
 * The version of the OpenAPI document: v1
 *
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

import type {
	CreateDataEncryptionKeyParamsRoute,
	CreateDekAliasRequest,
	DataEncryptionKey,
	DataEncryptionKeyAlias,
	DataEncryptionKeyListItemPaginatedResponse,
	EnvelopeEncryptionKey,
	EnvelopeEncryptionKeyPaginatedResponse,
	ImportDataEncryptionKeyParamsRoute,
	MigrateAllDataEncryptionKeysParamsRoute,
	MigrateDataEncryptionKeyParamsRoute,
	UpdateAliasParams,
} from "../models/index";
import {
	CreateDataEncryptionKeyParamsRouteToJSON,
	CreateDekAliasRequestToJSON,
	DataEncryptionKeyAliasFromJSON,
	DataEncryptionKeyFromJSON,
	DataEncryptionKeyListItemPaginatedResponseFromJSON,
	EnvelopeEncryptionKeyFromJSON,
	EnvelopeEncryptionKeyPaginatedResponseFromJSON,
	EnvelopeEncryptionKeyToJSON,
	ImportDataEncryptionKeyParamsRouteToJSON,
	MigrateAllDataEncryptionKeysParamsRouteToJSON,
	MigrateDataEncryptionKeyParamsRouteToJSON,
	UpdateAliasParamsToJSON,
} from "../models/index";
import * as runtime from "../runtime";

export interface EncryptionApiCreateDataEncryptionKeyRequest {
	envelopeId: string;
	createDataEncryptionKeyParamsRoute: CreateDataEncryptionKeyParamsRoute;
}

export interface EncryptionApiCreateDekAliasOperationRequest {
	createDekAliasRequest: CreateDekAliasRequest;
}

export interface EncryptionApiCreateEnvelopeEncryptionKeyRequest {
	envelopeEncryptionKey: EnvelopeEncryptionKey;
}

export interface EncryptionApiDeleteDekAliasRequest {
	alias: string;
}

export interface EncryptionApiGetDekByAliasOrIdRequest {
	alias: string;
}

export interface EncryptionApiImportDataEncryptionKeyRequest {
	envelopeId: string;
	importDataEncryptionKeyParamsRoute: ImportDataEncryptionKeyParamsRoute;
}

export interface EncryptionApiListDataEncryptionKeysByEnvelopeRequest {
	envelopeId: string;
	pageSize: number;
	nextPageToken?: string;
}

export interface EncryptionApiListEnvelopeEncryptionKeysRequest {
	pageSize: number;
	nextPageToken?: string;
}

export interface EncryptionApiMigrateAllDataEncryptionKeysRequest {
	envelopeId: string;
	migrateAllDataEncryptionKeysParamsRoute: MigrateAllDataEncryptionKeysParamsRoute;
}

export interface EncryptionApiMigrateDataEncryptionKeyRequest {
	envelopeId: string;
	dekId: string;
	migrateDataEncryptionKeyParamsRoute: MigrateDataEncryptionKeyParamsRoute;
}

export interface EncryptionApiUpdateDekAliasRequest {
	alias: string;
	updateAliasParams: UpdateAliasParams;
}

/**
 *
 */
export class EncryptionApi extends runtime.BaseAPI {
	/**
	 * Create a new data encryption key (DEK) encrypted with the specified envelope encryption key
	 * Create data key
	 */
	async createDataEncryptionKeyRaw(
		requestParameters: EncryptionApiCreateDataEncryptionKeyRequest,
		initOverrides?: RequestInit | runtime.InitOverrideFunction,
	): Promise<runtime.ApiResponse<DataEncryptionKey>> {
		if (requestParameters.envelopeId == null) {
			throw new runtime.RequiredError(
				"envelopeId",
				'Required parameter "envelopeId" was null or undefined when calling createDataEncryptionKey().',
			);
		}

		if (requestParameters.createDataEncryptionKeyParamsRoute == null) {
			throw new runtime.RequiredError(
				"createDataEncryptionKeyParamsRoute",
				'Required parameter "createDataEncryptionKeyParamsRoute" was null or undefined when calling createDataEncryptionKey().',
			);
		}

		const queryParameters: any = {};

		const headerParameters: runtime.HTTPHeaders = {};

		headerParameters["Content-Type"] = "application/json";

		if (this.configuration?.accessToken) {
			const token = this.configuration.accessToken;
			const tokenString = await token("bearer_token", []);

			if (tokenString) {
				headerParameters.Authorization = `Bearer ${tokenString}`;
			}
		}
		if (this.configuration?.apiKey) {
			headerParameters["X-API-Key"] =
				await this.configuration.apiKey("X-API-Key"); // api_key authentication
		}

		let urlPath = `/api/encryption/v1/envelope/{envelope_id}/dek`;
		urlPath = urlPath.replace(
			`{${"envelope_id"}}`,
			encodeURIComponent(String(requestParameters.envelopeId)),
		);

		const response = await this.request(
			{
				path: urlPath,
				method: "POST",
				headers: headerParameters,
				query: queryParameters,
				body: CreateDataEncryptionKeyParamsRouteToJSON(
					requestParameters.createDataEncryptionKeyParamsRoute,
				),
			},
			initOverrides,
		);

		return new runtime.JSONApiResponse(response, (jsonValue) =>
			DataEncryptionKeyFromJSON(jsonValue),
		);
	}

	/**
	 * Create a new data encryption key (DEK) encrypted with the specified envelope encryption key
	 * Create data key
	 */
	async createDataEncryptionKey(
		requestParameters: EncryptionApiCreateDataEncryptionKeyRequest,
		initOverrides?: RequestInit | runtime.InitOverrideFunction,
	): Promise<DataEncryptionKey> {
		const response = await this.createDataEncryptionKeyRaw(
			requestParameters,
			initOverrides,
		);
		return await response.value();
	}

	/**
	 * Create an alias for a data encryption key to enable lookup by friendly name
	 * Create DEK alias
	 */
	async createDekAliasRaw(
		requestParameters: EncryptionApiCreateDekAliasOperationRequest,
		initOverrides?: RequestInit | runtime.InitOverrideFunction,
	): Promise<runtime.ApiResponse<DataEncryptionKeyAlias>> {
		if (requestParameters.createDekAliasRequest == null) {
			throw new runtime.RequiredError(
				"createDekAliasRequest",
				'Required parameter "createDekAliasRequest" was null or undefined when calling createDekAlias().',
			);
		}

		const queryParameters: any = {};

		const headerParameters: runtime.HTTPHeaders = {};

		headerParameters["Content-Type"] = "application/json";

		if (this.configuration?.accessToken) {
			const token = this.configuration.accessToken;
			const tokenString = await token("bearer_token", []);

			if (tokenString) {
				headerParameters.Authorization = `Bearer ${tokenString}`;
			}
		}
		if (this.configuration?.apiKey) {
			headerParameters["X-API-Key"] =
				await this.configuration.apiKey("X-API-Key"); // api_key authentication
		}

		const urlPath = `/api/encryption/v1/dek/alias`;

		const response = await this.request(
			{
				path: urlPath,
				method: "POST",
				headers: headerParameters,
				query: queryParameters,
				body: CreateDekAliasRequestToJSON(
					requestParameters.createDekAliasRequest,
				),
			},
			initOverrides,
		);

		return new runtime.JSONApiResponse(response, (jsonValue) =>
			DataEncryptionKeyAliasFromJSON(jsonValue),
		);
	}

	/**
	 * Create an alias for a data encryption key to enable lookup by friendly name
	 * Create DEK alias
	 */
	async createDekAlias(
		requestParameters: EncryptionApiCreateDekAliasOperationRequest,
		initOverrides?: RequestInit | runtime.InitOverrideFunction,
	): Promise<DataEncryptionKeyAlias> {
		const response = await this.createDekAliasRaw(
			requestParameters,
			initOverrides,
		);
		return await response.value();
	}

	/**
	 * Create a new envelope encryption key (master key) for encrypting data encryption keys
	 * Create envelope key
	 */
	async createEnvelopeEncryptionKeyRaw(
		requestParameters: EncryptionApiCreateEnvelopeEncryptionKeyRequest,
		initOverrides?: RequestInit | runtime.InitOverrideFunction,
	): Promise<runtime.ApiResponse<EnvelopeEncryptionKey>> {
		if (requestParameters.envelopeEncryptionKey == null) {
			throw new runtime.RequiredError(
				"envelopeEncryptionKey",
				'Required parameter "envelopeEncryptionKey" was null or undefined when calling createEnvelopeEncryptionKey().',
			);
		}

		const queryParameters: any = {};

		const headerParameters: runtime.HTTPHeaders = {};

		headerParameters["Content-Type"] = "application/json";

		if (this.configuration?.accessToken) {
			const token = this.configuration.accessToken;
			const tokenString = await token("bearer_token", []);

			if (tokenString) {
				headerParameters.Authorization = `Bearer ${tokenString}`;
			}
		}
		if (this.configuration?.apiKey) {
			headerParameters["X-API-Key"] =
				await this.configuration.apiKey("X-API-Key"); // api_key authentication
		}

		const urlPath = `/api/encryption/v1/envelope`;

		const response = await this.request(
			{
				path: urlPath,
				method: "POST",
				headers: headerParameters,
				query: queryParameters,
				body: EnvelopeEncryptionKeyToJSON(
					requestParameters.envelopeEncryptionKey,
				),
			},
			initOverrides,
		);

		return new runtime.JSONApiResponse(response, (jsonValue) =>
			EnvelopeEncryptionKeyFromJSON(jsonValue),
		);
	}

	/**
	 * Create a new envelope encryption key (master key) for encrypting data encryption keys
	 * Create envelope key
	 */
	async createEnvelopeEncryptionKey(
		requestParameters: EncryptionApiCreateEnvelopeEncryptionKeyRequest,
		initOverrides?: RequestInit | runtime.InitOverrideFunction,
	): Promise<EnvelopeEncryptionKey> {
		const response = await this.createEnvelopeEncryptionKeyRaw(
			requestParameters,
			initOverrides,
		);
		return await response.value();
	}

	/**
	 * Delete an alias for a data encryption key
	 * Delete DEK alias
	 */
	async deleteDekAliasRaw(
		requestParameters: EncryptionApiDeleteDekAliasRequest,
		initOverrides?: RequestInit | runtime.InitOverrideFunction,
	): Promise<runtime.ApiResponse<void>> {
		if (requestParameters.alias == null) {
			throw new runtime.RequiredError(
				"alias",
				'Required parameter "alias" was null or undefined when calling deleteDekAlias().',
			);
		}

		const queryParameters: any = {};

		const headerParameters: runtime.HTTPHeaders = {};

		if (this.configuration?.accessToken) {
			const token = this.configuration.accessToken;
			const tokenString = await token("bearer_token", []);

			if (tokenString) {
				headerParameters.Authorization = `Bearer ${tokenString}`;
			}
		}
		if (this.configuration?.apiKey) {
			headerParameters["X-API-Key"] =
				await this.configuration.apiKey("X-API-Key"); // api_key authentication
		}

		let urlPath = `/api/encryption/v1/dek/alias/{alias}`;
		urlPath = urlPath.replace(
			`{${"alias"}}`,
			encodeURIComponent(String(requestParameters.alias)),
		);

		const response = await this.request(
			{
				path: urlPath,
				method: "DELETE",
				headers: headerParameters,
				query: queryParameters,
			},
			initOverrides,
		);

		return new runtime.VoidApiResponse(response);
	}

	/**
	 * Delete an alias for a data encryption key
	 * Delete DEK alias
	 */
	async deleteDekAlias(
		requestParameters: EncryptionApiDeleteDekAliasRequest,
		initOverrides?: RequestInit | runtime.InitOverrideFunction,
	): Promise<void> {
		await this.deleteDekAliasRaw(requestParameters, initOverrides);
	}

	/**
	 * Retrieve a data encryption key by its alias or ID
	 * Get DEK by alias
	 */
	async getDekByAliasOrIdRaw(
		requestParameters: EncryptionApiGetDekByAliasOrIdRequest,
		initOverrides?: RequestInit | runtime.InitOverrideFunction,
	): Promise<runtime.ApiResponse<DataEncryptionKey>> {
		if (requestParameters.alias == null) {
			throw new runtime.RequiredError(
				"alias",
				'Required parameter "alias" was null or undefined when calling getDekByAliasOrId().',
			);
		}

		const queryParameters: any = {};

		const headerParameters: runtime.HTTPHeaders = {};

		if (this.configuration?.accessToken) {
			const token = this.configuration.accessToken;
			const tokenString = await token("bearer_token", []);

			if (tokenString) {
				headerParameters.Authorization = `Bearer ${tokenString}`;
			}
		}
		if (this.configuration?.apiKey) {
			headerParameters["X-API-Key"] =
				await this.configuration.apiKey("X-API-Key"); // api_key authentication
		}

		let urlPath = `/api/encryption/v1/dek/alias/{alias}`;
		urlPath = urlPath.replace(
			`{${"alias"}}`,
			encodeURIComponent(String(requestParameters.alias)),
		);

		const response = await this.request(
			{
				path: urlPath,
				method: "GET",
				headers: headerParameters,
				query: queryParameters,
			},
			initOverrides,
		);

		return new runtime.JSONApiResponse(response, (jsonValue) =>
			DataEncryptionKeyFromJSON(jsonValue),
		);
	}

	/**
	 * Retrieve a data encryption key by its alias or ID
	 * Get DEK by alias
	 */
	async getDekByAliasOrId(
		requestParameters: EncryptionApiGetDekByAliasOrIdRequest,
		initOverrides?: RequestInit | runtime.InitOverrideFunction,
	): Promise<DataEncryptionKey> {
		const response = await this.getDekByAliasOrIdRaw(
			requestParameters,
			initOverrides,
		);
		return await response.value();
	}

	/**
	 * Import an existing pre-encrypted data encryption key into the system
	 * Import data key
	 */
	async importDataEncryptionKeyRaw(
		requestParameters: EncryptionApiImportDataEncryptionKeyRequest,
		initOverrides?: RequestInit | runtime.InitOverrideFunction,
	): Promise<runtime.ApiResponse<DataEncryptionKey>> {
		if (requestParameters.envelopeId == null) {
			throw new runtime.RequiredError(
				"envelopeId",
				'Required parameter "envelopeId" was null or undefined when calling importDataEncryptionKey().',
			);
		}

		if (requestParameters.importDataEncryptionKeyParamsRoute == null) {
			throw new runtime.RequiredError(
				"importDataEncryptionKeyParamsRoute",
				'Required parameter "importDataEncryptionKeyParamsRoute" was null or undefined when calling importDataEncryptionKey().',
			);
		}

		const queryParameters: any = {};

		const headerParameters: runtime.HTTPHeaders = {};

		headerParameters["Content-Type"] = "application/json";

		if (this.configuration?.accessToken) {
			const token = this.configuration.accessToken;
			const tokenString = await token("bearer_token", []);

			if (tokenString) {
				headerParameters.Authorization = `Bearer ${tokenString}`;
			}
		}
		if (this.configuration?.apiKey) {
			headerParameters["X-API-Key"] =
				await this.configuration.apiKey("X-API-Key"); // api_key authentication
		}

		let urlPath = `/api/encryption/v1/envelope/{envelope_id}/dek/import`;
		urlPath = urlPath.replace(
			`{${"envelope_id"}}`,
			encodeURIComponent(String(requestParameters.envelopeId)),
		);

		const response = await this.request(
			{
				path: urlPath,
				method: "POST",
				headers: headerParameters,
				query: queryParameters,
				body: ImportDataEncryptionKeyParamsRouteToJSON(
					requestParameters.importDataEncryptionKeyParamsRoute,
				),
			},
			initOverrides,
		);

		return new runtime.JSONApiResponse(response, (jsonValue) =>
			DataEncryptionKeyFromJSON(jsonValue),
		);
	}

	/**
	 * Import an existing pre-encrypted data encryption key into the system
	 * Import data key
	 */
	async importDataEncryptionKey(
		requestParameters: EncryptionApiImportDataEncryptionKeyRequest,
		initOverrides?: RequestInit | runtime.InitOverrideFunction,
	): Promise<DataEncryptionKey> {
		const response = await this.importDataEncryptionKeyRaw(
			requestParameters,
			initOverrides,
		);
		return await response.value();
	}

	/**
	 * List all data encryption keys encrypted with the specified envelope encryption key
	 * List data keys
	 */
	async listDataEncryptionKeysByEnvelopeRaw(
		requestParameters: EncryptionApiListDataEncryptionKeysByEnvelopeRequest,
		initOverrides?: RequestInit | runtime.InitOverrideFunction,
	): Promise<runtime.ApiResponse<DataEncryptionKeyListItemPaginatedResponse>> {
		if (requestParameters.envelopeId == null) {
			throw new runtime.RequiredError(
				"envelopeId",
				'Required parameter "envelopeId" was null or undefined when calling listDataEncryptionKeysByEnvelope().',
			);
		}

		if (requestParameters.pageSize == null) {
			throw new runtime.RequiredError(
				"pageSize",
				'Required parameter "pageSize" was null or undefined when calling listDataEncryptionKeysByEnvelope().',
			);
		}

		const queryParameters: any = {};

		if (requestParameters.pageSize != null) {
			queryParameters.page_size = requestParameters.pageSize;
		}

		if (requestParameters.nextPageToken != null) {
			queryParameters.next_page_token = requestParameters.nextPageToken;
		}

		const headerParameters: runtime.HTTPHeaders = {};

		if (this.configuration?.accessToken) {
			const token = this.configuration.accessToken;
			const tokenString = await token("bearer_token", []);

			if (tokenString) {
				headerParameters.Authorization = `Bearer ${tokenString}`;
			}
		}
		if (this.configuration?.apiKey) {
			headerParameters["X-API-Key"] =
				await this.configuration.apiKey("X-API-Key"); // api_key authentication
		}

		let urlPath = `/api/encryption/v1/envelope/{envelope_id}/dek`;
		urlPath = urlPath.replace(
			`{${"envelope_id"}}`,
			encodeURIComponent(String(requestParameters.envelopeId)),
		);

		const response = await this.request(
			{
				path: urlPath,
				method: "GET",
				headers: headerParameters,
				query: queryParameters,
			},
			initOverrides,
		);

		return new runtime.JSONApiResponse(response, (jsonValue) =>
			DataEncryptionKeyListItemPaginatedResponseFromJSON(jsonValue),
		);
	}

	/**
	 * List all data encryption keys encrypted with the specified envelope encryption key
	 * List data keys
	 */
	async listDataEncryptionKeysByEnvelope(
		requestParameters: EncryptionApiListDataEncryptionKeysByEnvelopeRequest,
		initOverrides?: RequestInit | runtime.InitOverrideFunction,
	): Promise<DataEncryptionKeyListItemPaginatedResponse> {
		const response = await this.listDataEncryptionKeysByEnvelopeRaw(
			requestParameters,
			initOverrides,
		);
		return await response.value();
	}

	/**
	 * List all envelope encryption keys (master keys) with pagination
	 * List envelope keys
	 */
	async listEnvelopeEncryptionKeysRaw(
		requestParameters: EncryptionApiListEnvelopeEncryptionKeysRequest,
		initOverrides?: RequestInit | runtime.InitOverrideFunction,
	): Promise<runtime.ApiResponse<EnvelopeEncryptionKeyPaginatedResponse>> {
		if (requestParameters.pageSize == null) {
			throw new runtime.RequiredError(
				"pageSize",
				'Required parameter "pageSize" was null or undefined when calling listEnvelopeEncryptionKeys().',
			);
		}

		const queryParameters: any = {};

		if (requestParameters.pageSize != null) {
			queryParameters.page_size = requestParameters.pageSize;
		}

		if (requestParameters.nextPageToken != null) {
			queryParameters.next_page_token = requestParameters.nextPageToken;
		}

		const headerParameters: runtime.HTTPHeaders = {};

		if (this.configuration?.accessToken) {
			const token = this.configuration.accessToken;
			const tokenString = await token("bearer_token", []);

			if (tokenString) {
				headerParameters.Authorization = `Bearer ${tokenString}`;
			}
		}
		if (this.configuration?.apiKey) {
			headerParameters["X-API-Key"] =
				await this.configuration.apiKey("X-API-Key"); // api_key authentication
		}

		const urlPath = `/api/encryption/v1/envelope`;

		const response = await this.request(
			{
				path: urlPath,
				method: "GET",
				headers: headerParameters,
				query: queryParameters,
			},
			initOverrides,
		);

		return new runtime.JSONApiResponse(response, (jsonValue) =>
			EnvelopeEncryptionKeyPaginatedResponseFromJSON(jsonValue),
		);
	}

	/**
	 * List all envelope encryption keys (master keys) with pagination
	 * List envelope keys
	 */
	async listEnvelopeEncryptionKeys(
		requestParameters: EncryptionApiListEnvelopeEncryptionKeysRequest,
		initOverrides?: RequestInit | runtime.InitOverrideFunction,
	): Promise<EnvelopeEncryptionKeyPaginatedResponse> {
		const response = await this.listEnvelopeEncryptionKeysRaw(
			requestParameters,
			initOverrides,
		);
		return await response.value();
	}

	/**
	 * Migrate all data encryption keys encrypted with the specified envelope key to a new envelope key
	 * Migrate all data keys
	 */
	async migrateAllDataEncryptionKeysRaw(
		requestParameters: EncryptionApiMigrateAllDataEncryptionKeysRequest,
		initOverrides?: RequestInit | runtime.InitOverrideFunction,
	): Promise<runtime.ApiResponse<void>> {
		if (requestParameters.envelopeId == null) {
			throw new runtime.RequiredError(
				"envelopeId",
				'Required parameter "envelopeId" was null or undefined when calling migrateAllDataEncryptionKeys().',
			);
		}

		if (requestParameters.migrateAllDataEncryptionKeysParamsRoute == null) {
			throw new runtime.RequiredError(
				"migrateAllDataEncryptionKeysParamsRoute",
				'Required parameter "migrateAllDataEncryptionKeysParamsRoute" was null or undefined when calling migrateAllDataEncryptionKeys().',
			);
		}

		const queryParameters: any = {};

		const headerParameters: runtime.HTTPHeaders = {};

		headerParameters["Content-Type"] = "application/json";

		if (this.configuration?.accessToken) {
			const token = this.configuration.accessToken;
			const tokenString = await token("bearer_token", []);

			if (tokenString) {
				headerParameters.Authorization = `Bearer ${tokenString}`;
			}
		}
		if (this.configuration?.apiKey) {
			headerParameters["X-API-Key"] =
				await this.configuration.apiKey("X-API-Key"); // api_key authentication
		}

		let urlPath = `/api/encryption/v1/envelope/{envelope_id}/migrate`;
		urlPath = urlPath.replace(
			`{${"envelope_id"}}`,
			encodeURIComponent(String(requestParameters.envelopeId)),
		);

		const response = await this.request(
			{
				path: urlPath,
				method: "POST",
				headers: headerParameters,
				query: queryParameters,
				body: MigrateAllDataEncryptionKeysParamsRouteToJSON(
					requestParameters.migrateAllDataEncryptionKeysParamsRoute,
				),
			},
			initOverrides,
		);

		return new runtime.VoidApiResponse(response);
	}

	/**
	 * Migrate all data encryption keys encrypted with the specified envelope key to a new envelope key
	 * Migrate all data keys
	 */
	async migrateAllDataEncryptionKeys(
		requestParameters: EncryptionApiMigrateAllDataEncryptionKeysRequest,
		initOverrides?: RequestInit | runtime.InitOverrideFunction,
	): Promise<void> {
		await this.migrateAllDataEncryptionKeysRaw(
			requestParameters,
			initOverrides,
		);
	}

	/**
	 * Migrate a data encryption key to be encrypted with a different envelope encryption key
	 * Migrate data key
	 */
	async migrateDataEncryptionKeyRaw(
		requestParameters: EncryptionApiMigrateDataEncryptionKeyRequest,
		initOverrides?: RequestInit | runtime.InitOverrideFunction,
	): Promise<runtime.ApiResponse<void>> {
		if (requestParameters.envelopeId == null) {
			throw new runtime.RequiredError(
				"envelopeId",
				'Required parameter "envelopeId" was null or undefined when calling migrateDataEncryptionKey().',
			);
		}

		if (requestParameters.dekId == null) {
			throw new runtime.RequiredError(
				"dekId",
				'Required parameter "dekId" was null or undefined when calling migrateDataEncryptionKey().',
			);
		}

		if (requestParameters.migrateDataEncryptionKeyParamsRoute == null) {
			throw new runtime.RequiredError(
				"migrateDataEncryptionKeyParamsRoute",
				'Required parameter "migrateDataEncryptionKeyParamsRoute" was null or undefined when calling migrateDataEncryptionKey().',
			);
		}

		const queryParameters: any = {};

		const headerParameters: runtime.HTTPHeaders = {};

		headerParameters["Content-Type"] = "application/json";

		if (this.configuration?.accessToken) {
			const token = this.configuration.accessToken;
			const tokenString = await token("bearer_token", []);

			if (tokenString) {
				headerParameters.Authorization = `Bearer ${tokenString}`;
			}
		}
		if (this.configuration?.apiKey) {
			headerParameters["X-API-Key"] =
				await this.configuration.apiKey("X-API-Key"); // api_key authentication
		}

		let urlPath = `/api/encryption/v1/envelope/{envelope_id}/dek/{dek_id}/migrate`;
		urlPath = urlPath.replace(
			`{${"envelope_id"}}`,
			encodeURIComponent(String(requestParameters.envelopeId)),
		);
		urlPath = urlPath.replace(
			`{${"dek_id"}}`,
			encodeURIComponent(String(requestParameters.dekId)),
		);

		const response = await this.request(
			{
				path: urlPath,
				method: "POST",
				headers: headerParameters,
				query: queryParameters,
				body: MigrateDataEncryptionKeyParamsRouteToJSON(
					requestParameters.migrateDataEncryptionKeyParamsRoute,
				),
			},
			initOverrides,
		);

		return new runtime.VoidApiResponse(response);
	}

	/**
	 * Migrate a data encryption key to be encrypted with a different envelope encryption key
	 * Migrate data key
	 */
	async migrateDataEncryptionKey(
		requestParameters: EncryptionApiMigrateDataEncryptionKeyRequest,
		initOverrides?: RequestInit | runtime.InitOverrideFunction,
	): Promise<void> {
		await this.migrateDataEncryptionKeyRaw(requestParameters, initOverrides);
	}

	/**
	 * Update the alias for a data encryption key
	 * Update DEK alias
	 */
	async updateDekAliasRaw(
		requestParameters: EncryptionApiUpdateDekAliasRequest,
		initOverrides?: RequestInit | runtime.InitOverrideFunction,
	): Promise<runtime.ApiResponse<DataEncryptionKeyAlias>> {
		if (requestParameters.alias == null) {
			throw new runtime.RequiredError(
				"alias",
				'Required parameter "alias" was null or undefined when calling updateDekAlias().',
			);
		}

		if (requestParameters.updateAliasParams == null) {
			throw new runtime.RequiredError(
				"updateAliasParams",
				'Required parameter "updateAliasParams" was null or undefined when calling updateDekAlias().',
			);
		}

		const queryParameters: any = {};

		const headerParameters: runtime.HTTPHeaders = {};

		headerParameters["Content-Type"] = "application/json";

		if (this.configuration?.accessToken) {
			const token = this.configuration.accessToken;
			const tokenString = await token("bearer_token", []);

			if (tokenString) {
				headerParameters.Authorization = `Bearer ${tokenString}`;
			}
		}
		if (this.configuration?.apiKey) {
			headerParameters["X-API-Key"] =
				await this.configuration.apiKey("X-API-Key"); // api_key authentication
		}

		let urlPath = `/api/encryption/v1/dek/alias/{alias}`;
		urlPath = urlPath.replace(
			`{${"alias"}}`,
			encodeURIComponent(String(requestParameters.alias)),
		);

		const response = await this.request(
			{
				path: urlPath,
				method: "PUT",
				headers: headerParameters,
				query: queryParameters,
				body: UpdateAliasParamsToJSON(requestParameters.updateAliasParams),
			},
			initOverrides,
		);

		return new runtime.JSONApiResponse(response, (jsonValue) =>
			DataEncryptionKeyAliasFromJSON(jsonValue),
		);
	}

	/**
	 * Update the alias for a data encryption key
	 * Update DEK alias
	 */
	async updateDekAlias(
		requestParameters: EncryptionApiUpdateDekAliasRequest,
		initOverrides?: RequestInit | runtime.InitOverrideFunction,
	): Promise<DataEncryptionKeyAlias> {
		const response = await this.updateDekAliasRaw(
			requestParameters,
			initOverrides,
		);
		return await response.value();
	}
}
