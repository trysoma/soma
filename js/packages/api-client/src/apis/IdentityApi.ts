/* tslint:disable */
/* eslint-disable */
/**
 * soma
 * An open source AI agent runtime
 *
 * The version of the OpenAPI document: v1
 *
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

import type {
	AddGroupMemberRequest,
	CreateApiKeyParams,
	CreateApiKeyResponse,
	CreateGroupRequest,
	CreateUserAuthFlowConfigParams,
	CreateUserAuthFlowConfigResponse,
	CreateUserRequest,
	EncryptedApiKeyConfig,
	GetUserAuthFlowConfigResponse,
	Group,
	GroupMemberWithUserPaginatedResponse,
	GroupPaginatedResponse,
	Identity,
	ImportUserAuthFlowConfigParams,
	JwkResponsePaginatedResponse,
	JwksResponse,
	ListApiKeysResponse,
	ListUserAuthFlowConfigResponse,
	NormalizedTokenIssuanceResult,
	RefreshTokenRequest,
	StsTokenConfig,
	StsTokenConfigPaginatedResponse,
	TokenResponse,
	UpdateGroupRequest,
	UpdateUserRequest,
	User,
	UserGroupWithGroupPaginatedResponse,
	UserPaginatedResponse,
} from "../models/index";
import {
	AddGroupMemberRequestToJSON,
	CreateApiKeyParamsToJSON,
	CreateApiKeyResponseFromJSON,
	CreateGroupRequestToJSON,
	CreateUserAuthFlowConfigParamsToJSON,
	CreateUserAuthFlowConfigResponseFromJSON,
	CreateUserRequestToJSON,
	EncryptedApiKeyConfigToJSON,
	GetUserAuthFlowConfigResponseFromJSON,
	GroupFromJSON,
	GroupMemberWithUserPaginatedResponseFromJSON,
	GroupPaginatedResponseFromJSON,
	IdentityFromJSON,
	ImportUserAuthFlowConfigParamsToJSON,
	JwkResponsePaginatedResponseFromJSON,
	JwksResponseFromJSON,
	ListApiKeysResponseFromJSON,
	ListUserAuthFlowConfigResponseFromJSON,
	NormalizedTokenIssuanceResultFromJSON,
	RefreshTokenRequestToJSON,
	StsTokenConfigFromJSON,
	StsTokenConfigPaginatedResponseFromJSON,
	StsTokenConfigToJSON,
	TokenResponseFromJSON,
	UpdateGroupRequestToJSON,
	UpdateUserRequestToJSON,
	UserFromJSON,
	UserGroupWithGroupPaginatedResponseFromJSON,
	UserPaginatedResponseFromJSON,
} from "../models/index";
import * as runtime from "../runtime";

export interface IdentityApiAddGroupMemberOperationRequest {
	groupId: string;
	addGroupMemberRequest: AddGroupMemberRequest;
}

export interface IdentityApiCreateGroupOperationRequest {
	createGroupRequest: CreateGroupRequest;
}

export interface IdentityApiCreateUserOperationRequest {
	createUserRequest: CreateUserRequest;
}

export interface IdentityApiDeleteGroupRequest {
	groupId: string;
}

export interface IdentityApiDeleteUserRequest {
	userId: string;
}

export interface IdentityApiGetGroupRequest {
	groupId: string;
}

export interface IdentityApiGetUserRequest {
	userId: string;
}

export interface IdentityApiListGroupMembersRequest {
	groupId: string;
	pageSize: number;
	nextPageToken?: string;
}

export interface IdentityApiListGroupsRequest {
	pageSize: number;
	nextPageToken?: string;
}

export interface IdentityApiListUserGroupsRequest {
	userId: string;
	pageSize: number;
	nextPageToken?: string;
}

export interface IdentityApiListUsersRequest {
	pageSize: number;
	nextPageToken?: string;
	userType?: string;
	role?: string;
}

export interface IdentityApiRemoveGroupMemberRequest {
	groupId: string;
	userId: string;
}

export interface IdentityApiRouteAuthCallbackRequest {
	code?: string | null;
	state?: string | null;
	error?: string | null;
	errorDescription?: string | null;
}

export interface IdentityApiRouteCreateApiKeyRequest {
	createApiKeyParams: CreateApiKeyParams;
}

export interface IdentityApiRouteCreateStsConfigRequest {
	stsTokenConfig: StsTokenConfig;
}

export interface IdentityApiRouteCreateUserAuthFlowConfigRequest {
	createUserAuthFlowConfigParams: CreateUserAuthFlowConfigParams;
}

export interface IdentityApiRouteDeleteApiKeyRequest {
	id: string;
}

export interface IdentityApiRouteDeleteStsConfigRequest {
	id: string;
}

export interface IdentityApiRouteDeleteUserAuthFlowConfigRequest {
	id: string;
}

export interface IdentityApiRouteExchangeStsTokenRequest {
	stsConfigId: string;
}

export interface IdentityApiRouteGetStsConfigRequest {
	id: string;
}

export interface IdentityApiRouteGetUserAuthFlowConfigRequest {
	id: string;
}

export interface IdentityApiRouteImportApiKeyRequest {
	encryptedApiKeyConfig: EncryptedApiKeyConfig;
}

export interface IdentityApiRouteImportUserAuthFlowConfigRequest {
	importUserAuthFlowConfigParams: ImportUserAuthFlowConfigParams;
}

export interface IdentityApiRouteInvalidateJwkRequest {
	kid: string;
}

export interface IdentityApiRouteListApiKeysRequest {
	pageSize: number;
	nextPageToken?: string;
}

export interface IdentityApiRouteListJwksRequest {
	pageSize: number;
	nextPageToken?: string;
}

export interface IdentityApiRouteListStsConfigsRequest {
	pageSize: number;
	nextPageToken?: string;
}

export interface IdentityApiRouteListUserAuthFlowConfigsRequest {
	pageSize?: number | null;
	nextPageToken?: string | null;
	type?: string | null;
}

export interface IdentityApiRouteRefreshTokenRequest {
	refreshTokenRequest?: RefreshTokenRequest;
}

export interface IdentityApiRouteStartAuthorizationRequest {
	configId: string;
	redirectAfterLogin?: string | null;
}

export interface IdentityApiUpdateGroupOperationRequest {
	groupId: string;
	updateGroupRequest: UpdateGroupRequest;
}

export interface IdentityApiUpdateUserOperationRequest {
	userId: string;
	updateUserRequest: UpdateUserRequest;
}

/**
 *
 */
export class IdentityApi extends runtime.BaseAPI {
	/**
	 * Add a user to a group
	 * Add group member
	 */
	async addGroupMemberRaw(
		requestParameters: IdentityApiAddGroupMemberOperationRequest,
		initOverrides?: RequestInit | runtime.InitOverrideFunction,
	): Promise<runtime.ApiResponse<void>> {
		if (requestParameters.groupId == null) {
			throw new runtime.RequiredError(
				"groupId",
				'Required parameter "groupId" was null or undefined when calling addGroupMember().',
			);
		}

		if (requestParameters.addGroupMemberRequest == null) {
			throw new runtime.RequiredError(
				"addGroupMemberRequest",
				'Required parameter "addGroupMemberRequest" was null or undefined when calling addGroupMember().',
			);
		}

		const queryParameters: any = {};

		const headerParameters: runtime.HTTPHeaders = {};

		headerParameters["Content-Type"] = "application/json";

		if (this.configuration?.accessToken) {
			const token = this.configuration.accessToken;
			const tokenString = await token("bearer_token", []);

			if (tokenString) {
				headerParameters.Authorization = `Bearer ${tokenString}`;
			}
		}
		if (this.configuration?.apiKey) {
			headerParameters["X-API-Key"] =
				await this.configuration.apiKey("X-API-Key"); // api_key authentication
		}

		let urlPath = `/api/identity/v1/groups/{group_id}/members`;
		urlPath = urlPath.replace(
			`{${"group_id"}}`,
			encodeURIComponent(String(requestParameters.groupId)),
		);

		const response = await this.request(
			{
				path: urlPath,
				method: "POST",
				headers: headerParameters,
				query: queryParameters,
				body: AddGroupMemberRequestToJSON(
					requestParameters.addGroupMemberRequest,
				),
			},
			initOverrides,
		);

		return new runtime.VoidApiResponse(response);
	}

	/**
	 * Add a user to a group
	 * Add group member
	 */
	async addGroupMember(
		requestParameters: IdentityApiAddGroupMemberOperationRequest,
		initOverrides?: RequestInit | runtime.InitOverrideFunction,
	): Promise<void> {
		await this.addGroupMemberRaw(requestParameters, initOverrides);
	}

	/**
	 * Create a new group with the specified name
	 * Create group
	 */
	async createGroupRaw(
		requestParameters: IdentityApiCreateGroupOperationRequest,
		initOverrides?: RequestInit | runtime.InitOverrideFunction,
	): Promise<runtime.ApiResponse<Group>> {
		if (requestParameters.createGroupRequest == null) {
			throw new runtime.RequiredError(
				"createGroupRequest",
				'Required parameter "createGroupRequest" was null or undefined when calling createGroup().',
			);
		}

		const queryParameters: any = {};

		const headerParameters: runtime.HTTPHeaders = {};

		headerParameters["Content-Type"] = "application/json";

		if (this.configuration?.accessToken) {
			const token = this.configuration.accessToken;
			const tokenString = await token("bearer_token", []);

			if (tokenString) {
				headerParameters.Authorization = `Bearer ${tokenString}`;
			}
		}
		if (this.configuration?.apiKey) {
			headerParameters["X-API-Key"] =
				await this.configuration.apiKey("X-API-Key"); // api_key authentication
		}

		const urlPath = `/api/identity/v1/groups`;

		const response = await this.request(
			{
				path: urlPath,
				method: "POST",
				headers: headerParameters,
				query: queryParameters,
				body: CreateGroupRequestToJSON(requestParameters.createGroupRequest),
			},
			initOverrides,
		);

		return new runtime.JSONApiResponse(response, (jsonValue) =>
			GroupFromJSON(jsonValue),
		);
	}

	/**
	 * Create a new group with the specified name
	 * Create group
	 */
	async createGroup(
		requestParameters: IdentityApiCreateGroupOperationRequest,
		initOverrides?: RequestInit | runtime.InitOverrideFunction,
	): Promise<Group> {
		const response = await this.createGroupRaw(
			requestParameters,
			initOverrides,
		);
		return await response.value();
	}

	/**
	 * Create a new user with the specified attributes
	 * Create user
	 */
	async createUserRaw(
		requestParameters: IdentityApiCreateUserOperationRequest,
		initOverrides?: RequestInit | runtime.InitOverrideFunction,
	): Promise<runtime.ApiResponse<User>> {
		if (requestParameters.createUserRequest == null) {
			throw new runtime.RequiredError(
				"createUserRequest",
				'Required parameter "createUserRequest" was null or undefined when calling createUser().',
			);
		}

		const queryParameters: any = {};

		const headerParameters: runtime.HTTPHeaders = {};

		headerParameters["Content-Type"] = "application/json";

		if (this.configuration?.accessToken) {
			const token = this.configuration.accessToken;
			const tokenString = await token("bearer_token", []);

			if (tokenString) {
				headerParameters.Authorization = `Bearer ${tokenString}`;
			}
		}
		if (this.configuration?.apiKey) {
			headerParameters["X-API-Key"] =
				await this.configuration.apiKey("X-API-Key"); // api_key authentication
		}

		const urlPath = `/api/identity/v1/users`;

		const response = await this.request(
			{
				path: urlPath,
				method: "POST",
				headers: headerParameters,
				query: queryParameters,
				body: CreateUserRequestToJSON(requestParameters.createUserRequest),
			},
			initOverrides,
		);

		return new runtime.JSONApiResponse(response, (jsonValue) =>
			UserFromJSON(jsonValue),
		);
	}

	/**
	 * Create a new user with the specified attributes
	 * Create user
	 */
	async createUser(
		requestParameters: IdentityApiCreateUserOperationRequest,
		initOverrides?: RequestInit | runtime.InitOverrideFunction,
	): Promise<User> {
		const response = await this.createUserRaw(requestParameters, initOverrides);
		return await response.value();
	}

	/**
	 * Delete a group by its unique identifier
	 * Delete group
	 */
	async deleteGroupRaw(
		requestParameters: IdentityApiDeleteGroupRequest,
		initOverrides?: RequestInit | runtime.InitOverrideFunction,
	): Promise<runtime.ApiResponse<void>> {
		if (requestParameters.groupId == null) {
			throw new runtime.RequiredError(
				"groupId",
				'Required parameter "groupId" was null or undefined when calling deleteGroup().',
			);
		}

		const queryParameters: any = {};

		const headerParameters: runtime.HTTPHeaders = {};

		if (this.configuration?.accessToken) {
			const token = this.configuration.accessToken;
			const tokenString = await token("bearer_token", []);

			if (tokenString) {
				headerParameters.Authorization = `Bearer ${tokenString}`;
			}
		}
		if (this.configuration?.apiKey) {
			headerParameters["X-API-Key"] =
				await this.configuration.apiKey("X-API-Key"); // api_key authentication
		}

		let urlPath = `/api/identity/v1/groups/{group_id}`;
		urlPath = urlPath.replace(
			`{${"group_id"}}`,
			encodeURIComponent(String(requestParameters.groupId)),
		);

		const response = await this.request(
			{
				path: urlPath,
				method: "DELETE",
				headers: headerParameters,
				query: queryParameters,
			},
			initOverrides,
		);

		return new runtime.VoidApiResponse(response);
	}

	/**
	 * Delete a group by its unique identifier
	 * Delete group
	 */
	async deleteGroup(
		requestParameters: IdentityApiDeleteGroupRequest,
		initOverrides?: RequestInit | runtime.InitOverrideFunction,
	): Promise<void> {
		await this.deleteGroupRaw(requestParameters, initOverrides);
	}

	/**
	 * Delete a user by their unique identifier
	 * Delete user
	 */
	async deleteUserRaw(
		requestParameters: IdentityApiDeleteUserRequest,
		initOverrides?: RequestInit | runtime.InitOverrideFunction,
	): Promise<runtime.ApiResponse<void>> {
		if (requestParameters.userId == null) {
			throw new runtime.RequiredError(
				"userId",
				'Required parameter "userId" was null or undefined when calling deleteUser().',
			);
		}

		const queryParameters: any = {};

		const headerParameters: runtime.HTTPHeaders = {};

		if (this.configuration?.accessToken) {
			const token = this.configuration.accessToken;
			const tokenString = await token("bearer_token", []);

			if (tokenString) {
				headerParameters.Authorization = `Bearer ${tokenString}`;
			}
		}
		if (this.configuration?.apiKey) {
			headerParameters["X-API-Key"] =
				await this.configuration.apiKey("X-API-Key"); // api_key authentication
		}

		let urlPath = `/api/identity/v1/users/{user_id}`;
		urlPath = urlPath.replace(
			`{${"user_id"}}`,
			encodeURIComponent(String(requestParameters.userId)),
		);

		const response = await this.request(
			{
				path: urlPath,
				method: "DELETE",
				headers: headerParameters,
				query: queryParameters,
			},
			initOverrides,
		);

		return new runtime.VoidApiResponse(response);
	}

	/**
	 * Delete a user by their unique identifier
	 * Delete user
	 */
	async deleteUser(
		requestParameters: IdentityApiDeleteUserRequest,
		initOverrides?: RequestInit | runtime.InitOverrideFunction,
	): Promise<void> {
		await this.deleteUserRaw(requestParameters, initOverrides);
	}

	/**
	 * Retrieve a group by its unique identifier
	 * Get group
	 */
	async getGroupRaw(
		requestParameters: IdentityApiGetGroupRequest,
		initOverrides?: RequestInit | runtime.InitOverrideFunction,
	): Promise<runtime.ApiResponse<Group>> {
		if (requestParameters.groupId == null) {
			throw new runtime.RequiredError(
				"groupId",
				'Required parameter "groupId" was null or undefined when calling getGroup().',
			);
		}

		const queryParameters: any = {};

		const headerParameters: runtime.HTTPHeaders = {};

		if (this.configuration?.accessToken) {
			const token = this.configuration.accessToken;
			const tokenString = await token("bearer_token", []);

			if (tokenString) {
				headerParameters.Authorization = `Bearer ${tokenString}`;
			}
		}
		if (this.configuration?.apiKey) {
			headerParameters["X-API-Key"] =
				await this.configuration.apiKey("X-API-Key"); // api_key authentication
		}

		let urlPath = `/api/identity/v1/groups/{group_id}`;
		urlPath = urlPath.replace(
			`{${"group_id"}}`,
			encodeURIComponent(String(requestParameters.groupId)),
		);

		const response = await this.request(
			{
				path: urlPath,
				method: "GET",
				headers: headerParameters,
				query: queryParameters,
			},
			initOverrides,
		);

		return new runtime.JSONApiResponse(response, (jsonValue) =>
			GroupFromJSON(jsonValue),
		);
	}

	/**
	 * Retrieve a group by its unique identifier
	 * Get group
	 */
	async getGroup(
		requestParameters: IdentityApiGetGroupRequest,
		initOverrides?: RequestInit | runtime.InitOverrideFunction,
	): Promise<Group> {
		const response = await this.getGroupRaw(requestParameters, initOverrides);
		return await response.value();
	}

	/**
	 * Retrieve a user by their unique identifier
	 * Get user
	 */
	async getUserRaw(
		requestParameters: IdentityApiGetUserRequest,
		initOverrides?: RequestInit | runtime.InitOverrideFunction,
	): Promise<runtime.ApiResponse<User>> {
		if (requestParameters.userId == null) {
			throw new runtime.RequiredError(
				"userId",
				'Required parameter "userId" was null or undefined when calling getUser().',
			);
		}

		const queryParameters: any = {};

		const headerParameters: runtime.HTTPHeaders = {};

		if (this.configuration?.accessToken) {
			const token = this.configuration.accessToken;
			const tokenString = await token("bearer_token", []);

			if (tokenString) {
				headerParameters.Authorization = `Bearer ${tokenString}`;
			}
		}
		if (this.configuration?.apiKey) {
			headerParameters["X-API-Key"] =
				await this.configuration.apiKey("X-API-Key"); // api_key authentication
		}

		let urlPath = `/api/identity/v1/users/{user_id}`;
		urlPath = urlPath.replace(
			`{${"user_id"}}`,
			encodeURIComponent(String(requestParameters.userId)),
		);

		const response = await this.request(
			{
				path: urlPath,
				method: "GET",
				headers: headerParameters,
				query: queryParameters,
			},
			initOverrides,
		);

		return new runtime.JSONApiResponse(response, (jsonValue) =>
			UserFromJSON(jsonValue),
		);
	}

	/**
	 * Retrieve a user by their unique identifier
	 * Get user
	 */
	async getUser(
		requestParameters: IdentityApiGetUserRequest,
		initOverrides?: RequestInit | runtime.InitOverrideFunction,
	): Promise<User> {
		const response = await this.getUserRaw(requestParameters, initOverrides);
		return await response.value();
	}

	/**
	 * List all members of a group
	 * List group members
	 */
	async listGroupMembersRaw(
		requestParameters: IdentityApiListGroupMembersRequest,
		initOverrides?: RequestInit | runtime.InitOverrideFunction,
	): Promise<runtime.ApiResponse<GroupMemberWithUserPaginatedResponse>> {
		if (requestParameters.groupId == null) {
			throw new runtime.RequiredError(
				"groupId",
				'Required parameter "groupId" was null or undefined when calling listGroupMembers().',
			);
		}

		if (requestParameters.pageSize == null) {
			throw new runtime.RequiredError(
				"pageSize",
				'Required parameter "pageSize" was null or undefined when calling listGroupMembers().',
			);
		}

		const queryParameters: any = {};

		if (requestParameters.pageSize != null) {
			queryParameters.page_size = requestParameters.pageSize;
		}

		if (requestParameters.nextPageToken != null) {
			queryParameters.next_page_token = requestParameters.nextPageToken;
		}

		const headerParameters: runtime.HTTPHeaders = {};

		if (this.configuration?.accessToken) {
			const token = this.configuration.accessToken;
			const tokenString = await token("bearer_token", []);

			if (tokenString) {
				headerParameters.Authorization = `Bearer ${tokenString}`;
			}
		}
		if (this.configuration?.apiKey) {
			headerParameters["X-API-Key"] =
				await this.configuration.apiKey("X-API-Key"); // api_key authentication
		}

		let urlPath = `/api/identity/v1/groups/{group_id}/members`;
		urlPath = urlPath.replace(
			`{${"group_id"}}`,
			encodeURIComponent(String(requestParameters.groupId)),
		);

		const response = await this.request(
			{
				path: urlPath,
				method: "GET",
				headers: headerParameters,
				query: queryParameters,
			},
			initOverrides,
		);

		return new runtime.JSONApiResponse(response, (jsonValue) =>
			GroupMemberWithUserPaginatedResponseFromJSON(jsonValue),
		);
	}

	/**
	 * List all members of a group
	 * List group members
	 */
	async listGroupMembers(
		requestParameters: IdentityApiListGroupMembersRequest,
		initOverrides?: RequestInit | runtime.InitOverrideFunction,
	): Promise<GroupMemberWithUserPaginatedResponse> {
		const response = await this.listGroupMembersRaw(
			requestParameters,
			initOverrides,
		);
		return await response.value();
	}

	/**
	 * List all groups with pagination
	 * List groups
	 */
	async listGroupsRaw(
		requestParameters: IdentityApiListGroupsRequest,
		initOverrides?: RequestInit | runtime.InitOverrideFunction,
	): Promise<runtime.ApiResponse<GroupPaginatedResponse>> {
		if (requestParameters.pageSize == null) {
			throw new runtime.RequiredError(
				"pageSize",
				'Required parameter "pageSize" was null or undefined when calling listGroups().',
			);
		}

		const queryParameters: any = {};

		if (requestParameters.pageSize != null) {
			queryParameters.page_size = requestParameters.pageSize;
		}

		if (requestParameters.nextPageToken != null) {
			queryParameters.next_page_token = requestParameters.nextPageToken;
		}

		const headerParameters: runtime.HTTPHeaders = {};

		if (this.configuration?.accessToken) {
			const token = this.configuration.accessToken;
			const tokenString = await token("bearer_token", []);

			if (tokenString) {
				headerParameters.Authorization = `Bearer ${tokenString}`;
			}
		}
		if (this.configuration?.apiKey) {
			headerParameters["X-API-Key"] =
				await this.configuration.apiKey("X-API-Key"); // api_key authentication
		}

		const urlPath = `/api/identity/v1/groups`;

		const response = await this.request(
			{
				path: urlPath,
				method: "GET",
				headers: headerParameters,
				query: queryParameters,
			},
			initOverrides,
		);

		return new runtime.JSONApiResponse(response, (jsonValue) =>
			GroupPaginatedResponseFromJSON(jsonValue),
		);
	}

	/**
	 * List all groups with pagination
	 * List groups
	 */
	async listGroups(
		requestParameters: IdentityApiListGroupsRequest,
		initOverrides?: RequestInit | runtime.InitOverrideFunction,
	): Promise<GroupPaginatedResponse> {
		const response = await this.listGroupsRaw(requestParameters, initOverrides);
		return await response.value();
	}

	/**
	 * List all groups that a user belongs to
	 * List user groups
	 */
	async listUserGroupsRaw(
		requestParameters: IdentityApiListUserGroupsRequest,
		initOverrides?: RequestInit | runtime.InitOverrideFunction,
	): Promise<runtime.ApiResponse<UserGroupWithGroupPaginatedResponse>> {
		if (requestParameters.userId == null) {
			throw new runtime.RequiredError(
				"userId",
				'Required parameter "userId" was null or undefined when calling listUserGroups().',
			);
		}

		if (requestParameters.pageSize == null) {
			throw new runtime.RequiredError(
				"pageSize",
				'Required parameter "pageSize" was null or undefined when calling listUserGroups().',
			);
		}

		const queryParameters: any = {};

		if (requestParameters.pageSize != null) {
			queryParameters.page_size = requestParameters.pageSize;
		}

		if (requestParameters.nextPageToken != null) {
			queryParameters.next_page_token = requestParameters.nextPageToken;
		}

		const headerParameters: runtime.HTTPHeaders = {};

		if (this.configuration?.accessToken) {
			const token = this.configuration.accessToken;
			const tokenString = await token("bearer_token", []);

			if (tokenString) {
				headerParameters.Authorization = `Bearer ${tokenString}`;
			}
		}
		if (this.configuration?.apiKey) {
			headerParameters["X-API-Key"] =
				await this.configuration.apiKey("X-API-Key"); // api_key authentication
		}

		let urlPath = `/api/identity/v1/users/{user_id}/groups`;
		urlPath = urlPath.replace(
			`{${"user_id"}}`,
			encodeURIComponent(String(requestParameters.userId)),
		);

		const response = await this.request(
			{
				path: urlPath,
				method: "GET",
				headers: headerParameters,
				query: queryParameters,
			},
			initOverrides,
		);

		return new runtime.JSONApiResponse(response, (jsonValue) =>
			UserGroupWithGroupPaginatedResponseFromJSON(jsonValue),
		);
	}

	/**
	 * List all groups that a user belongs to
	 * List user groups
	 */
	async listUserGroups(
		requestParameters: IdentityApiListUserGroupsRequest,
		initOverrides?: RequestInit | runtime.InitOverrideFunction,
	): Promise<UserGroupWithGroupPaginatedResponse> {
		const response = await this.listUserGroupsRaw(
			requestParameters,
			initOverrides,
		);
		return await response.value();
	}

	/**
	 * List all users with pagination and optional filtering
	 * List users
	 */
	async listUsersRaw(
		requestParameters: IdentityApiListUsersRequest,
		initOverrides?: RequestInit | runtime.InitOverrideFunction,
	): Promise<runtime.ApiResponse<UserPaginatedResponse>> {
		if (requestParameters.pageSize == null) {
			throw new runtime.RequiredError(
				"pageSize",
				'Required parameter "pageSize" was null or undefined when calling listUsers().',
			);
		}

		const queryParameters: any = {};

		if (requestParameters.pageSize != null) {
			queryParameters.page_size = requestParameters.pageSize;
		}

		if (requestParameters.nextPageToken != null) {
			queryParameters.next_page_token = requestParameters.nextPageToken;
		}

		if (requestParameters.userType != null) {
			queryParameters.user_type = requestParameters.userType;
		}

		if (requestParameters.role != null) {
			queryParameters.role = requestParameters.role;
		}

		const headerParameters: runtime.HTTPHeaders = {};

		if (this.configuration?.accessToken) {
			const token = this.configuration.accessToken;
			const tokenString = await token("bearer_token", []);

			if (tokenString) {
				headerParameters.Authorization = `Bearer ${tokenString}`;
			}
		}
		if (this.configuration?.apiKey) {
			headerParameters["X-API-Key"] =
				await this.configuration.apiKey("X-API-Key"); // api_key authentication
		}

		const urlPath = `/api/identity/v1/users`;

		const response = await this.request(
			{
				path: urlPath,
				method: "GET",
				headers: headerParameters,
				query: queryParameters,
			},
			initOverrides,
		);

		return new runtime.JSONApiResponse(response, (jsonValue) =>
			UserPaginatedResponseFromJSON(jsonValue),
		);
	}

	/**
	 * List all users with pagination and optional filtering
	 * List users
	 */
	async listUsers(
		requestParameters: IdentityApiListUsersRequest,
		initOverrides?: RequestInit | runtime.InitOverrideFunction,
	): Promise<UserPaginatedResponse> {
		const response = await this.listUsersRaw(requestParameters, initOverrides);
		return await response.value();
	}

	/**
	 * Remove a user from a group
	 * Remove group member
	 */
	async removeGroupMemberRaw(
		requestParameters: IdentityApiRemoveGroupMemberRequest,
		initOverrides?: RequestInit | runtime.InitOverrideFunction,
	): Promise<runtime.ApiResponse<void>> {
		if (requestParameters.groupId == null) {
			throw new runtime.RequiredError(
				"groupId",
				'Required parameter "groupId" was null or undefined when calling removeGroupMember().',
			);
		}

		if (requestParameters.userId == null) {
			throw new runtime.RequiredError(
				"userId",
				'Required parameter "userId" was null or undefined when calling removeGroupMember().',
			);
		}

		const queryParameters: any = {};

		const headerParameters: runtime.HTTPHeaders = {};

		if (this.configuration?.accessToken) {
			const token = this.configuration.accessToken;
			const tokenString = await token("bearer_token", []);

			if (tokenString) {
				headerParameters.Authorization = `Bearer ${tokenString}`;
			}
		}
		if (this.configuration?.apiKey) {
			headerParameters["X-API-Key"] =
				await this.configuration.apiKey("X-API-Key"); // api_key authentication
		}

		let urlPath = `/api/identity/v1/groups/{group_id}/members/{user_id}`;
		urlPath = urlPath.replace(
			`{${"group_id"}}`,
			encodeURIComponent(String(requestParameters.groupId)),
		);
		urlPath = urlPath.replace(
			`{${"user_id"}}`,
			encodeURIComponent(String(requestParameters.userId)),
		);

		const response = await this.request(
			{
				path: urlPath,
				method: "DELETE",
				headers: headerParameters,
				query: queryParameters,
			},
			initOverrides,
		);

		return new runtime.VoidApiResponse(response);
	}

	/**
	 * Remove a user from a group
	 * Remove group member
	 */
	async removeGroupMember(
		requestParameters: IdentityApiRemoveGroupMemberRequest,
		initOverrides?: RequestInit | runtime.InitOverrideFunction,
	): Promise<void> {
		await this.removeGroupMemberRaw(requestParameters, initOverrides);
	}

	/**
	 * Handles the OAuth/OIDC callback from the external IdP, exchanges the authorization code for tokens
	 * Authorization callback
	 */
	async routeAuthCallbackRaw(
		requestParameters: IdentityApiRouteAuthCallbackRequest,
		initOverrides?: RequestInit | runtime.InitOverrideFunction,
	): Promise<runtime.ApiResponse<void>> {
		const queryParameters: any = {};

		if (requestParameters.code != null) {
			queryParameters.code = requestParameters.code;
		}

		if (requestParameters.state != null) {
			queryParameters.state = requestParameters.state;
		}

		if (requestParameters.error != null) {
			queryParameters.error = requestParameters.error;
		}

		if (requestParameters.errorDescription != null) {
			queryParameters.error_description = requestParameters.errorDescription;
		}

		const headerParameters: runtime.HTTPHeaders = {};

		if (this.configuration?.accessToken) {
			const token = this.configuration.accessToken;
			const tokenString = await token("bearer_token", []);

			if (tokenString) {
				headerParameters.Authorization = `Bearer ${tokenString}`;
			}
		}
		if (this.configuration?.apiKey) {
			headerParameters["X-API-Key"] =
				await this.configuration.apiKey("X-API-Key"); // api_key authentication
		}

		const urlPath = `/api/identity/v1/auth/callback`;

		const response = await this.request(
			{
				path: urlPath,
				method: "GET",
				headers: headerParameters,
				query: queryParameters,
			},
			initOverrides,
		);

		return new runtime.VoidApiResponse(response);
	}

	/**
	 * Handles the OAuth/OIDC callback from the external IdP, exchanges the authorization code for tokens
	 * Authorization callback
	 */
	async routeAuthCallback(
		requestParameters: IdentityApiRouteAuthCallbackRequest = {},
		initOverrides?: RequestInit | runtime.InitOverrideFunction,
	): Promise<void> {
		await this.routeAuthCallbackRaw(requestParameters, initOverrides);
	}

	/**
	 */
	async routeCreateApiKeyRaw(
		requestParameters: IdentityApiRouteCreateApiKeyRequest,
		initOverrides?: RequestInit | runtime.InitOverrideFunction,
	): Promise<runtime.ApiResponse<CreateApiKeyResponse>> {
		if (requestParameters.createApiKeyParams == null) {
			throw new runtime.RequiredError(
				"createApiKeyParams",
				'Required parameter "createApiKeyParams" was null or undefined when calling routeCreateApiKey().',
			);
		}

		const queryParameters: any = {};

		const headerParameters: runtime.HTTPHeaders = {};

		headerParameters["Content-Type"] = "application/json";

		if (this.configuration?.accessToken) {
			const token = this.configuration.accessToken;
			const tokenString = await token("bearer_token", []);

			if (tokenString) {
				headerParameters.Authorization = `Bearer ${tokenString}`;
			}
		}
		if (this.configuration?.apiKey) {
			headerParameters["X-API-Key"] =
				await this.configuration.apiKey("X-API-Key"); // api_key authentication
		}

		const urlPath = `/api/identity/v1/api-key`;

		const response = await this.request(
			{
				path: urlPath,
				method: "POST",
				headers: headerParameters,
				query: queryParameters,
				body: CreateApiKeyParamsToJSON(requestParameters.createApiKeyParams),
			},
			initOverrides,
		);

		return new runtime.JSONApiResponse(response, (jsonValue) =>
			CreateApiKeyResponseFromJSON(jsonValue),
		);
	}

	/**
	 */
	async routeCreateApiKey(
		requestParameters: IdentityApiRouteCreateApiKeyRequest,
		initOverrides?: RequestInit | runtime.InitOverrideFunction,
	): Promise<CreateApiKeyResponse> {
		const response = await this.routeCreateApiKeyRaw(
			requestParameters,
			initOverrides,
		);
		return await response.value();
	}

	/**
	 * Create a new STS configuration (e.g., JWT template or dev settings)
	 * Create STS configuration
	 */
	async routeCreateStsConfigRaw(
		requestParameters: IdentityApiRouteCreateStsConfigRequest,
		initOverrides?: RequestInit | runtime.InitOverrideFunction,
	): Promise<runtime.ApiResponse<StsTokenConfig>> {
		if (requestParameters.stsTokenConfig == null) {
			throw new runtime.RequiredError(
				"stsTokenConfig",
				'Required parameter "stsTokenConfig" was null or undefined when calling routeCreateStsConfig().',
			);
		}

		const queryParameters: any = {};

		const headerParameters: runtime.HTTPHeaders = {};

		headerParameters["Content-Type"] = "application/json";

		if (this.configuration?.accessToken) {
			const token = this.configuration.accessToken;
			const tokenString = await token("bearer_token", []);

			if (tokenString) {
				headerParameters.Authorization = `Bearer ${tokenString}`;
			}
		}
		if (this.configuration?.apiKey) {
			headerParameters["X-API-Key"] =
				await this.configuration.apiKey("X-API-Key"); // api_key authentication
		}

		const urlPath = `/api/identity/v1/sts-configuration`;

		const response = await this.request(
			{
				path: urlPath,
				method: "POST",
				headers: headerParameters,
				query: queryParameters,
				body: StsTokenConfigToJSON(requestParameters.stsTokenConfig),
			},
			initOverrides,
		);

		return new runtime.JSONApiResponse(response, (jsonValue) =>
			StsTokenConfigFromJSON(jsonValue),
		);
	}

	/**
	 * Create a new STS configuration (e.g., JWT template or dev settings)
	 * Create STS configuration
	 */
	async routeCreateStsConfig(
		requestParameters: IdentityApiRouteCreateStsConfigRequest,
		initOverrides?: RequestInit | runtime.InitOverrideFunction,
	): Promise<StsTokenConfig> {
		const response = await this.routeCreateStsConfigRaw(
			requestParameters,
			initOverrides,
		);
		return await response.value();
	}

	/**
	 * Create a new user auth flow configuration for OAuth/OIDC authorization flows. The configuration will be encrypted before storage.
	 * Create user auth flow configuration
	 */
	async routeCreateUserAuthFlowConfigRaw(
		requestParameters: IdentityApiRouteCreateUserAuthFlowConfigRequest,
		initOverrides?: RequestInit | runtime.InitOverrideFunction,
	): Promise<runtime.ApiResponse<CreateUserAuthFlowConfigResponse>> {
		if (requestParameters.createUserAuthFlowConfigParams == null) {
			throw new runtime.RequiredError(
				"createUserAuthFlowConfigParams",
				'Required parameter "createUserAuthFlowConfigParams" was null or undefined when calling routeCreateUserAuthFlowConfig().',
			);
		}

		const queryParameters: any = {};

		const headerParameters: runtime.HTTPHeaders = {};

		headerParameters["Content-Type"] = "application/json";

		if (this.configuration?.accessToken) {
			const token = this.configuration.accessToken;
			const tokenString = await token("bearer_token", []);

			if (tokenString) {
				headerParameters.Authorization = `Bearer ${tokenString}`;
			}
		}
		if (this.configuration?.apiKey) {
			headerParameters["X-API-Key"] =
				await this.configuration.apiKey("X-API-Key"); // api_key authentication
		}

		const urlPath = `/api/identity/v1/user-auth-flow-config`;

		const response = await this.request(
			{
				path: urlPath,
				method: "POST",
				headers: headerParameters,
				query: queryParameters,
				body: CreateUserAuthFlowConfigParamsToJSON(
					requestParameters.createUserAuthFlowConfigParams,
				),
			},
			initOverrides,
		);

		return new runtime.JSONApiResponse(response, (jsonValue) =>
			CreateUserAuthFlowConfigResponseFromJSON(jsonValue),
		);
	}

	/**
	 * Create a new user auth flow configuration for OAuth/OIDC authorization flows. The configuration will be encrypted before storage.
	 * Create user auth flow configuration
	 */
	async routeCreateUserAuthFlowConfig(
		requestParameters: IdentityApiRouteCreateUserAuthFlowConfigRequest,
		initOverrides?: RequestInit | runtime.InitOverrideFunction,
	): Promise<CreateUserAuthFlowConfigResponse> {
		const response = await this.routeCreateUserAuthFlowConfigRaw(
			requestParameters,
			initOverrides,
		);
		return await response.value();
	}

	/**
	 */
	async routeDeleteApiKeyRaw(
		requestParameters: IdentityApiRouteDeleteApiKeyRequest,
		initOverrides?: RequestInit | runtime.InitOverrideFunction,
	): Promise<runtime.ApiResponse<any>> {
		if (requestParameters.id == null) {
			throw new runtime.RequiredError(
				"id",
				'Required parameter "id" was null or undefined when calling routeDeleteApiKey().',
			);
		}

		const queryParameters: any = {};

		const headerParameters: runtime.HTTPHeaders = {};

		if (this.configuration?.accessToken) {
			const token = this.configuration.accessToken;
			const tokenString = await token("bearer_token", []);

			if (tokenString) {
				headerParameters.Authorization = `Bearer ${tokenString}`;
			}
		}
		if (this.configuration?.apiKey) {
			headerParameters["X-API-Key"] =
				await this.configuration.apiKey("X-API-Key"); // api_key authentication
		}

		let urlPath = `/api/identity/v1/api-key/{id}`;
		urlPath = urlPath.replace(
			`{${"id"}}`,
			encodeURIComponent(String(requestParameters.id)),
		);

		const response = await this.request(
			{
				path: urlPath,
				method: "DELETE",
				headers: headerParameters,
				query: queryParameters,
			},
			initOverrides,
		);

		if (this.isJsonMime(response.headers.get("content-type"))) {
			return new runtime.JSONApiResponse<any>(response);
		} else {
			return new runtime.TextApiResponse(response) as any;
		}
	}

	/**
	 */
	async routeDeleteApiKey(
		requestParameters: IdentityApiRouteDeleteApiKeyRequest,
		initOverrides?: RequestInit | runtime.InitOverrideFunction,
	): Promise<any> {
		const response = await this.routeDeleteApiKeyRaw(
			requestParameters,
			initOverrides,
		);
		return await response.value();
	}

	/**
	 * Delete an STS configuration by ID
	 * Delete STS configuration
	 */
	async routeDeleteStsConfigRaw(
		requestParameters: IdentityApiRouteDeleteStsConfigRequest,
		initOverrides?: RequestInit | runtime.InitOverrideFunction,
	): Promise<runtime.ApiResponse<any>> {
		if (requestParameters.id == null) {
			throw new runtime.RequiredError(
				"id",
				'Required parameter "id" was null or undefined when calling routeDeleteStsConfig().',
			);
		}

		const queryParameters: any = {};

		const headerParameters: runtime.HTTPHeaders = {};

		if (this.configuration?.accessToken) {
			const token = this.configuration.accessToken;
			const tokenString = await token("bearer_token", []);

			if (tokenString) {
				headerParameters.Authorization = `Bearer ${tokenString}`;
			}
		}
		if (this.configuration?.apiKey) {
			headerParameters["X-API-Key"] =
				await this.configuration.apiKey("X-API-Key"); // api_key authentication
		}

		let urlPath = `/api/identity/v1/sts-configuration/{id}`;
		urlPath = urlPath.replace(
			`{${"id"}}`,
			encodeURIComponent(String(requestParameters.id)),
		);

		const response = await this.request(
			{
				path: urlPath,
				method: "DELETE",
				headers: headerParameters,
				query: queryParameters,
			},
			initOverrides,
		);

		if (this.isJsonMime(response.headers.get("content-type"))) {
			return new runtime.JSONApiResponse<any>(response);
		} else {
			return new runtime.TextApiResponse(response) as any;
		}
	}

	/**
	 * Delete an STS configuration by ID
	 * Delete STS configuration
	 */
	async routeDeleteStsConfig(
		requestParameters: IdentityApiRouteDeleteStsConfigRequest,
		initOverrides?: RequestInit | runtime.InitOverrideFunction,
	): Promise<any> {
		const response = await this.routeDeleteStsConfigRaw(
			requestParameters,
			initOverrides,
		);
		return await response.value();
	}

	/**
	 * Delete a user auth flow configuration by ID
	 * Delete user auth flow configuration
	 */
	async routeDeleteUserAuthFlowConfigRaw(
		requestParameters: IdentityApiRouteDeleteUserAuthFlowConfigRequest,
		initOverrides?: RequestInit | runtime.InitOverrideFunction,
	): Promise<runtime.ApiResponse<any>> {
		if (requestParameters.id == null) {
			throw new runtime.RequiredError(
				"id",
				'Required parameter "id" was null or undefined when calling routeDeleteUserAuthFlowConfig().',
			);
		}

		const queryParameters: any = {};

		const headerParameters: runtime.HTTPHeaders = {};

		if (this.configuration?.accessToken) {
			const token = this.configuration.accessToken;
			const tokenString = await token("bearer_token", []);

			if (tokenString) {
				headerParameters.Authorization = `Bearer ${tokenString}`;
			}
		}
		if (this.configuration?.apiKey) {
			headerParameters["X-API-Key"] =
				await this.configuration.apiKey("X-API-Key"); // api_key authentication
		}

		let urlPath = `/api/identity/v1/user-auth-flow-config/{id}`;
		urlPath = urlPath.replace(
			`{${"id"}}`,
			encodeURIComponent(String(requestParameters.id)),
		);

		const response = await this.request(
			{
				path: urlPath,
				method: "DELETE",
				headers: headerParameters,
				query: queryParameters,
			},
			initOverrides,
		);

		if (this.isJsonMime(response.headers.get("content-type"))) {
			return new runtime.JSONApiResponse<any>(response);
		} else {
			return new runtime.TextApiResponse(response) as any;
		}
	}

	/**
	 * Delete a user auth flow configuration by ID
	 * Delete user auth flow configuration
	 */
	async routeDeleteUserAuthFlowConfig(
		requestParameters: IdentityApiRouteDeleteUserAuthFlowConfigRequest,
		initOverrides?: RequestInit | runtime.InitOverrideFunction,
	): Promise<any> {
		const response = await this.routeDeleteUserAuthFlowConfigRaw(
			requestParameters,
			initOverrides,
		);
		return await response.value();
	}

	/**
	 * Exchange an external token for internal access and refresh tokens using an STS configuration
	 * Exchange STS token
	 */
	async routeExchangeStsTokenRaw(
		requestParameters: IdentityApiRouteExchangeStsTokenRequest,
		initOverrides?: RequestInit | runtime.InitOverrideFunction,
	): Promise<runtime.ApiResponse<NormalizedTokenIssuanceResult>> {
		if (requestParameters.stsConfigId == null) {
			throw new runtime.RequiredError(
				"stsConfigId",
				'Required parameter "stsConfigId" was null or undefined when calling routeExchangeStsToken().',
			);
		}

		const queryParameters: any = {};

		const headerParameters: runtime.HTTPHeaders = {};

		if (this.configuration?.accessToken) {
			const token = this.configuration.accessToken;
			const tokenString = await token("bearer_token", []);

			if (tokenString) {
				headerParameters.Authorization = `Bearer ${tokenString}`;
			}
		}
		if (this.configuration?.apiKey) {
			headerParameters["X-API-Key"] =
				await this.configuration.apiKey("X-API-Key"); // api_key authentication
		}

		let urlPath = `/api/identity/v1/sts/{sts_config_id}`;
		urlPath = urlPath.replace(
			`{${"sts_config_id"}}`,
			encodeURIComponent(String(requestParameters.stsConfigId)),
		);

		const response = await this.request(
			{
				path: urlPath,
				method: "POST",
				headers: headerParameters,
				query: queryParameters,
			},
			initOverrides,
		);

		return new runtime.JSONApiResponse(response, (jsonValue) =>
			NormalizedTokenIssuanceResultFromJSON(jsonValue),
		);
	}

	/**
	 * Exchange an external token for internal access and refresh tokens using an STS configuration
	 * Exchange STS token
	 */
	async routeExchangeStsToken(
		requestParameters: IdentityApiRouteExchangeStsTokenRequest,
		initOverrides?: RequestInit | runtime.InitOverrideFunction,
	): Promise<NormalizedTokenIssuanceResult> {
		const response = await this.routeExchangeStsTokenRaw(
			requestParameters,
			initOverrides,
		);
		return await response.value();
	}

	/**
	 */
	async routeGetJwksRaw(
		initOverrides?: RequestInit | runtime.InitOverrideFunction,
	): Promise<runtime.ApiResponse<JwksResponse>> {
		const queryParameters: any = {};

		const headerParameters: runtime.HTTPHeaders = {};

		if (this.configuration?.accessToken) {
			const token = this.configuration.accessToken;
			const tokenString = await token("bearer_token", []);

			if (tokenString) {
				headerParameters.Authorization = `Bearer ${tokenString}`;
			}
		}
		if (this.configuration?.apiKey) {
			headerParameters["X-API-Key"] =
				await this.configuration.apiKey("X-API-Key"); // api_key authentication
		}

		const urlPath = `/api/identity/v1/.well-known/jwks.json`;

		const response = await this.request(
			{
				path: urlPath,
				method: "GET",
				headers: headerParameters,
				query: queryParameters,
			},
			initOverrides,
		);

		return new runtime.JSONApiResponse(response, (jsonValue) =>
			JwksResponseFromJSON(jsonValue),
		);
	}

	/**
	 */
	async routeGetJwks(
		initOverrides?: RequestInit | runtime.InitOverrideFunction,
	): Promise<JwksResponse> {
		const response = await this.routeGetJwksRaw(initOverrides);
		return await response.value();
	}

	/**
	 * Get an STS configuration by ID
	 * Get STS configuration
	 */
	async routeGetStsConfigRaw(
		requestParameters: IdentityApiRouteGetStsConfigRequest,
		initOverrides?: RequestInit | runtime.InitOverrideFunction,
	): Promise<runtime.ApiResponse<StsTokenConfig>> {
		if (requestParameters.id == null) {
			throw new runtime.RequiredError(
				"id",
				'Required parameter "id" was null or undefined when calling routeGetStsConfig().',
			);
		}

		const queryParameters: any = {};

		const headerParameters: runtime.HTTPHeaders = {};

		if (this.configuration?.accessToken) {
			const token = this.configuration.accessToken;
			const tokenString = await token("bearer_token", []);

			if (tokenString) {
				headerParameters.Authorization = `Bearer ${tokenString}`;
			}
		}
		if (this.configuration?.apiKey) {
			headerParameters["X-API-Key"] =
				await this.configuration.apiKey("X-API-Key"); // api_key authentication
		}

		let urlPath = `/api/identity/v1/sts-configuration/{id}`;
		urlPath = urlPath.replace(
			`{${"id"}}`,
			encodeURIComponent(String(requestParameters.id)),
		);

		const response = await this.request(
			{
				path: urlPath,
				method: "GET",
				headers: headerParameters,
				query: queryParameters,
			},
			initOverrides,
		);

		return new runtime.JSONApiResponse(response, (jsonValue) =>
			StsTokenConfigFromJSON(jsonValue),
		);
	}

	/**
	 * Get an STS configuration by ID
	 * Get STS configuration
	 */
	async routeGetStsConfig(
		requestParameters: IdentityApiRouteGetStsConfigRequest,
		initOverrides?: RequestInit | runtime.InitOverrideFunction,
	): Promise<StsTokenConfig> {
		const response = await this.routeGetStsConfigRaw(
			requestParameters,
			initOverrides,
		);
		return await response.value();
	}

	/**
	 * Get a user auth flow configuration by ID. Returns the encrypted configuration.
	 * Get user auth flow configuration
	 */
	async routeGetUserAuthFlowConfigRaw(
		requestParameters: IdentityApiRouteGetUserAuthFlowConfigRequest,
		initOverrides?: RequestInit | runtime.InitOverrideFunction,
	): Promise<runtime.ApiResponse<GetUserAuthFlowConfigResponse>> {
		if (requestParameters.id == null) {
			throw new runtime.RequiredError(
				"id",
				'Required parameter "id" was null or undefined when calling routeGetUserAuthFlowConfig().',
			);
		}

		const queryParameters: any = {};

		const headerParameters: runtime.HTTPHeaders = {};

		if (this.configuration?.accessToken) {
			const token = this.configuration.accessToken;
			const tokenString = await token("bearer_token", []);

			if (tokenString) {
				headerParameters.Authorization = `Bearer ${tokenString}`;
			}
		}
		if (this.configuration?.apiKey) {
			headerParameters["X-API-Key"] =
				await this.configuration.apiKey("X-API-Key"); // api_key authentication
		}

		let urlPath = `/api/identity/v1/user-auth-flow-config/{id}`;
		urlPath = urlPath.replace(
			`{${"id"}}`,
			encodeURIComponent(String(requestParameters.id)),
		);

		const response = await this.request(
			{
				path: urlPath,
				method: "GET",
				headers: headerParameters,
				query: queryParameters,
			},
			initOverrides,
		);

		return new runtime.JSONApiResponse(response, (jsonValue) =>
			GetUserAuthFlowConfigResponseFromJSON(jsonValue),
		);
	}

	/**
	 * Get a user auth flow configuration by ID. Returns the encrypted configuration.
	 * Get user auth flow configuration
	 */
	async routeGetUserAuthFlowConfig(
		requestParameters: IdentityApiRouteGetUserAuthFlowConfigRequest,
		initOverrides?: RequestInit | runtime.InitOverrideFunction,
	): Promise<GetUserAuthFlowConfigResponse> {
		const response = await this.routeGetUserAuthFlowConfigRaw(
			requestParameters,
			initOverrides,
		);
		return await response.value();
	}

	/**
	 */
	async routeImportApiKeyRaw(
		requestParameters: IdentityApiRouteImportApiKeyRequest,
		initOverrides?: RequestInit | runtime.InitOverrideFunction,
	): Promise<runtime.ApiResponse<any>> {
		if (requestParameters.encryptedApiKeyConfig == null) {
			throw new runtime.RequiredError(
				"encryptedApiKeyConfig",
				'Required parameter "encryptedApiKeyConfig" was null or undefined when calling routeImportApiKey().',
			);
		}

		const queryParameters: any = {};

		const headerParameters: runtime.HTTPHeaders = {};

		headerParameters["Content-Type"] = "application/json";

		if (this.configuration?.accessToken) {
			const token = this.configuration.accessToken;
			const tokenString = await token("bearer_token", []);

			if (tokenString) {
				headerParameters.Authorization = `Bearer ${tokenString}`;
			}
		}
		if (this.configuration?.apiKey) {
			headerParameters["X-API-Key"] =
				await this.configuration.apiKey("X-API-Key"); // api_key authentication
		}

		const urlPath = `/api/identity/v1/api-key/import`;

		const response = await this.request(
			{
				path: urlPath,
				method: "POST",
				headers: headerParameters,
				query: queryParameters,
				body: EncryptedApiKeyConfigToJSON(
					requestParameters.encryptedApiKeyConfig,
				),
			},
			initOverrides,
		);

		if (this.isJsonMime(response.headers.get("content-type"))) {
			return new runtime.JSONApiResponse<any>(response);
		} else {
			return new runtime.TextApiResponse(response) as any;
		}
	}

	/**
	 */
	async routeImportApiKey(
		requestParameters: IdentityApiRouteImportApiKeyRequest,
		initOverrides?: RequestInit | runtime.InitOverrideFunction,
	): Promise<any> {
		const response = await this.routeImportApiKeyRaw(
			requestParameters,
			initOverrides,
		);
		return await response.value();
	}

	/**
	 * Import an already encrypted user auth flow configuration (idempotent, used for syncing from soma.yaml)
	 * Import user auth flow configuration
	 */
	async routeImportUserAuthFlowConfigRaw(
		requestParameters: IdentityApiRouteImportUserAuthFlowConfigRequest,
		initOverrides?: RequestInit | runtime.InitOverrideFunction,
	): Promise<runtime.ApiResponse<any>> {
		if (requestParameters.importUserAuthFlowConfigParams == null) {
			throw new runtime.RequiredError(
				"importUserAuthFlowConfigParams",
				'Required parameter "importUserAuthFlowConfigParams" was null or undefined when calling routeImportUserAuthFlowConfig().',
			);
		}

		const queryParameters: any = {};

		const headerParameters: runtime.HTTPHeaders = {};

		headerParameters["Content-Type"] = "application/json";

		if (this.configuration?.accessToken) {
			const token = this.configuration.accessToken;
			const tokenString = await token("bearer_token", []);

			if (tokenString) {
				headerParameters.Authorization = `Bearer ${tokenString}`;
			}
		}
		if (this.configuration?.apiKey) {
			headerParameters["X-API-Key"] =
				await this.configuration.apiKey("X-API-Key"); // api_key authentication
		}

		const urlPath = `/api/identity/v1/user-auth-flow-config/import`;

		const response = await this.request(
			{
				path: urlPath,
				method: "POST",
				headers: headerParameters,
				query: queryParameters,
				body: ImportUserAuthFlowConfigParamsToJSON(
					requestParameters.importUserAuthFlowConfigParams,
				),
			},
			initOverrides,
		);

		if (this.isJsonMime(response.headers.get("content-type"))) {
			return new runtime.JSONApiResponse<any>(response);
		} else {
			return new runtime.TextApiResponse(response) as any;
		}
	}

	/**
	 * Import an already encrypted user auth flow configuration (idempotent, used for syncing from soma.yaml)
	 * Import user auth flow configuration
	 */
	async routeImportUserAuthFlowConfig(
		requestParameters: IdentityApiRouteImportUserAuthFlowConfigRequest,
		initOverrides?: RequestInit | runtime.InitOverrideFunction,
	): Promise<any> {
		const response = await this.routeImportUserAuthFlowConfigRaw(
			requestParameters,
			initOverrides,
		);
		return await response.value();
	}

	/**
	 */
	async routeInvalidateJwkRaw(
		requestParameters: IdentityApiRouteInvalidateJwkRequest,
		initOverrides?: RequestInit | runtime.InitOverrideFunction,
	): Promise<runtime.ApiResponse<void>> {
		if (requestParameters.kid == null) {
			throw new runtime.RequiredError(
				"kid",
				'Required parameter "kid" was null or undefined when calling routeInvalidateJwk().',
			);
		}

		const queryParameters: any = {};

		const headerParameters: runtime.HTTPHeaders = {};

		if (this.configuration?.accessToken) {
			const token = this.configuration.accessToken;
			const tokenString = await token("bearer_token", []);

			if (tokenString) {
				headerParameters.Authorization = `Bearer ${tokenString}`;
			}
		}
		if (this.configuration?.apiKey) {
			headerParameters["X-API-Key"] =
				await this.configuration.apiKey("X-API-Key"); // api_key authentication
		}

		let urlPath = `/api/identity/v1/jwk/{kid}/invalidate`;
		urlPath = urlPath.replace(
			`{${"kid"}}`,
			encodeURIComponent(String(requestParameters.kid)),
		);

		const response = await this.request(
			{
				path: urlPath,
				method: "POST",
				headers: headerParameters,
				query: queryParameters,
			},
			initOverrides,
		);

		return new runtime.VoidApiResponse(response);
	}

	/**
	 */
	async routeInvalidateJwk(
		requestParameters: IdentityApiRouteInvalidateJwkRequest,
		initOverrides?: RequestInit | runtime.InitOverrideFunction,
	): Promise<void> {
		await this.routeInvalidateJwkRaw(requestParameters, initOverrides);
	}

	/**
	 */
	async routeListApiKeysRaw(
		requestParameters: IdentityApiRouteListApiKeysRequest,
		initOverrides?: RequestInit | runtime.InitOverrideFunction,
	): Promise<runtime.ApiResponse<ListApiKeysResponse>> {
		if (requestParameters.pageSize == null) {
			throw new runtime.RequiredError(
				"pageSize",
				'Required parameter "pageSize" was null or undefined when calling routeListApiKeys().',
			);
		}

		const queryParameters: any = {};

		if (requestParameters.pageSize != null) {
			queryParameters.page_size = requestParameters.pageSize;
		}

		if (requestParameters.nextPageToken != null) {
			queryParameters.next_page_token = requestParameters.nextPageToken;
		}

		const headerParameters: runtime.HTTPHeaders = {};

		if (this.configuration?.accessToken) {
			const token = this.configuration.accessToken;
			const tokenString = await token("bearer_token", []);

			if (tokenString) {
				headerParameters.Authorization = `Bearer ${tokenString}`;
			}
		}
		if (this.configuration?.apiKey) {
			headerParameters["X-API-Key"] =
				await this.configuration.apiKey("X-API-Key"); // api_key authentication
		}

		const urlPath = `/api/identity/v1/api-key`;

		const response = await this.request(
			{
				path: urlPath,
				method: "GET",
				headers: headerParameters,
				query: queryParameters,
			},
			initOverrides,
		);

		return new runtime.JSONApiResponse(response, (jsonValue) =>
			ListApiKeysResponseFromJSON(jsonValue),
		);
	}

	/**
	 */
	async routeListApiKeys(
		requestParameters: IdentityApiRouteListApiKeysRequest,
		initOverrides?: RequestInit | runtime.InitOverrideFunction,
	): Promise<ListApiKeysResponse> {
		const response = await this.routeListApiKeysRaw(
			requestParameters,
			initOverrides,
		);
		return await response.value();
	}

	/**
	 */
	async routeListJwksRaw(
		requestParameters: IdentityApiRouteListJwksRequest,
		initOverrides?: RequestInit | runtime.InitOverrideFunction,
	): Promise<runtime.ApiResponse<JwkResponsePaginatedResponse>> {
		if (requestParameters.pageSize == null) {
			throw new runtime.RequiredError(
				"pageSize",
				'Required parameter "pageSize" was null or undefined when calling routeListJwks().',
			);
		}

		const queryParameters: any = {};

		if (requestParameters.pageSize != null) {
			queryParameters.page_size = requestParameters.pageSize;
		}

		if (requestParameters.nextPageToken != null) {
			queryParameters.next_page_token = requestParameters.nextPageToken;
		}

		const headerParameters: runtime.HTTPHeaders = {};

		if (this.configuration?.accessToken) {
			const token = this.configuration.accessToken;
			const tokenString = await token("bearer_token", []);

			if (tokenString) {
				headerParameters.Authorization = `Bearer ${tokenString}`;
			}
		}
		if (this.configuration?.apiKey) {
			headerParameters["X-API-Key"] =
				await this.configuration.apiKey("X-API-Key"); // api_key authentication
		}

		const urlPath = `/api/identity/v1/jwk`;

		const response = await this.request(
			{
				path: urlPath,
				method: "GET",
				headers: headerParameters,
				query: queryParameters,
			},
			initOverrides,
		);

		return new runtime.JSONApiResponse(response, (jsonValue) =>
			JwkResponsePaginatedResponseFromJSON(jsonValue),
		);
	}

	/**
	 */
	async routeListJwks(
		requestParameters: IdentityApiRouteListJwksRequest,
		initOverrides?: RequestInit | runtime.InitOverrideFunction,
	): Promise<JwkResponsePaginatedResponse> {
		const response = await this.routeListJwksRaw(
			requestParameters,
			initOverrides,
		);
		return await response.value();
	}

	/**
	 * List all STS configurations with optional filtering by type
	 * List STS configurations
	 */
	async routeListStsConfigsRaw(
		requestParameters: IdentityApiRouteListStsConfigsRequest,
		initOverrides?: RequestInit | runtime.InitOverrideFunction,
	): Promise<runtime.ApiResponse<StsTokenConfigPaginatedResponse>> {
		if (requestParameters.pageSize == null) {
			throw new runtime.RequiredError(
				"pageSize",
				'Required parameter "pageSize" was null or undefined when calling routeListStsConfigs().',
			);
		}

		const queryParameters: any = {};

		if (requestParameters.pageSize != null) {
			queryParameters.page_size = requestParameters.pageSize;
		}

		if (requestParameters.nextPageToken != null) {
			queryParameters.next_page_token = requestParameters.nextPageToken;
		}

		const headerParameters: runtime.HTTPHeaders = {};

		if (this.configuration?.accessToken) {
			const token = this.configuration.accessToken;
			const tokenString = await token("bearer_token", []);

			if (tokenString) {
				headerParameters.Authorization = `Bearer ${tokenString}`;
			}
		}
		if (this.configuration?.apiKey) {
			headerParameters["X-API-Key"] =
				await this.configuration.apiKey("X-API-Key"); // api_key authentication
		}

		const urlPath = `/api/identity/v1/sts-configuration`;

		const response = await this.request(
			{
				path: urlPath,
				method: "GET",
				headers: headerParameters,
				query: queryParameters,
			},
			initOverrides,
		);

		return new runtime.JSONApiResponse(response, (jsonValue) =>
			StsTokenConfigPaginatedResponseFromJSON(jsonValue),
		);
	}

	/**
	 * List all STS configurations with optional filtering by type
	 * List STS configurations
	 */
	async routeListStsConfigs(
		requestParameters: IdentityApiRouteListStsConfigsRequest,
		initOverrides?: RequestInit | runtime.InitOverrideFunction,
	): Promise<StsTokenConfigPaginatedResponse> {
		const response = await this.routeListStsConfigsRaw(
			requestParameters,
			initOverrides,
		);
		return await response.value();
	}

	/**
	 * List all user auth flow configurations with optional filtering by type
	 * List user auth flow configurations
	 */
	async routeListUserAuthFlowConfigsRaw(
		requestParameters: IdentityApiRouteListUserAuthFlowConfigsRequest,
		initOverrides?: RequestInit | runtime.InitOverrideFunction,
	): Promise<runtime.ApiResponse<ListUserAuthFlowConfigResponse>> {
		const queryParameters: any = {};

		if (requestParameters.pageSize != null) {
			queryParameters.page_size = requestParameters.pageSize;
		}

		if (requestParameters.nextPageToken != null) {
			queryParameters.next_page_token = requestParameters.nextPageToken;
		}

		if (requestParameters.type != null) {
			queryParameters.type = requestParameters.type;
		}

		const headerParameters: runtime.HTTPHeaders = {};

		if (this.configuration?.accessToken) {
			const token = this.configuration.accessToken;
			const tokenString = await token("bearer_token", []);

			if (tokenString) {
				headerParameters.Authorization = `Bearer ${tokenString}`;
			}
		}
		if (this.configuration?.apiKey) {
			headerParameters["X-API-Key"] =
				await this.configuration.apiKey("X-API-Key"); // api_key authentication
		}

		const urlPath = `/api/identity/v1/user-auth-flow-config`;

		const response = await this.request(
			{
				path: urlPath,
				method: "GET",
				headers: headerParameters,
				query: queryParameters,
			},
			initOverrides,
		);

		return new runtime.JSONApiResponse(response, (jsonValue) =>
			ListUserAuthFlowConfigResponseFromJSON(jsonValue),
		);
	}

	/**
	 * List all user auth flow configurations with optional filtering by type
	 * List user auth flow configurations
	 */
	async routeListUserAuthFlowConfigs(
		requestParameters: IdentityApiRouteListUserAuthFlowConfigsRequest = {},
		initOverrides?: RequestInit | runtime.InitOverrideFunction,
	): Promise<ListUserAuthFlowConfigResponse> {
		const response = await this.routeListUserAuthFlowConfigsRaw(
			requestParameters,
			initOverrides,
		);
		return await response.value();
	}

	/**
	 * Refreshes an access token using a refresh token from the request body or cookie
	 * Refresh access token
	 */
	async routeRefreshTokenRaw(
		requestParameters: IdentityApiRouteRefreshTokenRequest,
		initOverrides?: RequestInit | runtime.InitOverrideFunction,
	): Promise<runtime.ApiResponse<TokenResponse>> {
		const queryParameters: any = {};

		const headerParameters: runtime.HTTPHeaders = {};

		headerParameters["Content-Type"] = "application/json";

		if (this.configuration?.accessToken) {
			const token = this.configuration.accessToken;
			const tokenString = await token("bearer_token", []);

			if (tokenString) {
				headerParameters.Authorization = `Bearer ${tokenString}`;
			}
		}
		if (this.configuration?.apiKey) {
			headerParameters["X-API-Key"] =
				await this.configuration.apiKey("X-API-Key"); // api_key authentication
		}

		const urlPath = `/api/identity/v1/auth/refresh`;

		const response = await this.request(
			{
				path: urlPath,
				method: "POST",
				headers: headerParameters,
				query: queryParameters,
				body: RefreshTokenRequestToJSON(requestParameters.refreshTokenRequest),
			},
			initOverrides,
		);

		return new runtime.JSONApiResponse(response, (jsonValue) =>
			TokenResponseFromJSON(jsonValue),
		);
	}

	/**
	 * Refreshes an access token using a refresh token from the request body or cookie
	 * Refresh access token
	 */
	async routeRefreshToken(
		requestParameters: IdentityApiRouteRefreshTokenRequest = {},
		initOverrides?: RequestInit | runtime.InitOverrideFunction,
	): Promise<TokenResponse> {
		const response = await this.routeRefreshTokenRaw(
			requestParameters,
			initOverrides,
		);
		return await response.value();
	}

	/**
	 * Initiates the OAuth/OIDC authorization flow by redirecting to the external IdP
	 * Start authorization
	 */
	async routeStartAuthorizationRaw(
		requestParameters: IdentityApiRouteStartAuthorizationRequest,
		initOverrides?: RequestInit | runtime.InitOverrideFunction,
	): Promise<runtime.ApiResponse<void>> {
		if (requestParameters.configId == null) {
			throw new runtime.RequiredError(
				"configId",
				'Required parameter "configId" was null or undefined when calling routeStartAuthorization().',
			);
		}

		const queryParameters: any = {};

		if (requestParameters.redirectAfterLogin != null) {
			queryParameters.redirect_after_login =
				requestParameters.redirectAfterLogin;
		}

		const headerParameters: runtime.HTTPHeaders = {};

		if (this.configuration?.accessToken) {
			const token = this.configuration.accessToken;
			const tokenString = await token("bearer_token", []);

			if (tokenString) {
				headerParameters.Authorization = `Bearer ${tokenString}`;
			}
		}
		if (this.configuration?.apiKey) {
			headerParameters["X-API-Key"] =
				await this.configuration.apiKey("X-API-Key"); // api_key authentication
		}

		let urlPath = `/api/identity/v1/auth/authorize/{config_id}`;
		urlPath = urlPath.replace(
			`{${"config_id"}}`,
			encodeURIComponent(String(requestParameters.configId)),
		);

		const response = await this.request(
			{
				path: urlPath,
				method: "GET",
				headers: headerParameters,
				query: queryParameters,
			},
			initOverrides,
		);

		return new runtime.VoidApiResponse(response);
	}

	/**
	 * Initiates the OAuth/OIDC authorization flow by redirecting to the external IdP
	 * Start authorization
	 */
	async routeStartAuthorization(
		requestParameters: IdentityApiRouteStartAuthorizationRequest,
		initOverrides?: RequestInit | runtime.InitOverrideFunction,
	): Promise<void> {
		await this.routeStartAuthorizationRaw(requestParameters, initOverrides);
	}

	/**
	 * Returns the current authenticated identity based on the request headers (Authorization header, cookies, or API key)
	 * Get current identity
	 */
	async routeWhoamiRaw(
		initOverrides?: RequestInit | runtime.InitOverrideFunction,
	): Promise<runtime.ApiResponse<Identity>> {
		const queryParameters: any = {};

		const headerParameters: runtime.HTTPHeaders = {};

		if (this.configuration?.accessToken) {
			const token = this.configuration.accessToken;
			const tokenString = await token("bearer_token", []);

			if (tokenString) {
				headerParameters.Authorization = `Bearer ${tokenString}`;
			}
		}
		if (this.configuration?.apiKey) {
			headerParameters["X-API-Key"] =
				await this.configuration.apiKey("X-API-Key"); // api_key authentication
		}

		const urlPath = `/api/identity/v1/auth/whoami`;

		const response = await this.request(
			{
				path: urlPath,
				method: "GET",
				headers: headerParameters,
				query: queryParameters,
			},
			initOverrides,
		);

		return new runtime.JSONApiResponse(response, (jsonValue) =>
			IdentityFromJSON(jsonValue),
		);
	}

	/**
	 * Returns the current authenticated identity based on the request headers (Authorization header, cookies, or API key)
	 * Get current identity
	 */
	async routeWhoami(
		initOverrides?: RequestInit | runtime.InitOverrideFunction,
	): Promise<Identity> {
		const response = await this.routeWhoamiRaw(initOverrides);
		return await response.value();
	}

	/**
	 * Update a group\'s name
	 * Update group
	 */
	async updateGroupRaw(
		requestParameters: IdentityApiUpdateGroupOperationRequest,
		initOverrides?: RequestInit | runtime.InitOverrideFunction,
	): Promise<runtime.ApiResponse<Group>> {
		if (requestParameters.groupId == null) {
			throw new runtime.RequiredError(
				"groupId",
				'Required parameter "groupId" was null or undefined when calling updateGroup().',
			);
		}

		if (requestParameters.updateGroupRequest == null) {
			throw new runtime.RequiredError(
				"updateGroupRequest",
				'Required parameter "updateGroupRequest" was null or undefined when calling updateGroup().',
			);
		}

		const queryParameters: any = {};

		const headerParameters: runtime.HTTPHeaders = {};

		headerParameters["Content-Type"] = "application/json";

		if (this.configuration?.accessToken) {
			const token = this.configuration.accessToken;
			const tokenString = await token("bearer_token", []);

			if (tokenString) {
				headerParameters.Authorization = `Bearer ${tokenString}`;
			}
		}
		if (this.configuration?.apiKey) {
			headerParameters["X-API-Key"] =
				await this.configuration.apiKey("X-API-Key"); // api_key authentication
		}

		let urlPath = `/api/identity/v1/groups/{group_id}`;
		urlPath = urlPath.replace(
			`{${"group_id"}}`,
			encodeURIComponent(String(requestParameters.groupId)),
		);

		const response = await this.request(
			{
				path: urlPath,
				method: "PATCH",
				headers: headerParameters,
				query: queryParameters,
				body: UpdateGroupRequestToJSON(requestParameters.updateGroupRequest),
			},
			initOverrides,
		);

		return new runtime.JSONApiResponse(response, (jsonValue) =>
			GroupFromJSON(jsonValue),
		);
	}

	/**
	 * Update a group\'s name
	 * Update group
	 */
	async updateGroup(
		requestParameters: IdentityApiUpdateGroupOperationRequest,
		initOverrides?: RequestInit | runtime.InitOverrideFunction,
	): Promise<Group> {
		const response = await this.updateGroupRaw(
			requestParameters,
			initOverrides,
		);
		return await response.value();
	}

	/**
	 * Update a user\'s attributes
	 * Update user
	 */
	async updateUserRaw(
		requestParameters: IdentityApiUpdateUserOperationRequest,
		initOverrides?: RequestInit | runtime.InitOverrideFunction,
	): Promise<runtime.ApiResponse<User>> {
		if (requestParameters.userId == null) {
			throw new runtime.RequiredError(
				"userId",
				'Required parameter "userId" was null or undefined when calling updateUser().',
			);
		}

		if (requestParameters.updateUserRequest == null) {
			throw new runtime.RequiredError(
				"updateUserRequest",
				'Required parameter "updateUserRequest" was null or undefined when calling updateUser().',
			);
		}

		const queryParameters: any = {};

		const headerParameters: runtime.HTTPHeaders = {};

		headerParameters["Content-Type"] = "application/json";

		if (this.configuration?.accessToken) {
			const token = this.configuration.accessToken;
			const tokenString = await token("bearer_token", []);

			if (tokenString) {
				headerParameters.Authorization = `Bearer ${tokenString}`;
			}
		}
		if (this.configuration?.apiKey) {
			headerParameters["X-API-Key"] =
				await this.configuration.apiKey("X-API-Key"); // api_key authentication
		}

		let urlPath = `/api/identity/v1/users/{user_id}`;
		urlPath = urlPath.replace(
			`{${"user_id"}}`,
			encodeURIComponent(String(requestParameters.userId)),
		);

		const response = await this.request(
			{
				path: urlPath,
				method: "PATCH",
				headers: headerParameters,
				query: queryParameters,
				body: UpdateUserRequestToJSON(requestParameters.updateUserRequest),
			},
			initOverrides,
		);

		return new runtime.JSONApiResponse(response, (jsonValue) =>
			UserFromJSON(jsonValue),
		);
	}

	/**
	 * Update a user\'s attributes
	 * Update user
	 */
	async updateUser(
		requestParameters: IdentityApiUpdateUserOperationRequest,
		initOverrides?: RequestInit | runtime.InitOverrideFunction,
	): Promise<User> {
		const response = await this.updateUserRaw(requestParameters, initOverrides);
		return await response.value();
	}
}
