/* tslint:disable */
/* eslint-disable */
/**
 * soma
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: v1
 *
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

import type {
	CreateProviderInstanceParamsInner,
	CreateResourceServerCredentialParamsInner,
	CreateUserCredentialParamsInner,
	EncryptCredentialConfigurationParamsInner,
	FunctionInstanceConfigPaginatedResponse,
	FunctionInstanceSerialized,
	FunctionInstanceSerializedPaginatedResponse,
	InvokeFunctionParamsInner,
	InvokeResult,
	ProviderControllerSerializedPaginatedResponse,
	ProviderInstanceListItemPaginatedResponse,
	ProviderInstanceSerialized,
	ProviderInstanceSerializedWithEverything,
	ResourceServerCredentialSerialized,
	StartUserCredentialBrokeringParamsInner,
	UpdateProviderInstanceParamsInner,
	UserCredentialBrokeringResponse,
	UserCredentialSerialized,
} from "../models/index";
import {
	CreateProviderInstanceParamsInnerToJSON,
	CreateResourceServerCredentialParamsInnerToJSON,
	CreateUserCredentialParamsInnerToJSON,
	EncryptCredentialConfigurationParamsInnerToJSON,
	FunctionInstanceConfigPaginatedResponseFromJSON,
	FunctionInstanceSerializedFromJSON,
	FunctionInstanceSerializedPaginatedResponseFromJSON,
	InvokeFunctionParamsInnerToJSON,
	InvokeResultFromJSON,
	ProviderControllerSerializedPaginatedResponseFromJSON,
	ProviderInstanceListItemPaginatedResponseFromJSON,
	ProviderInstanceSerializedFromJSON,
	ProviderInstanceSerializedWithEverythingFromJSON,
	ResourceServerCredentialSerializedFromJSON,
	StartUserCredentialBrokeringParamsInnerToJSON,
	UpdateProviderInstanceParamsInnerToJSON,
	UserCredentialBrokeringResponseFromJSON,
	UserCredentialSerializedFromJSON,
} from "../models/index";
import * as runtime from "../runtime";

export interface BridgeApiCreateProviderInstanceRequest {
	providerControllerTypeId: string;
	credentialControllerTypeId: string;
	createProviderInstanceParamsInner: CreateProviderInstanceParamsInner;
}

export interface BridgeApiCreateResourceServerCredentialRequest {
	providerControllerTypeId: string;
	credentialControllerTypeId: string;
	createResourceServerCredentialParamsInner: CreateResourceServerCredentialParamsInner;
}

export interface BridgeApiCreateUserCredentialRequest {
	providerControllerTypeId: string;
	credentialControllerTypeId: string;
	createUserCredentialParamsInner: CreateUserCredentialParamsInner;
}

export interface BridgeApiDeleteProviderInstanceRequest {
	providerInstanceId: string;
}

export interface BridgeApiDisableFunctionRequest {
	providerInstanceId: string;
	functionControllerTypeId: string;
}

export interface BridgeApiEnableFunctionRequest {
	providerInstanceId: string;
	functionControllerTypeId: string;
	body: object;
}

export interface BridgeApiEncryptResourceServerConfigurationRequest {
	providerControllerTypeId: string;
	credentialControllerTypeId: string;
	encryptCredentialConfigurationParamsInner: EncryptCredentialConfigurationParamsInner;
}

export interface BridgeApiEncryptUserCredentialConfigurationRequest {
	providerControllerTypeId: string;
	credentialControllerTypeId: string;
	encryptCredentialConfigurationParamsInner: EncryptCredentialConfigurationParamsInner;
}

export interface BridgeApiGetProviderInstanceRequest {
	providerInstanceId: string;
}

export interface BridgeApiInvokeFunctionRequest {
	providerInstanceId: string;
	functionControllerTypeId: string;
	invokeFunctionParamsInner: InvokeFunctionParamsInner;
}

export interface BridgeApiListAvailableProvidersRequest {
	pageSize: number;
	nextPageToken?: string;
}

export interface BridgeApiListFunctionInstancesRequest {
	pageSize: number;
	nextPageToken?: string;
	providerInstanceId?: string;
}

export interface BridgeApiListProviderInstancesRequest {
	pageSize: number;
	nextPageToken?: string;
	status?: string;
	providerControllerTypeId?: string;
}

export interface BridgeApiListProviderInstancesGroupedByFunctionRequest {
	pageSize: number;
	nextPageToken?: string | null;
	providerControllerTypeId?: string | null;
	functionCategory?: string | null;
}

export interface BridgeApiResumeUserCredentialBrokeringRequest {
	state?: string;
	code?: string;
	error?: string;
	errorDescription?: string;
}

export interface BridgeApiStartUserCredentialBrokeringRequest {
	providerControllerTypeId: string;
	credentialControllerTypeId: string;
	startUserCredentialBrokeringParamsInner: StartUserCredentialBrokeringParamsInner;
}

export interface BridgeApiTriggerMcpMessageRequest {
	body: object;
}

export interface BridgeApiUpdateProviderInstanceRequest {
	providerInstanceId: string;
	updateProviderInstanceParamsInner: UpdateProviderInstanceParamsInner;
}

/**
 *
 */
export class BridgeApi extends runtime.BaseAPI {
	/**
	 * Create a new provider instance with the specified configuration
	 * Create provider
	 */
	async createProviderInstanceRaw(
		requestParameters: BridgeApiCreateProviderInstanceRequest,
		initOverrides?: RequestInit | runtime.InitOverrideFunction,
	): Promise<runtime.ApiResponse<ProviderInstanceSerialized>> {
		if (requestParameters.providerControllerTypeId == null) {
			throw new runtime.RequiredError(
				"providerControllerTypeId",
				'Required parameter "providerControllerTypeId" was null or undefined when calling createProviderInstance().',
			);
		}

		if (requestParameters.credentialControllerTypeId == null) {
			throw new runtime.RequiredError(
				"credentialControllerTypeId",
				'Required parameter "credentialControllerTypeId" was null or undefined when calling createProviderInstance().',
			);
		}

		if (requestParameters.createProviderInstanceParamsInner == null) {
			throw new runtime.RequiredError(
				"createProviderInstanceParamsInner",
				'Required parameter "createProviderInstanceParamsInner" was null or undefined when calling createProviderInstance().',
			);
		}

		const queryParameters: any = {};

		const headerParameters: runtime.HTTPHeaders = {};

		headerParameters["Content-Type"] = "application/json";

		let urlPath = `/api/bridge/v1/available-providers/{provider_controller_type_id}/available-credentials/{credential_controller_type_id}`;
		urlPath = urlPath.replace(
			`{${"provider_controller_type_id"}}`,
			encodeURIComponent(String(requestParameters.providerControllerTypeId)),
		);
		urlPath = urlPath.replace(
			`{${"credential_controller_type_id"}}`,
			encodeURIComponent(String(requestParameters.credentialControllerTypeId)),
		);

		const response = await this.request(
			{
				path: urlPath,
				method: "POST",
				headers: headerParameters,
				query: queryParameters,
				body: CreateProviderInstanceParamsInnerToJSON(
					requestParameters.createProviderInstanceParamsInner,
				),
			},
			initOverrides,
		);

		return new runtime.JSONApiResponse(response, (jsonValue) =>
			ProviderInstanceSerializedFromJSON(jsonValue),
		);
	}

	/**
	 * Create a new provider instance with the specified configuration
	 * Create provider
	 */
	async createProviderInstance(
		requestParameters: BridgeApiCreateProviderInstanceRequest,
		initOverrides?: RequestInit | runtime.InitOverrideFunction,
	): Promise<ProviderInstanceSerialized> {
		const response = await this.createProviderInstanceRaw(
			requestParameters,
			initOverrides,
		);
		return await response.value();
	}

	/**
	 * Create a new resource server credential
	 * Create resource server credential
	 */
	async createResourceServerCredentialRaw(
		requestParameters: BridgeApiCreateResourceServerCredentialRequest,
		initOverrides?: RequestInit | runtime.InitOverrideFunction,
	): Promise<runtime.ApiResponse<ResourceServerCredentialSerialized>> {
		if (requestParameters.providerControllerTypeId == null) {
			throw new runtime.RequiredError(
				"providerControllerTypeId",
				'Required parameter "providerControllerTypeId" was null or undefined when calling createResourceServerCredential().',
			);
		}

		if (requestParameters.credentialControllerTypeId == null) {
			throw new runtime.RequiredError(
				"credentialControllerTypeId",
				'Required parameter "credentialControllerTypeId" was null or undefined when calling createResourceServerCredential().',
			);
		}

		if (requestParameters.createResourceServerCredentialParamsInner == null) {
			throw new runtime.RequiredError(
				"createResourceServerCredentialParamsInner",
				'Required parameter "createResourceServerCredentialParamsInner" was null or undefined when calling createResourceServerCredential().',
			);
		}

		const queryParameters: any = {};

		const headerParameters: runtime.HTTPHeaders = {};

		headerParameters["Content-Type"] = "application/json";

		let urlPath = `/api/bridge/v1/available-providers/{provider_controller_type_id}/available-credentials/{credential_controller_type_id}/credential/resource-server`;
		urlPath = urlPath.replace(
			`{${"provider_controller_type_id"}}`,
			encodeURIComponent(String(requestParameters.providerControllerTypeId)),
		);
		urlPath = urlPath.replace(
			`{${"credential_controller_type_id"}}`,
			encodeURIComponent(String(requestParameters.credentialControllerTypeId)),
		);

		const response = await this.request(
			{
				path: urlPath,
				method: "POST",
				headers: headerParameters,
				query: queryParameters,
				body: CreateResourceServerCredentialParamsInnerToJSON(
					requestParameters.createResourceServerCredentialParamsInner,
				),
			},
			initOverrides,
		);

		return new runtime.JSONApiResponse(response, (jsonValue) =>
			ResourceServerCredentialSerializedFromJSON(jsonValue),
		);
	}

	/**
	 * Create a new resource server credential
	 * Create resource server credential
	 */
	async createResourceServerCredential(
		requestParameters: BridgeApiCreateResourceServerCredentialRequest,
		initOverrides?: RequestInit | runtime.InitOverrideFunction,
	): Promise<ResourceServerCredentialSerialized> {
		const response = await this.createResourceServerCredentialRaw(
			requestParameters,
			initOverrides,
		);
		return await response.value();
	}

	/**
	 * Create a new user credential
	 * Create user credential
	 */
	async createUserCredentialRaw(
		requestParameters: BridgeApiCreateUserCredentialRequest,
		initOverrides?: RequestInit | runtime.InitOverrideFunction,
	): Promise<runtime.ApiResponse<UserCredentialSerialized>> {
		if (requestParameters.providerControllerTypeId == null) {
			throw new runtime.RequiredError(
				"providerControllerTypeId",
				'Required parameter "providerControllerTypeId" was null or undefined when calling createUserCredential().',
			);
		}

		if (requestParameters.credentialControllerTypeId == null) {
			throw new runtime.RequiredError(
				"credentialControllerTypeId",
				'Required parameter "credentialControllerTypeId" was null or undefined when calling createUserCredential().',
			);
		}

		if (requestParameters.createUserCredentialParamsInner == null) {
			throw new runtime.RequiredError(
				"createUserCredentialParamsInner",
				'Required parameter "createUserCredentialParamsInner" was null or undefined when calling createUserCredential().',
			);
		}

		const queryParameters: any = {};

		const headerParameters: runtime.HTTPHeaders = {};

		headerParameters["Content-Type"] = "application/json";

		let urlPath = `/api/bridge/v1/available-providers/{provider_controller_type_id}/available-credentials/{credential_controller_type_id}/credential/user-credential`;
		urlPath = urlPath.replace(
			`{${"provider_controller_type_id"}}`,
			encodeURIComponent(String(requestParameters.providerControllerTypeId)),
		);
		urlPath = urlPath.replace(
			`{${"credential_controller_type_id"}}`,
			encodeURIComponent(String(requestParameters.credentialControllerTypeId)),
		);

		const response = await this.request(
			{
				path: urlPath,
				method: "POST",
				headers: headerParameters,
				query: queryParameters,
				body: CreateUserCredentialParamsInnerToJSON(
					requestParameters.createUserCredentialParamsInner,
				),
			},
			initOverrides,
		);

		return new runtime.JSONApiResponse(response, (jsonValue) =>
			UserCredentialSerializedFromJSON(jsonValue),
		);
	}

	/**
	 * Create a new user credential
	 * Create user credential
	 */
	async createUserCredential(
		requestParameters: BridgeApiCreateUserCredentialRequest,
		initOverrides?: RequestInit | runtime.InitOverrideFunction,
	): Promise<UserCredentialSerialized> {
		const response = await this.createUserCredentialRaw(
			requestParameters,
			initOverrides,
		);
		return await response.value();
	}

	/**
	 * Delete a provider instance by its unique identifier
	 * Delete provider
	 */
	async deleteProviderInstanceRaw(
		requestParameters: BridgeApiDeleteProviderInstanceRequest,
		initOverrides?: RequestInit | runtime.InitOverrideFunction,
	): Promise<runtime.ApiResponse<any>> {
		if (requestParameters.providerInstanceId == null) {
			throw new runtime.RequiredError(
				"providerInstanceId",
				'Required parameter "providerInstanceId" was null or undefined when calling deleteProviderInstance().',
			);
		}

		const queryParameters: any = {};

		const headerParameters: runtime.HTTPHeaders = {};

		let urlPath = `/api/bridge/v1/provider/{provider_instance_id}`;
		urlPath = urlPath.replace(
			`{${"provider_instance_id"}}`,
			encodeURIComponent(String(requestParameters.providerInstanceId)),
		);

		const response = await this.request(
			{
				path: urlPath,
				method: "DELETE",
				headers: headerParameters,
				query: queryParameters,
			},
			initOverrides,
		);

		if (this.isJsonMime(response.headers.get("content-type"))) {
			return new runtime.JSONApiResponse<any>(response);
		} else {
			return new runtime.TextApiResponse(response) as any;
		}
	}

	/**
	 * Delete a provider instance by its unique identifier
	 * Delete provider
	 */
	async deleteProviderInstance(
		requestParameters: BridgeApiDeleteProviderInstanceRequest,
		initOverrides?: RequestInit | runtime.InitOverrideFunction,
	): Promise<any> {
		const response = await this.deleteProviderInstanceRaw(
			requestParameters,
			initOverrides,
		);
		return await response.value();
	}

	/**
	 * Disable a function for a provider instance
	 * Disable function
	 */
	async disableFunctionRaw(
		requestParameters: BridgeApiDisableFunctionRequest,
		initOverrides?: RequestInit | runtime.InitOverrideFunction,
	): Promise<runtime.ApiResponse<any>> {
		if (requestParameters.providerInstanceId == null) {
			throw new runtime.RequiredError(
				"providerInstanceId",
				'Required parameter "providerInstanceId" was null or undefined when calling disableFunction().',
			);
		}

		if (requestParameters.functionControllerTypeId == null) {
			throw new runtime.RequiredError(
				"functionControllerTypeId",
				'Required parameter "functionControllerTypeId" was null or undefined when calling disableFunction().',
			);
		}

		const queryParameters: any = {};

		const headerParameters: runtime.HTTPHeaders = {};

		let urlPath = `/api/bridge/v1/provider/{provider_instance_id}/function/{function_controller_type_id}/disable`;
		urlPath = urlPath.replace(
			`{${"provider_instance_id"}}`,
			encodeURIComponent(String(requestParameters.providerInstanceId)),
		);
		urlPath = urlPath.replace(
			`{${"function_controller_type_id"}}`,
			encodeURIComponent(String(requestParameters.functionControllerTypeId)),
		);

		const response = await this.request(
			{
				path: urlPath,
				method: "POST",
				headers: headerParameters,
				query: queryParameters,
			},
			initOverrides,
		);

		if (this.isJsonMime(response.headers.get("content-type"))) {
			return new runtime.JSONApiResponse<any>(response);
		} else {
			return new runtime.TextApiResponse(response) as any;
		}
	}

	/**
	 * Disable a function for a provider instance
	 * Disable function
	 */
	async disableFunction(
		requestParameters: BridgeApiDisableFunctionRequest,
		initOverrides?: RequestInit | runtime.InitOverrideFunction,
	): Promise<any> {
		const response = await this.disableFunctionRaw(
			requestParameters,
			initOverrides,
		);
		return await response.value();
	}

	/**
	 * Enable a function for a provider instance
	 * Enable function
	 */
	async enableFunctionRaw(
		requestParameters: BridgeApiEnableFunctionRequest,
		initOverrides?: RequestInit | runtime.InitOverrideFunction,
	): Promise<runtime.ApiResponse<FunctionInstanceSerialized>> {
		if (requestParameters.providerInstanceId == null) {
			throw new runtime.RequiredError(
				"providerInstanceId",
				'Required parameter "providerInstanceId" was null or undefined when calling enableFunction().',
			);
		}

		if (requestParameters.functionControllerTypeId == null) {
			throw new runtime.RequiredError(
				"functionControllerTypeId",
				'Required parameter "functionControllerTypeId" was null or undefined when calling enableFunction().',
			);
		}

		if (requestParameters.body == null) {
			throw new runtime.RequiredError(
				"body",
				'Required parameter "body" was null or undefined when calling enableFunction().',
			);
		}

		const queryParameters: any = {};

		const headerParameters: runtime.HTTPHeaders = {};

		headerParameters["Content-Type"] = "application/json";

		let urlPath = `/api/bridge/v1/provider/{provider_instance_id}/function/{function_controller_type_id}/enable`;
		urlPath = urlPath.replace(
			`{${"provider_instance_id"}}`,
			encodeURIComponent(String(requestParameters.providerInstanceId)),
		);
		urlPath = urlPath.replace(
			`{${"function_controller_type_id"}}`,
			encodeURIComponent(String(requestParameters.functionControllerTypeId)),
		);

		const response = await this.request(
			{
				path: urlPath,
				method: "POST",
				headers: headerParameters,
				query: queryParameters,
				body: requestParameters.body as any,
			},
			initOverrides,
		);

		return new runtime.JSONApiResponse(response, (jsonValue) =>
			FunctionInstanceSerializedFromJSON(jsonValue),
		);
	}

	/**
	 * Enable a function for a provider instance
	 * Enable function
	 */
	async enableFunction(
		requestParameters: BridgeApiEnableFunctionRequest,
		initOverrides?: RequestInit | runtime.InitOverrideFunction,
	): Promise<FunctionInstanceSerialized> {
		const response = await this.enableFunctionRaw(
			requestParameters,
			initOverrides,
		);
		return await response.value();
	}

	/**
	 * Encrypt a resource server credential configuration before storage
	 * Encrypt resource server config
	 */
	async encryptResourceServerConfigurationRaw(
		requestParameters: BridgeApiEncryptResourceServerConfigurationRequest,
		initOverrides?: RequestInit | runtime.InitOverrideFunction,
	): Promise<runtime.ApiResponse<any>> {
		if (requestParameters.providerControllerTypeId == null) {
			throw new runtime.RequiredError(
				"providerControllerTypeId",
				'Required parameter "providerControllerTypeId" was null or undefined when calling encryptResourceServerConfiguration().',
			);
		}

		if (requestParameters.credentialControllerTypeId == null) {
			throw new runtime.RequiredError(
				"credentialControllerTypeId",
				'Required parameter "credentialControllerTypeId" was null or undefined when calling encryptResourceServerConfiguration().',
			);
		}

		if (requestParameters.encryptCredentialConfigurationParamsInner == null) {
			throw new runtime.RequiredError(
				"encryptCredentialConfigurationParamsInner",
				'Required parameter "encryptCredentialConfigurationParamsInner" was null or undefined when calling encryptResourceServerConfiguration().',
			);
		}

		const queryParameters: any = {};

		const headerParameters: runtime.HTTPHeaders = {};

		headerParameters["Content-Type"] = "application/json";

		let urlPath = `/api/bridge/v1/available-providers/{provider_controller_type_id}/available-credentials/{credential_controller_type_id}/credential/resource-server/encrypt`;
		urlPath = urlPath.replace(
			`{${"provider_controller_type_id"}}`,
			encodeURIComponent(String(requestParameters.providerControllerTypeId)),
		);
		urlPath = urlPath.replace(
			`{${"credential_controller_type_id"}}`,
			encodeURIComponent(String(requestParameters.credentialControllerTypeId)),
		);

		const response = await this.request(
			{
				path: urlPath,
				method: "POST",
				headers: headerParameters,
				query: queryParameters,
				body: EncryptCredentialConfigurationParamsInnerToJSON(
					requestParameters.encryptCredentialConfigurationParamsInner,
				),
			},
			initOverrides,
		);

		if (this.isJsonMime(response.headers.get("content-type"))) {
			return new runtime.JSONApiResponse<any>(response);
		} else {
			return new runtime.TextApiResponse(response) as any;
		}
	}

	/**
	 * Encrypt a resource server credential configuration before storage
	 * Encrypt resource server config
	 */
	async encryptResourceServerConfiguration(
		requestParameters: BridgeApiEncryptResourceServerConfigurationRequest,
		initOverrides?: RequestInit | runtime.InitOverrideFunction,
	): Promise<any> {
		const response = await this.encryptResourceServerConfigurationRaw(
			requestParameters,
			initOverrides,
		);
		return await response.value();
	}

	/**
	 * Encrypt a user credential configuration before storage
	 * Encrypt user credential config
	 */
	async encryptUserCredentialConfigurationRaw(
		requestParameters: BridgeApiEncryptUserCredentialConfigurationRequest,
		initOverrides?: RequestInit | runtime.InitOverrideFunction,
	): Promise<runtime.ApiResponse<any>> {
		if (requestParameters.providerControllerTypeId == null) {
			throw new runtime.RequiredError(
				"providerControllerTypeId",
				'Required parameter "providerControllerTypeId" was null or undefined when calling encryptUserCredentialConfiguration().',
			);
		}

		if (requestParameters.credentialControllerTypeId == null) {
			throw new runtime.RequiredError(
				"credentialControllerTypeId",
				'Required parameter "credentialControllerTypeId" was null or undefined when calling encryptUserCredentialConfiguration().',
			);
		}

		if (requestParameters.encryptCredentialConfigurationParamsInner == null) {
			throw new runtime.RequiredError(
				"encryptCredentialConfigurationParamsInner",
				'Required parameter "encryptCredentialConfigurationParamsInner" was null or undefined when calling encryptUserCredentialConfiguration().',
			);
		}

		const queryParameters: any = {};

		const headerParameters: runtime.HTTPHeaders = {};

		headerParameters["Content-Type"] = "application/json";

		let urlPath = `/api/bridge/v1/available-providers/{provider_controller_type_id}/available-credentials/{credential_controller_type_id}/credential/user-credential/encrypt`;
		urlPath = urlPath.replace(
			`{${"provider_controller_type_id"}}`,
			encodeURIComponent(String(requestParameters.providerControllerTypeId)),
		);
		urlPath = urlPath.replace(
			`{${"credential_controller_type_id"}}`,
			encodeURIComponent(String(requestParameters.credentialControllerTypeId)),
		);

		const response = await this.request(
			{
				path: urlPath,
				method: "POST",
				headers: headerParameters,
				query: queryParameters,
				body: EncryptCredentialConfigurationParamsInnerToJSON(
					requestParameters.encryptCredentialConfigurationParamsInner,
				),
			},
			initOverrides,
		);

		if (this.isJsonMime(response.headers.get("content-type"))) {
			return new runtime.JSONApiResponse<any>(response);
		} else {
			return new runtime.TextApiResponse(response) as any;
		}
	}

	/**
	 * Encrypt a user credential configuration before storage
	 * Encrypt user credential config
	 */
	async encryptUserCredentialConfiguration(
		requestParameters: BridgeApiEncryptUserCredentialConfigurationRequest,
		initOverrides?: RequestInit | runtime.InitOverrideFunction,
	): Promise<any> {
		const response = await this.encryptUserCredentialConfigurationRaw(
			requestParameters,
			initOverrides,
		);
		return await response.value();
	}

	/**
	 * Get the OpenAPI specification for all function instances
	 * Get function OpenAPI spec
	 */
	async getFunctionInstancesOpenapiSpecRaw(
		initOverrides?: RequestInit | runtime.InitOverrideFunction,
	): Promise<runtime.ApiResponse<string>> {
		const queryParameters: any = {};

		const headerParameters: runtime.HTTPHeaders = {};

		const urlPath = `/api/bridge/v1/function-instances/openapi.json`;

		const response = await this.request(
			{
				path: urlPath,
				method: "GET",
				headers: headerParameters,
				query: queryParameters,
			},
			initOverrides,
		);

		if (this.isJsonMime(response.headers.get("content-type"))) {
			return new runtime.JSONApiResponse<string>(response);
		} else {
			return new runtime.TextApiResponse(response) as any;
		}
	}

	/**
	 * Get the OpenAPI specification for all function instances
	 * Get function OpenAPI spec
	 */
	async getFunctionInstancesOpenapiSpec(
		initOverrides?: RequestInit | runtime.InitOverrideFunction,
	): Promise<string> {
		const response =
			await this.getFunctionInstancesOpenapiSpecRaw(initOverrides);
		return await response.value();
	}

	/**
	 * Retrieve a provider instance by its unique identifier
	 * Get provider
	 */
	async getProviderInstanceRaw(
		requestParameters: BridgeApiGetProviderInstanceRequest,
		initOverrides?: RequestInit | runtime.InitOverrideFunction,
	): Promise<runtime.ApiResponse<ProviderInstanceSerializedWithEverything>> {
		if (requestParameters.providerInstanceId == null) {
			throw new runtime.RequiredError(
				"providerInstanceId",
				'Required parameter "providerInstanceId" was null or undefined when calling getProviderInstance().',
			);
		}

		const queryParameters: any = {};

		const headerParameters: runtime.HTTPHeaders = {};

		let urlPath = `/api/bridge/v1/provider/{provider_instance_id}`;
		urlPath = urlPath.replace(
			`{${"provider_instance_id"}}`,
			encodeURIComponent(String(requestParameters.providerInstanceId)),
		);

		const response = await this.request(
			{
				path: urlPath,
				method: "GET",
				headers: headerParameters,
				query: queryParameters,
			},
			initOverrides,
		);

		return new runtime.JSONApiResponse(response, (jsonValue) =>
			ProviderInstanceSerializedWithEverythingFromJSON(jsonValue),
		);
	}

	/**
	 * Retrieve a provider instance by its unique identifier
	 * Get provider
	 */
	async getProviderInstance(
		requestParameters: BridgeApiGetProviderInstanceRequest,
		initOverrides?: RequestInit | runtime.InitOverrideFunction,
	): Promise<ProviderInstanceSerializedWithEverything> {
		const response = await this.getProviderInstanceRaw(
			requestParameters,
			initOverrides,
		);
		return await response.value();
	}

	/**
	 * Invoke a function on a provider instance
	 * Invoke function
	 */
	async invokeFunctionRaw(
		requestParameters: BridgeApiInvokeFunctionRequest,
		initOverrides?: RequestInit | runtime.InitOverrideFunction,
	): Promise<runtime.ApiResponse<InvokeResult>> {
		if (requestParameters.providerInstanceId == null) {
			throw new runtime.RequiredError(
				"providerInstanceId",
				'Required parameter "providerInstanceId" was null or undefined when calling invokeFunction().',
			);
		}

		if (requestParameters.functionControllerTypeId == null) {
			throw new runtime.RequiredError(
				"functionControllerTypeId",
				'Required parameter "functionControllerTypeId" was null or undefined when calling invokeFunction().',
			);
		}

		if (requestParameters.invokeFunctionParamsInner == null) {
			throw new runtime.RequiredError(
				"invokeFunctionParamsInner",
				'Required parameter "invokeFunctionParamsInner" was null or undefined when calling invokeFunction().',
			);
		}

		const queryParameters: any = {};

		const headerParameters: runtime.HTTPHeaders = {};

		headerParameters["Content-Type"] = "application/json";

		let urlPath = `/api/bridge/v1/provider/{provider_instance_id}/function/{function_controller_type_id}/invoke`;
		urlPath = urlPath.replace(
			`{${"provider_instance_id"}}`,
			encodeURIComponent(String(requestParameters.providerInstanceId)),
		);
		urlPath = urlPath.replace(
			`{${"function_controller_type_id"}}`,
			encodeURIComponent(String(requestParameters.functionControllerTypeId)),
		);

		const response = await this.request(
			{
				path: urlPath,
				method: "POST",
				headers: headerParameters,
				query: queryParameters,
				body: InvokeFunctionParamsInnerToJSON(
					requestParameters.invokeFunctionParamsInner,
				),
			},
			initOverrides,
		);

		return new runtime.JSONApiResponse(response, (jsonValue) =>
			InvokeResultFromJSON(jsonValue),
		);
	}

	/**
	 * Invoke a function on a provider instance
	 * Invoke function
	 */
	async invokeFunction(
		requestParameters: BridgeApiInvokeFunctionRequest,
		initOverrides?: RequestInit | runtime.InitOverrideFunction,
	): Promise<InvokeResult> {
		const response = await this.invokeFunctionRaw(
			requestParameters,
			initOverrides,
		);
		return await response.value();
	}

	/**
	 * List all available provider types that can be instantiated
	 * List providers
	 */
	async listAvailableProvidersRaw(
		requestParameters: BridgeApiListAvailableProvidersRequest,
		initOverrides?: RequestInit | runtime.InitOverrideFunction,
	): Promise<
		runtime.ApiResponse<ProviderControllerSerializedPaginatedResponse>
	> {
		if (requestParameters.pageSize == null) {
			throw new runtime.RequiredError(
				"pageSize",
				'Required parameter "pageSize" was null or undefined when calling listAvailableProviders().',
			);
		}

		const queryParameters: any = {};

		if (requestParameters.pageSize != null) {
			queryParameters.page_size = requestParameters.pageSize;
		}

		if (requestParameters.nextPageToken != null) {
			queryParameters.next_page_token = requestParameters.nextPageToken;
		}

		const headerParameters: runtime.HTTPHeaders = {};

		const urlPath = `/api/bridge/v1/available-providers`;

		const response = await this.request(
			{
				path: urlPath,
				method: "GET",
				headers: headerParameters,
				query: queryParameters,
			},
			initOverrides,
		);

		return new runtime.JSONApiResponse(response, (jsonValue) =>
			ProviderControllerSerializedPaginatedResponseFromJSON(jsonValue),
		);
	}

	/**
	 * List all available provider types that can be instantiated
	 * List providers
	 */
	async listAvailableProviders(
		requestParameters: BridgeApiListAvailableProvidersRequest,
		initOverrides?: RequestInit | runtime.InitOverrideFunction,
	): Promise<ProviderControllerSerializedPaginatedResponse> {
		const response = await this.listAvailableProvidersRaw(
			requestParameters,
			initOverrides,
		);
		return await response.value();
	}

	/**
	 * List all function instances with optional filtering by provider instance
	 * List function instances
	 */
	async listFunctionInstancesRaw(
		requestParameters: BridgeApiListFunctionInstancesRequest,
		initOverrides?: RequestInit | runtime.InitOverrideFunction,
	): Promise<runtime.ApiResponse<FunctionInstanceSerializedPaginatedResponse>> {
		if (requestParameters.pageSize == null) {
			throw new runtime.RequiredError(
				"pageSize",
				'Required parameter "pageSize" was null or undefined when calling listFunctionInstances().',
			);
		}

		const queryParameters: any = {};

		if (requestParameters.pageSize != null) {
			queryParameters.page_size = requestParameters.pageSize;
		}

		if (requestParameters.nextPageToken != null) {
			queryParameters.next_page_token = requestParameters.nextPageToken;
		}

		if (requestParameters.providerInstanceId != null) {
			queryParameters.provider_instance_id =
				requestParameters.providerInstanceId;
		}

		const headerParameters: runtime.HTTPHeaders = {};

		const urlPath = `/api/bridge/v1/function-instances`;

		const response = await this.request(
			{
				path: urlPath,
				method: "GET",
				headers: headerParameters,
				query: queryParameters,
			},
			initOverrides,
		);

		return new runtime.JSONApiResponse(response, (jsonValue) =>
			FunctionInstanceSerializedPaginatedResponseFromJSON(jsonValue),
		);
	}

	/**
	 * List all function instances with optional filtering by provider instance
	 * List function instances
	 */
	async listFunctionInstances(
		requestParameters: BridgeApiListFunctionInstancesRequest,
		initOverrides?: RequestInit | runtime.InitOverrideFunction,
	): Promise<FunctionInstanceSerializedPaginatedResponse> {
		const response = await this.listFunctionInstancesRaw(
			requestParameters,
			initOverrides,
		);
		return await response.value();
	}

	/**
	 * List all provider instances with optional filtering by status and provider type
	 * List provider instances
	 */
	async listProviderInstancesRaw(
		requestParameters: BridgeApiListProviderInstancesRequest,
		initOverrides?: RequestInit | runtime.InitOverrideFunction,
	): Promise<runtime.ApiResponse<ProviderInstanceListItemPaginatedResponse>> {
		if (requestParameters.pageSize == null) {
			throw new runtime.RequiredError(
				"pageSize",
				'Required parameter "pageSize" was null or undefined when calling listProviderInstances().',
			);
		}

		const queryParameters: any = {};

		if (requestParameters.pageSize != null) {
			queryParameters.page_size = requestParameters.pageSize;
		}

		if (requestParameters.nextPageToken != null) {
			queryParameters.next_page_token = requestParameters.nextPageToken;
		}

		if (requestParameters.status != null) {
			queryParameters.status = requestParameters.status;
		}

		if (requestParameters.providerControllerTypeId != null) {
			queryParameters.provider_controller_type_id =
				requestParameters.providerControllerTypeId;
		}

		const headerParameters: runtime.HTTPHeaders = {};

		const urlPath = `/api/bridge/v1/provider`;

		const response = await this.request(
			{
				path: urlPath,
				method: "GET",
				headers: headerParameters,
				query: queryParameters,
			},
			initOverrides,
		);

		return new runtime.JSONApiResponse(response, (jsonValue) =>
			ProviderInstanceListItemPaginatedResponseFromJSON(jsonValue),
		);
	}

	/**
	 * List all provider instances with optional filtering by status and provider type
	 * List provider instances
	 */
	async listProviderInstances(
		requestParameters: BridgeApiListProviderInstancesRequest,
		initOverrides?: RequestInit | runtime.InitOverrideFunction,
	): Promise<ProviderInstanceListItemPaginatedResponse> {
		const response = await this.listProviderInstancesRaw(
			requestParameters,
			initOverrides,
		);
		return await response.value();
	}

	/**
	 * List provider instances grouped by their associated functions
	 * List providers by function
	 */
	async listProviderInstancesGroupedByFunctionRaw(
		requestParameters: BridgeApiListProviderInstancesGroupedByFunctionRequest,
		initOverrides?: RequestInit | runtime.InitOverrideFunction,
	): Promise<runtime.ApiResponse<FunctionInstanceConfigPaginatedResponse>> {
		if (requestParameters.pageSize == null) {
			throw new runtime.RequiredError(
				"pageSize",
				'Required parameter "pageSize" was null or undefined when calling listProviderInstancesGroupedByFunction().',
			);
		}

		const queryParameters: any = {};

		if (requestParameters.nextPageToken != null) {
			queryParameters.next_page_token = requestParameters.nextPageToken;
		}

		if (requestParameters.pageSize != null) {
			queryParameters.page_size = requestParameters.pageSize;
		}

		if (requestParameters.providerControllerTypeId != null) {
			queryParameters.provider_controller_type_id =
				requestParameters.providerControllerTypeId;
		}

		if (requestParameters.functionCategory != null) {
			queryParameters.function_category = requestParameters.functionCategory;
		}

		const headerParameters: runtime.HTTPHeaders = {};

		const urlPath = `/api/bridge/v1/provider/grouped-by-function`;

		const response = await this.request(
			{
				path: urlPath,
				method: "GET",
				headers: headerParameters,
				query: queryParameters,
			},
			initOverrides,
		);

		return new runtime.JSONApiResponse(response, (jsonValue) =>
			FunctionInstanceConfigPaginatedResponseFromJSON(jsonValue),
		);
	}

	/**
	 * List provider instances grouped by their associated functions
	 * List providers by function
	 */
	async listProviderInstancesGroupedByFunction(
		requestParameters: BridgeApiListProviderInstancesGroupedByFunctionRequest,
		initOverrides?: RequestInit | runtime.InitOverrideFunction,
	): Promise<FunctionInstanceConfigPaginatedResponse> {
		const response = await this.listProviderInstancesGroupedByFunctionRaw(
			requestParameters,
			initOverrides,
		);
		return await response.value();
	}

	/**
	 * Establish Server-Sent Events (SSE) connection for MCP protocol communication
	 * MCP SSE connection
	 */
	async listenToMcpSseRaw(
		initOverrides?: RequestInit | runtime.InitOverrideFunction,
	): Promise<runtime.ApiResponse<void>> {
		const queryParameters: any = {};

		const headerParameters: runtime.HTTPHeaders = {};

		const urlPath = `/api/bridge/v1/mcp`;

		const response = await this.request(
			{
				path: urlPath,
				method: "GET",
				headers: headerParameters,
				query: queryParameters,
			},
			initOverrides,
		);

		return new runtime.VoidApiResponse(response);
	}

	/**
	 * Establish Server-Sent Events (SSE) connection for MCP protocol communication
	 * MCP SSE connection
	 */
	async listenToMcpSse(
		initOverrides?: RequestInit | runtime.InitOverrideFunction,
	): Promise<void> {
		await this.listenToMcpSseRaw(initOverrides);
	}

	/**
	 * Handle OAuth callback to complete user credential brokering flow
	 * OAuth callback
	 */
	async resumeUserCredentialBrokeringRaw(
		requestParameters: BridgeApiResumeUserCredentialBrokeringRequest,
		initOverrides?: RequestInit | runtime.InitOverrideFunction,
	): Promise<runtime.ApiResponse<UserCredentialBrokeringResponse>> {
		const queryParameters: any = {};

		if (requestParameters.state != null) {
			queryParameters.state = requestParameters.state;
		}

		if (requestParameters.code != null) {
			queryParameters.code = requestParameters.code;
		}

		if (requestParameters.error != null) {
			queryParameters.error = requestParameters.error;
		}

		if (requestParameters.errorDescription != null) {
			queryParameters.error_description = requestParameters.errorDescription;
		}

		const headerParameters: runtime.HTTPHeaders = {};

		const urlPath = `/api/bridge/v1/generic-oauth-callback`;

		const response = await this.request(
			{
				path: urlPath,
				method: "GET",
				headers: headerParameters,
				query: queryParameters,
			},
			initOverrides,
		);

		return new runtime.JSONApiResponse(response, (jsonValue) =>
			UserCredentialBrokeringResponseFromJSON(jsonValue),
		);
	}

	/**
	 * Handle OAuth callback to complete user credential brokering flow
	 * OAuth callback
	 */
	async resumeUserCredentialBrokering(
		requestParameters: BridgeApiResumeUserCredentialBrokeringRequest = {},
		initOverrides?: RequestInit | runtime.InitOverrideFunction,
	): Promise<UserCredentialBrokeringResponse> {
		const response = await this.resumeUserCredentialBrokeringRaw(
			requestParameters,
			initOverrides,
		);
		return await response.value();
	}

	/**
	 * Start the OAuth flow for user credential brokering
	 * Start credential brokering
	 */
	async startUserCredentialBrokeringRaw(
		requestParameters: BridgeApiStartUserCredentialBrokeringRequest,
		initOverrides?: RequestInit | runtime.InitOverrideFunction,
	): Promise<runtime.ApiResponse<UserCredentialBrokeringResponse>> {
		if (requestParameters.providerControllerTypeId == null) {
			throw new runtime.RequiredError(
				"providerControllerTypeId",
				'Required parameter "providerControllerTypeId" was null or undefined when calling startUserCredentialBrokering().',
			);
		}

		if (requestParameters.credentialControllerTypeId == null) {
			throw new runtime.RequiredError(
				"credentialControllerTypeId",
				'Required parameter "credentialControllerTypeId" was null or undefined when calling startUserCredentialBrokering().',
			);
		}

		if (requestParameters.startUserCredentialBrokeringParamsInner == null) {
			throw new runtime.RequiredError(
				"startUserCredentialBrokeringParamsInner",
				'Required parameter "startUserCredentialBrokeringParamsInner" was null or undefined when calling startUserCredentialBrokering().',
			);
		}

		const queryParameters: any = {};

		const headerParameters: runtime.HTTPHeaders = {};

		headerParameters["Content-Type"] = "application/json";

		let urlPath = `/api/bridge/v1/available-providers/{provider_controller_type_id}/available-credentials/{credential_controller_type_id}/credential/user-credential/broker`;
		urlPath = urlPath.replace(
			`{${"provider_controller_type_id"}}`,
			encodeURIComponent(String(requestParameters.providerControllerTypeId)),
		);
		urlPath = urlPath.replace(
			`{${"credential_controller_type_id"}}`,
			encodeURIComponent(String(requestParameters.credentialControllerTypeId)),
		);

		const response = await this.request(
			{
				path: urlPath,
				method: "POST",
				headers: headerParameters,
				query: queryParameters,
				body: StartUserCredentialBrokeringParamsInnerToJSON(
					requestParameters.startUserCredentialBrokeringParamsInner,
				),
			},
			initOverrides,
		);

		return new runtime.JSONApiResponse(response, (jsonValue) =>
			UserCredentialBrokeringResponseFromJSON(jsonValue),
		);
	}

	/**
	 * Start the OAuth flow for user credential brokering
	 * Start credential brokering
	 */
	async startUserCredentialBrokering(
		requestParameters: BridgeApiStartUserCredentialBrokeringRequest,
		initOverrides?: RequestInit | runtime.InitOverrideFunction,
	): Promise<UserCredentialBrokeringResponse> {
		const response = await this.startUserCredentialBrokeringRaw(
			requestParameters,
			initOverrides,
		);
		return await response.value();
	}

	/**
	 * Send a JSON-RPC message to the MCP server
	 * Send MCP message
	 */
	async triggerMcpMessageRaw(
		requestParameters: BridgeApiTriggerMcpMessageRequest,
		initOverrides?: RequestInit | runtime.InitOverrideFunction,
	): Promise<runtime.ApiResponse<void>> {
		if (requestParameters.body == null) {
			throw new runtime.RequiredError(
				"body",
				'Required parameter "body" was null or undefined when calling triggerMcpMessage().',
			);
		}

		const queryParameters: any = {};

		const headerParameters: runtime.HTTPHeaders = {};

		headerParameters["Content-Type"] = "application/json";

		const urlPath = `/api/bridge/v1/mcp`;

		const response = await this.request(
			{
				path: urlPath,
				method: "POST",
				headers: headerParameters,
				query: queryParameters,
				body: requestParameters.body as any,
			},
			initOverrides,
		);

		return new runtime.VoidApiResponse(response);
	}

	/**
	 * Send a JSON-RPC message to the MCP server
	 * Send MCP message
	 */
	async triggerMcpMessage(
		requestParameters: BridgeApiTriggerMcpMessageRequest,
		initOverrides?: RequestInit | runtime.InitOverrideFunction,
	): Promise<void> {
		await this.triggerMcpMessageRaw(requestParameters, initOverrides);
	}

	/**
	 * Update an existing provider instance configuration
	 * Update provider
	 */
	async updateProviderInstanceRaw(
		requestParameters: BridgeApiUpdateProviderInstanceRequest,
		initOverrides?: RequestInit | runtime.InitOverrideFunction,
	): Promise<runtime.ApiResponse<any>> {
		if (requestParameters.providerInstanceId == null) {
			throw new runtime.RequiredError(
				"providerInstanceId",
				'Required parameter "providerInstanceId" was null or undefined when calling updateProviderInstance().',
			);
		}

		if (requestParameters.updateProviderInstanceParamsInner == null) {
			throw new runtime.RequiredError(
				"updateProviderInstanceParamsInner",
				'Required parameter "updateProviderInstanceParamsInner" was null or undefined when calling updateProviderInstance().',
			);
		}

		const queryParameters: any = {};

		const headerParameters: runtime.HTTPHeaders = {};

		headerParameters["Content-Type"] = "application/json";

		let urlPath = `/api/bridge/v1/provider/{provider_instance_id}`;
		urlPath = urlPath.replace(
			`{${"provider_instance_id"}}`,
			encodeURIComponent(String(requestParameters.providerInstanceId)),
		);

		const response = await this.request(
			{
				path: urlPath,
				method: "PATCH",
				headers: headerParameters,
				query: queryParameters,
				body: UpdateProviderInstanceParamsInnerToJSON(
					requestParameters.updateProviderInstanceParamsInner,
				),
			},
			initOverrides,
		);

		if (this.isJsonMime(response.headers.get("content-type"))) {
			return new runtime.JSONApiResponse<any>(response);
		} else {
			return new runtime.TextApiResponse(response) as any;
		}
	}

	/**
	 * Update an existing provider instance configuration
	 * Update provider
	 */
	async updateProviderInstance(
		requestParameters: BridgeApiUpdateProviderInstanceRequest,
		initOverrides?: RequestInit | runtime.InitOverrideFunction,
	): Promise<any> {
		const response = await this.updateProviderInstanceRaw(
			requestParameters,
			initOverrides,
		);
		return await response.value();
	}
}
