/* tslint:disable */
/* eslint-disable */
/**
 * utoipa-axum
 * Utoipa\'s axum bindings for seamless integration for the two
 *
 * The version of the OpenAPI document: 0.2.0
 * Contact: juha7kukkonen@gmail.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

import type {
	ContextInfoPaginatedResponse,
	CreateDataEncryptionKeyParams,
	CreateMessageRequest,
	CreateMessageResponse,
	CreateProviderInstanceParamsInner,
	CreateResourceServerCredentialParamsInner,
	CreateUserCredentialParamsInner,
	DataEncryptionKey,
	DataEncryptionKeyListItemPaginatedResponse,
	EnableFunctionParamsInner,
	EncryptCredentialConfigurationParamsInner,
	FunctionInstanceSerialized,
	InvokeFunctionParamsInner,
	ProviderControllerSerializedPaginatedResponse,
	ProviderInstanceSerialized,
	ResourceServerCredentialSerialized,
	SomaAgentDefinition,
	StartUserCredentialBrokeringParamsInner,
	TaskPaginatedResponse,
	TaskTimelineItemPaginatedResponse,
	TaskWithDetails,
	UpdateTaskStatusRequest,
	UserCredentialBrokeringResponse,
	UserCredentialSerialized,
} from "../models/index";
import {
	ContextInfoPaginatedResponseFromJSON,
	CreateDataEncryptionKeyParamsToJSON,
	CreateMessageRequestToJSON,
	CreateMessageResponseFromJSON,
	CreateProviderInstanceParamsInnerToJSON,
	CreateResourceServerCredentialParamsInnerToJSON,
	CreateUserCredentialParamsInnerToJSON,
	DataEncryptionKeyFromJSON,
	DataEncryptionKeyListItemPaginatedResponseFromJSON,
	EnableFunctionParamsInnerToJSON,
	EncryptCredentialConfigurationParamsInnerToJSON,
	FunctionInstanceSerializedFromJSON,
	InvokeFunctionParamsInnerToJSON,
	ProviderControllerSerializedPaginatedResponseFromJSON,
	ProviderInstanceSerializedFromJSON,
	ResourceServerCredentialSerializedFromJSON,
	SomaAgentDefinitionFromJSON,
	StartUserCredentialBrokeringParamsInnerToJSON,
	TaskPaginatedResponseFromJSON,
	TaskTimelineItemPaginatedResponseFromJSON,
	TaskWithDetailsFromJSON,
	UpdateTaskStatusRequestToJSON,
	UserCredentialBrokeringResponseFromJSON,
	UserCredentialSerializedFromJSON,
} from "../models/index";
import * as runtime from "../runtime";

export interface CreateDataEncryptionKeyRequest {
	createDataEncryptionKeyParams: CreateDataEncryptionKeyParams;
}

export interface CreateProviderInstanceRequest {
	providerControllerTypeId: string;
	credentialControllerTypeId: string;
	createProviderInstanceParamsInner: CreateProviderInstanceParamsInner;
}

export interface CreateResourceServerCredentialRequest {
	providerControllerTypeId: string;
	credentialControllerTypeId: string;
	createResourceServerCredentialParamsInner: CreateResourceServerCredentialParamsInner;
}

export interface CreateUserCredentialRequest {
	providerControllerTypeId: string;
	credentialControllerTypeId: string;
	createUserCredentialParamsInner: CreateUserCredentialParamsInner;
}

export interface DeleteProviderInstanceRequest {
	providerInstanceId: string;
}

export interface DisableFunctionRequest {
	providerInstanceId: string;
	functionInstanceId: string;
}

export interface EnableFunctionRequest {
	providerInstanceId: string;
	functionControllerTypeId: string;
	enableFunctionParamsInner: EnableFunctionParamsInner;
}

export interface EncryptResourceServerConfigurationRequest {
	providerControllerTypeId: string;
	credentialControllerTypeId: string;
	encryptCredentialConfigurationParamsInner: EncryptCredentialConfigurationParamsInner;
}

export interface EncryptUserCredentialConfigurationRequest {
	providerControllerTypeId: string;
	credentialControllerTypeId: string;
	encryptCredentialConfigurationParamsInner: EncryptCredentialConfigurationParamsInner;
}

export interface GetTaskByIdRequest {
	taskId: string;
}

export interface InvokeFunctionRequest {
	providerInstanceId: string;
	functionInstanceId: string;
	invokeFunctionParamsInner: InvokeFunctionParamsInner;
}

export interface JsonRpcRequest {
	body: object;
}

export interface ListAvailableProvidersRequest {
	pageSize: number;
	nextPageToken?: string;
}

export interface ListContextsRequest {
	pageSize: number;
	nextPageToken?: string;
}

export interface ListDataEncryptionKeysRequest {
	pageSize: number;
	nextPageToken?: string;
}

export interface ListTasksRequest {
	pageSize: number;
	nextPageToken?: string;
}

export interface ListTasksByContextIdRequest {
	pageSize: number;
	contextId: string;
	nextPageToken?: string;
}

export interface ResumeUserCredentialBrokeringRequest {
	state?: string;
	code?: string;
	error?: string;
	errorDescription?: string;
}

export interface SendMessageRequest {
	taskId: string;
	createMessageRequest: CreateMessageRequest;
}

export interface StartUserCredentialBrokeringRequest {
	providerControllerTypeId: string;
	credentialControllerTypeId: string;
	startUserCredentialBrokeringParamsInner: StartUserCredentialBrokeringParamsInner;
}

export interface TaskHistoryRequest {
	pageSize: number;
	taskId: string;
	nextPageToken?: string;
}

export interface UpdateTaskStatusOperationRequest {
	taskId: string;
	updateTaskStatusRequest: UpdateTaskStatusRequest;
}

/**
 *
 */
export class DefaultApi extends runtime.BaseAPI {
	/**
	 */
	async agentCardRaw(
		initOverrides?: RequestInit | runtime.InitOverrideFunction,
	): Promise<runtime.ApiResponse<object>> {
		const queryParameters: any = {};

		const headerParameters: runtime.HTTPHeaders = {};

		const urlPath = `/api/a2a/v1/.well-known/agent.json`;

		const response = await this.request(
			{
				path: urlPath,
				method: "GET",
				headers: headerParameters,
				query: queryParameters,
			},
			initOverrides,
		);

		return new runtime.JSONApiResponse<any>(response);
	}

	/**
	 */
	async agentCard(
		initOverrides?: RequestInit | runtime.InitOverrideFunction,
	): Promise<object> {
		const response = await this.agentCardRaw(initOverrides);
		return await response.value();
	}

	/**
	 */
	async createDataEncryptionKeyRaw(
		requestParameters: CreateDataEncryptionKeyRequest,
		initOverrides?: RequestInit | runtime.InitOverrideFunction,
	): Promise<runtime.ApiResponse<DataEncryptionKey>> {
		if (requestParameters.createDataEncryptionKeyParams == null) {
			throw new runtime.RequiredError(
				"createDataEncryptionKeyParams",
				'Required parameter "createDataEncryptionKeyParams" was null or undefined when calling createDataEncryptionKey().',
			);
		}

		const queryParameters: any = {};

		const headerParameters: runtime.HTTPHeaders = {};

		headerParameters["Content-Type"] = "application/json";

		const urlPath = `/api/bridge/v1/encryption/data-encryption-key`;

		const response = await this.request(
			{
				path: urlPath,
				method: "POST",
				headers: headerParameters,
				query: queryParameters,
				body: CreateDataEncryptionKeyParamsToJSON(
					requestParameters.createDataEncryptionKeyParams,
				),
			},
			initOverrides,
		);

		return new runtime.JSONApiResponse(response, (jsonValue) =>
			DataEncryptionKeyFromJSON(jsonValue),
		);
	}

	/**
	 */
	async createDataEncryptionKey(
		requestParameters: CreateDataEncryptionKeyRequest,
		initOverrides?: RequestInit | runtime.InitOverrideFunction,
	): Promise<DataEncryptionKey> {
		const response = await this.createDataEncryptionKeyRaw(
			requestParameters,
			initOverrides,
		);
		return await response.value();
	}

	/**
	 */
	async createProviderInstanceRaw(
		requestParameters: CreateProviderInstanceRequest,
		initOverrides?: RequestInit | runtime.InitOverrideFunction,
	): Promise<runtime.ApiResponse<ProviderInstanceSerialized>> {
		if (requestParameters.providerControllerTypeId == null) {
			throw new runtime.RequiredError(
				"providerControllerTypeId",
				'Required parameter "providerControllerTypeId" was null or undefined when calling createProviderInstance().',
			);
		}

		if (requestParameters.credentialControllerTypeId == null) {
			throw new runtime.RequiredError(
				"credentialControllerTypeId",
				'Required parameter "credentialControllerTypeId" was null or undefined when calling createProviderInstance().',
			);
		}

		if (requestParameters.createProviderInstanceParamsInner == null) {
			throw new runtime.RequiredError(
				"createProviderInstanceParamsInner",
				'Required parameter "createProviderInstanceParamsInner" was null or undefined when calling createProviderInstance().',
			);
		}

		const queryParameters: any = {};

		const headerParameters: runtime.HTTPHeaders = {};

		headerParameters["Content-Type"] = "application/json";

		let urlPath = `/api/bridge/v1/available-providers/{provider_controller_type_id}/available-credentials/{credential_controller_type_id}`;
		urlPath = urlPath.replace(
			`{${"provider_controller_type_id"}}`,
			encodeURIComponent(String(requestParameters.providerControllerTypeId)),
		);
		urlPath = urlPath.replace(
			`{${"credential_controller_type_id"}}`,
			encodeURIComponent(String(requestParameters.credentialControllerTypeId)),
		);

		const response = await this.request(
			{
				path: urlPath,
				method: "POST",
				headers: headerParameters,
				query: queryParameters,
				body: CreateProviderInstanceParamsInnerToJSON(
					requestParameters.createProviderInstanceParamsInner,
				),
			},
			initOverrides,
		);

		return new runtime.JSONApiResponse(response, (jsonValue) =>
			ProviderInstanceSerializedFromJSON(jsonValue),
		);
	}

	/**
	 */
	async createProviderInstance(
		requestParameters: CreateProviderInstanceRequest,
		initOverrides?: RequestInit | runtime.InitOverrideFunction,
	): Promise<ProviderInstanceSerialized> {
		const response = await this.createProviderInstanceRaw(
			requestParameters,
			initOverrides,
		);
		return await response.value();
	}

	/**
	 */
	async createResourceServerCredentialRaw(
		requestParameters: CreateResourceServerCredentialRequest,
		initOverrides?: RequestInit | runtime.InitOverrideFunction,
	): Promise<runtime.ApiResponse<ResourceServerCredentialSerialized>> {
		if (requestParameters.providerControllerTypeId == null) {
			throw new runtime.RequiredError(
				"providerControllerTypeId",
				'Required parameter "providerControllerTypeId" was null or undefined when calling createResourceServerCredential().',
			);
		}

		if (requestParameters.credentialControllerTypeId == null) {
			throw new runtime.RequiredError(
				"credentialControllerTypeId",
				'Required parameter "credentialControllerTypeId" was null or undefined when calling createResourceServerCredential().',
			);
		}

		if (requestParameters.createResourceServerCredentialParamsInner == null) {
			throw new runtime.RequiredError(
				"createResourceServerCredentialParamsInner",
				'Required parameter "createResourceServerCredentialParamsInner" was null or undefined when calling createResourceServerCredential().',
			);
		}

		const queryParameters: any = {};

		const headerParameters: runtime.HTTPHeaders = {};

		headerParameters["Content-Type"] = "application/json";

		let urlPath = `/api/bridge/v1/available-providers/{provider_controller_type_id}/available-credentials/{credential_controller_type_id}/credential/resource-server`;
		urlPath = urlPath.replace(
			`{${"provider_controller_type_id"}}`,
			encodeURIComponent(String(requestParameters.providerControllerTypeId)),
		);
		urlPath = urlPath.replace(
			`{${"credential_controller_type_id"}}`,
			encodeURIComponent(String(requestParameters.credentialControllerTypeId)),
		);

		const response = await this.request(
			{
				path: urlPath,
				method: "POST",
				headers: headerParameters,
				query: queryParameters,
				body: CreateResourceServerCredentialParamsInnerToJSON(
					requestParameters.createResourceServerCredentialParamsInner,
				),
			},
			initOverrides,
		);

		return new runtime.JSONApiResponse(response, (jsonValue) =>
			ResourceServerCredentialSerializedFromJSON(jsonValue),
		);
	}

	/**
	 */
	async createResourceServerCredential(
		requestParameters: CreateResourceServerCredentialRequest,
		initOverrides?: RequestInit | runtime.InitOverrideFunction,
	): Promise<ResourceServerCredentialSerialized> {
		const response = await this.createResourceServerCredentialRaw(
			requestParameters,
			initOverrides,
		);
		return await response.value();
	}

	/**
	 */
	async createUserCredentialRaw(
		requestParameters: CreateUserCredentialRequest,
		initOverrides?: RequestInit | runtime.InitOverrideFunction,
	): Promise<runtime.ApiResponse<UserCredentialSerialized>> {
		if (requestParameters.providerControllerTypeId == null) {
			throw new runtime.RequiredError(
				"providerControllerTypeId",
				'Required parameter "providerControllerTypeId" was null or undefined when calling createUserCredential().',
			);
		}

		if (requestParameters.credentialControllerTypeId == null) {
			throw new runtime.RequiredError(
				"credentialControllerTypeId",
				'Required parameter "credentialControllerTypeId" was null or undefined when calling createUserCredential().',
			);
		}

		if (requestParameters.createUserCredentialParamsInner == null) {
			throw new runtime.RequiredError(
				"createUserCredentialParamsInner",
				'Required parameter "createUserCredentialParamsInner" was null or undefined when calling createUserCredential().',
			);
		}

		const queryParameters: any = {};

		const headerParameters: runtime.HTTPHeaders = {};

		headerParameters["Content-Type"] = "application/json";

		let urlPath = `/api/bridge/v1/available-providers/{provider_controller_type_id}/available-credentials/{credential_controller_type_id}/credential/user-credential`;
		urlPath = urlPath.replace(
			`{${"provider_controller_type_id"}}`,
			encodeURIComponent(String(requestParameters.providerControllerTypeId)),
		);
		urlPath = urlPath.replace(
			`{${"credential_controller_type_id"}}`,
			encodeURIComponent(String(requestParameters.credentialControllerTypeId)),
		);

		const response = await this.request(
			{
				path: urlPath,
				method: "POST",
				headers: headerParameters,
				query: queryParameters,
				body: CreateUserCredentialParamsInnerToJSON(
					requestParameters.createUserCredentialParamsInner,
				),
			},
			initOverrides,
		);

		return new runtime.JSONApiResponse(response, (jsonValue) =>
			UserCredentialSerializedFromJSON(jsonValue),
		);
	}

	/**
	 */
	async createUserCredential(
		requestParameters: CreateUserCredentialRequest,
		initOverrides?: RequestInit | runtime.InitOverrideFunction,
	): Promise<UserCredentialSerialized> {
		const response = await this.createUserCredentialRaw(
			requestParameters,
			initOverrides,
		);
		return await response.value();
	}

	/**
	 */
	async deleteProviderInstanceRaw(
		requestParameters: DeleteProviderInstanceRequest,
		initOverrides?: RequestInit | runtime.InitOverrideFunction,
	): Promise<runtime.ApiResponse<any>> {
		if (requestParameters.providerInstanceId == null) {
			throw new runtime.RequiredError(
				"providerInstanceId",
				'Required parameter "providerInstanceId" was null or undefined when calling deleteProviderInstance().',
			);
		}

		const queryParameters: any = {};

		const headerParameters: runtime.HTTPHeaders = {};

		let urlPath = `/api/bridge/v1/provider/{provider_instance_id}`;
		urlPath = urlPath.replace(
			`{${"provider_instance_id"}}`,
			encodeURIComponent(String(requestParameters.providerInstanceId)),
		);

		const response = await this.request(
			{
				path: urlPath,
				method: "DELETE",
				headers: headerParameters,
				query: queryParameters,
			},
			initOverrides,
		);

		if (this.isJsonMime(response.headers.get("content-type"))) {
			return new runtime.JSONApiResponse<any>(response);
		} else {
			return new runtime.TextApiResponse(response) as any;
		}
	}

	/**
	 */
	async deleteProviderInstance(
		requestParameters: DeleteProviderInstanceRequest,
		initOverrides?: RequestInit | runtime.InitOverrideFunction,
	): Promise<any> {
		const response = await this.deleteProviderInstanceRaw(
			requestParameters,
			initOverrides,
		);
		return await response.value();
	}

	/**
	 */
	async disableFunctionRaw(
		requestParameters: DisableFunctionRequest,
		initOverrides?: RequestInit | runtime.InitOverrideFunction,
	): Promise<runtime.ApiResponse<any>> {
		if (requestParameters.providerInstanceId == null) {
			throw new runtime.RequiredError(
				"providerInstanceId",
				'Required parameter "providerInstanceId" was null or undefined when calling disableFunction().',
			);
		}

		if (requestParameters.functionInstanceId == null) {
			throw new runtime.RequiredError(
				"functionInstanceId",
				'Required parameter "functionInstanceId" was null or undefined when calling disableFunction().',
			);
		}

		const queryParameters: any = {};

		const headerParameters: runtime.HTTPHeaders = {};

		let urlPath = `/api/bridge/v1/provider/{provider_instance_id}/function/{function_instance_id}/disable`;
		urlPath = urlPath.replace(
			`{${"provider_instance_id"}}`,
			encodeURIComponent(String(requestParameters.providerInstanceId)),
		);
		urlPath = urlPath.replace(
			`{${"function_instance_id"}}`,
			encodeURIComponent(String(requestParameters.functionInstanceId)),
		);

		const response = await this.request(
			{
				path: urlPath,
				method: "POST",
				headers: headerParameters,
				query: queryParameters,
			},
			initOverrides,
		);

		if (this.isJsonMime(response.headers.get("content-type"))) {
			return new runtime.JSONApiResponse<any>(response);
		} else {
			return new runtime.TextApiResponse(response) as any;
		}
	}

	/**
	 */
	async disableFunction(
		requestParameters: DisableFunctionRequest,
		initOverrides?: RequestInit | runtime.InitOverrideFunction,
	): Promise<any> {
		const response = await this.disableFunctionRaw(
			requestParameters,
			initOverrides,
		);
		return await response.value();
	}

	/**
	 */
	async enableFunctionRaw(
		requestParameters: EnableFunctionRequest,
		initOverrides?: RequestInit | runtime.InitOverrideFunction,
	): Promise<runtime.ApiResponse<FunctionInstanceSerialized>> {
		if (requestParameters.providerInstanceId == null) {
			throw new runtime.RequiredError(
				"providerInstanceId",
				'Required parameter "providerInstanceId" was null or undefined when calling enableFunction().',
			);
		}

		if (requestParameters.functionControllerTypeId == null) {
			throw new runtime.RequiredError(
				"functionControllerTypeId",
				'Required parameter "functionControllerTypeId" was null or undefined when calling enableFunction().',
			);
		}

		if (requestParameters.enableFunctionParamsInner == null) {
			throw new runtime.RequiredError(
				"enableFunctionParamsInner",
				'Required parameter "enableFunctionParamsInner" was null or undefined when calling enableFunction().',
			);
		}

		const queryParameters: any = {};

		const headerParameters: runtime.HTTPHeaders = {};

		headerParameters["Content-Type"] = "application/json";

		let urlPath = `/api/bridge/v1/provider/{provider_instance_id}/available-functions/{function_controller_type_id}/enable`;
		urlPath = urlPath.replace(
			`{${"provider_instance_id"}}`,
			encodeURIComponent(String(requestParameters.providerInstanceId)),
		);
		urlPath = urlPath.replace(
			`{${"function_controller_type_id"}}`,
			encodeURIComponent(String(requestParameters.functionControllerTypeId)),
		);

		const response = await this.request(
			{
				path: urlPath,
				method: "POST",
				headers: headerParameters,
				query: queryParameters,
				body: EnableFunctionParamsInnerToJSON(
					requestParameters.enableFunctionParamsInner,
				),
			},
			initOverrides,
		);

		return new runtime.JSONApiResponse(response, (jsonValue) =>
			FunctionInstanceSerializedFromJSON(jsonValue),
		);
	}

	/**
	 */
	async enableFunction(
		requestParameters: EnableFunctionRequest,
		initOverrides?: RequestInit | runtime.InitOverrideFunction,
	): Promise<FunctionInstanceSerialized> {
		const response = await this.enableFunctionRaw(
			requestParameters,
			initOverrides,
		);
		return await response.value();
	}

	/**
	 */
	async encryptResourceServerConfigurationRaw(
		requestParameters: EncryptResourceServerConfigurationRequest,
		initOverrides?: RequestInit | runtime.InitOverrideFunction,
	): Promise<runtime.ApiResponse<any>> {
		if (requestParameters.providerControllerTypeId == null) {
			throw new runtime.RequiredError(
				"providerControllerTypeId",
				'Required parameter "providerControllerTypeId" was null or undefined when calling encryptResourceServerConfiguration().',
			);
		}

		if (requestParameters.credentialControllerTypeId == null) {
			throw new runtime.RequiredError(
				"credentialControllerTypeId",
				'Required parameter "credentialControllerTypeId" was null or undefined when calling encryptResourceServerConfiguration().',
			);
		}

		if (requestParameters.encryptCredentialConfigurationParamsInner == null) {
			throw new runtime.RequiredError(
				"encryptCredentialConfigurationParamsInner",
				'Required parameter "encryptCredentialConfigurationParamsInner" was null or undefined when calling encryptResourceServerConfiguration().',
			);
		}

		const queryParameters: any = {};

		const headerParameters: runtime.HTTPHeaders = {};

		headerParameters["Content-Type"] = "application/json";

		let urlPath = `/api/bridge/v1/available-providers/{provider_controller_type_id}/available-credentials/{credential_controller_type_id}/credential/resource-server/encrypt`;
		urlPath = urlPath.replace(
			`{${"provider_controller_type_id"}}`,
			encodeURIComponent(String(requestParameters.providerControllerTypeId)),
		);
		urlPath = urlPath.replace(
			`{${"credential_controller_type_id"}}`,
			encodeURIComponent(String(requestParameters.credentialControllerTypeId)),
		);

		const response = await this.request(
			{
				path: urlPath,
				method: "POST",
				headers: headerParameters,
				query: queryParameters,
				body: EncryptCredentialConfigurationParamsInnerToJSON(
					requestParameters.encryptCredentialConfigurationParamsInner,
				),
			},
			initOverrides,
		);

		if (this.isJsonMime(response.headers.get("content-type"))) {
			return new runtime.JSONApiResponse<any>(response);
		} else {
			return new runtime.TextApiResponse(response) as any;
		}
	}

	/**
	 */
	async encryptResourceServerConfiguration(
		requestParameters: EncryptResourceServerConfigurationRequest,
		initOverrides?: RequestInit | runtime.InitOverrideFunction,
	): Promise<any> {
		const response = await this.encryptResourceServerConfigurationRaw(
			requestParameters,
			initOverrides,
		);
		return await response.value();
	}

	/**
	 */
	async encryptUserCredentialConfigurationRaw(
		requestParameters: EncryptUserCredentialConfigurationRequest,
		initOverrides?: RequestInit | runtime.InitOverrideFunction,
	): Promise<runtime.ApiResponse<any>> {
		if (requestParameters.providerControllerTypeId == null) {
			throw new runtime.RequiredError(
				"providerControllerTypeId",
				'Required parameter "providerControllerTypeId" was null or undefined when calling encryptUserCredentialConfiguration().',
			);
		}

		if (requestParameters.credentialControllerTypeId == null) {
			throw new runtime.RequiredError(
				"credentialControllerTypeId",
				'Required parameter "credentialControllerTypeId" was null or undefined when calling encryptUserCredentialConfiguration().',
			);
		}

		if (requestParameters.encryptCredentialConfigurationParamsInner == null) {
			throw new runtime.RequiredError(
				"encryptCredentialConfigurationParamsInner",
				'Required parameter "encryptCredentialConfigurationParamsInner" was null or undefined when calling encryptUserCredentialConfiguration().',
			);
		}

		const queryParameters: any = {};

		const headerParameters: runtime.HTTPHeaders = {};

		headerParameters["Content-Type"] = "application/json";

		let urlPath = `/api/bridge/v1/available-providers/{provider_controller_type_id}/available-credentials/{credential_controller_type_id}/credential/user-credential/encrypt`;
		urlPath = urlPath.replace(
			`{${"provider_controller_type_id"}}`,
			encodeURIComponent(String(requestParameters.providerControllerTypeId)),
		);
		urlPath = urlPath.replace(
			`{${"credential_controller_type_id"}}`,
			encodeURIComponent(String(requestParameters.credentialControllerTypeId)),
		);

		const response = await this.request(
			{
				path: urlPath,
				method: "POST",
				headers: headerParameters,
				query: queryParameters,
				body: EncryptCredentialConfigurationParamsInnerToJSON(
					requestParameters.encryptCredentialConfigurationParamsInner,
				),
			},
			initOverrides,
		);

		if (this.isJsonMime(response.headers.get("content-type"))) {
			return new runtime.JSONApiResponse<any>(response);
		} else {
			return new runtime.TextApiResponse(response) as any;
		}
	}

	/**
	 */
	async encryptUserCredentialConfiguration(
		requestParameters: EncryptUserCredentialConfigurationRequest,
		initOverrides?: RequestInit | runtime.InitOverrideFunction,
	): Promise<any> {
		const response = await this.encryptUserCredentialConfigurationRaw(
			requestParameters,
			initOverrides,
		);
		return await response.value();
	}

	/**
	 */
	async extendedAgentCardRaw(
		initOverrides?: RequestInit | runtime.InitOverrideFunction,
	): Promise<runtime.ApiResponse<object>> {
		const queryParameters: any = {};

		const headerParameters: runtime.HTTPHeaders = {};

		const urlPath = `/api/a2a/v1/agent/authenticatedExtendedCard`;

		const response = await this.request(
			{
				path: urlPath,
				method: "GET",
				headers: headerParameters,
				query: queryParameters,
			},
			initOverrides,
		);

		return new runtime.JSONApiResponse<any>(response);
	}

	/**
	 */
	async extendedAgentCard(
		initOverrides?: RequestInit | runtime.InitOverrideFunction,
	): Promise<object> {
		const response = await this.extendedAgentCardRaw(initOverrides);
		return await response.value();
	}

	/**
	 */
	async getAgentDefinitionRaw(
		initOverrides?: RequestInit | runtime.InitOverrideFunction,
	): Promise<runtime.ApiResponse<SomaAgentDefinition>> {
		const queryParameters: any = {};

		const headerParameters: runtime.HTTPHeaders = {};

		const urlPath = `/api/a2a/v1/definition`;

		const response = await this.request(
			{
				path: urlPath,
				method: "GET",
				headers: headerParameters,
				query: queryParameters,
			},
			initOverrides,
		);

		return new runtime.JSONApiResponse(response, (jsonValue) =>
			SomaAgentDefinitionFromJSON(jsonValue),
		);
	}

	/**
	 */
	async getAgentDefinition(
		initOverrides?: RequestInit | runtime.InitOverrideFunction,
	): Promise<SomaAgentDefinition> {
		const response = await this.getAgentDefinitionRaw(initOverrides);
		return await response.value();
	}

	/**
	 */
	async getFrontendEnvRaw(
		initOverrides?: RequestInit | runtime.InitOverrideFunction,
	): Promise<runtime.ApiResponse<object>> {
		const queryParameters: any = {};

		const headerParameters: runtime.HTTPHeaders = {};

		const urlPath = `/_internal/v1/runtime_config`;

		const response = await this.request(
			{
				path: urlPath,
				method: "GET",
				headers: headerParameters,
				query: queryParameters,
			},
			initOverrides,
		);

		return new runtime.JSONApiResponse<any>(response);
	}

	/**
	 */
	async getFrontendEnv(
		initOverrides?: RequestInit | runtime.InitOverrideFunction,
	): Promise<object> {
		const response = await this.getFrontendEnvRaw(initOverrides);
		return await response.value();
	}

	/**
	 */
	async getTaskByIdRaw(
		requestParameters: GetTaskByIdRequest,
		initOverrides?: RequestInit | runtime.InitOverrideFunction,
	): Promise<runtime.ApiResponse<TaskWithDetails>> {
		if (requestParameters.taskId == null) {
			throw new runtime.RequiredError(
				"taskId",
				'Required parameter "taskId" was null or undefined when calling getTaskById().',
			);
		}

		const queryParameters: any = {};

		const headerParameters: runtime.HTTPHeaders = {};

		let urlPath = `/api/task/v1/{task_id}`;
		urlPath = urlPath.replace(
			`{${"task_id"}}`,
			encodeURIComponent(String(requestParameters.taskId)),
		);

		const response = await this.request(
			{
				path: urlPath,
				method: "GET",
				headers: headerParameters,
				query: queryParameters,
			},
			initOverrides,
		);

		return new runtime.JSONApiResponse(response, (jsonValue) =>
			TaskWithDetailsFromJSON(jsonValue),
		);
	}

	/**
	 */
	async getTaskById(
		requestParameters: GetTaskByIdRequest,
		initOverrides?: RequestInit | runtime.InitOverrideFunction,
	): Promise<TaskWithDetails> {
		const response = await this.getTaskByIdRaw(
			requestParameters,
			initOverrides,
		);
		return await response.value();
	}

	/**
	 */
	async invokeFunctionRaw(
		requestParameters: InvokeFunctionRequest,
		initOverrides?: RequestInit | runtime.InitOverrideFunction,
	): Promise<runtime.ApiResponse<any>> {
		if (requestParameters.providerInstanceId == null) {
			throw new runtime.RequiredError(
				"providerInstanceId",
				'Required parameter "providerInstanceId" was null or undefined when calling invokeFunction().',
			);
		}

		if (requestParameters.functionInstanceId == null) {
			throw new runtime.RequiredError(
				"functionInstanceId",
				'Required parameter "functionInstanceId" was null or undefined when calling invokeFunction().',
			);
		}

		if (requestParameters.invokeFunctionParamsInner == null) {
			throw new runtime.RequiredError(
				"invokeFunctionParamsInner",
				'Required parameter "invokeFunctionParamsInner" was null or undefined when calling invokeFunction().',
			);
		}

		const queryParameters: any = {};

		const headerParameters: runtime.HTTPHeaders = {};

		headerParameters["Content-Type"] = "application/json";

		let urlPath = `/api/bridge/v1/provider/{provider_instance_id}/function/{function_instance_id}/invoke`;
		urlPath = urlPath.replace(
			`{${"provider_instance_id"}}`,
			encodeURIComponent(String(requestParameters.providerInstanceId)),
		);
		urlPath = urlPath.replace(
			`{${"function_instance_id"}}`,
			encodeURIComponent(String(requestParameters.functionInstanceId)),
		);

		const response = await this.request(
			{
				path: urlPath,
				method: "POST",
				headers: headerParameters,
				query: queryParameters,
				body: InvokeFunctionParamsInnerToJSON(
					requestParameters.invokeFunctionParamsInner,
				),
			},
			initOverrides,
		);

		if (this.isJsonMime(response.headers.get("content-type"))) {
			return new runtime.JSONApiResponse<any>(response);
		} else {
			return new runtime.TextApiResponse(response) as any;
		}
	}

	/**
	 */
	async invokeFunction(
		requestParameters: InvokeFunctionRequest,
		initOverrides?: RequestInit | runtime.InitOverrideFunction,
	): Promise<any> {
		const response = await this.invokeFunctionRaw(
			requestParameters,
			initOverrides,
		);
		return await response.value();
	}

	/**
	 */
	async jsonRpcRaw(
		requestParameters: JsonRpcRequest,
		initOverrides?: RequestInit | runtime.InitOverrideFunction,
	): Promise<runtime.ApiResponse<void>> {
		if (requestParameters.body == null) {
			throw new runtime.RequiredError(
				"body",
				'Required parameter "body" was null or undefined when calling jsonRpc().',
			);
		}

		const queryParameters: any = {};

		const headerParameters: runtime.HTTPHeaders = {};

		headerParameters["Content-Type"] = "application/json";

		const urlPath = `/api/a2a/v1`;

		const response = await this.request(
			{
				path: urlPath,
				method: "POST",
				headers: headerParameters,
				query: queryParameters,
				body: requestParameters.body as any,
			},
			initOverrides,
		);

		return new runtime.VoidApiResponse(response);
	}

	/**
	 */
	async jsonRpc(
		requestParameters: JsonRpcRequest,
		initOverrides?: RequestInit | runtime.InitOverrideFunction,
	): Promise<void> {
		await this.jsonRpcRaw(requestParameters, initOverrides);
	}

	/**
	 */
	async listAvailableProvidersRaw(
		requestParameters: ListAvailableProvidersRequest,
		initOverrides?: RequestInit | runtime.InitOverrideFunction,
	): Promise<
		runtime.ApiResponse<ProviderControllerSerializedPaginatedResponse>
	> {
		if (requestParameters.pageSize == null) {
			throw new runtime.RequiredError(
				"pageSize",
				'Required parameter "pageSize" was null or undefined when calling listAvailableProviders().',
			);
		}

		const queryParameters: any = {};

		if (requestParameters.pageSize != null) {
			queryParameters.page_size = requestParameters.pageSize;
		}

		if (requestParameters.nextPageToken != null) {
			queryParameters.next_page_token = requestParameters.nextPageToken;
		}

		const headerParameters: runtime.HTTPHeaders = {};

		const urlPath = `/api/bridge/v1/available-providers`;

		const response = await this.request(
			{
				path: urlPath,
				method: "GET",
				headers: headerParameters,
				query: queryParameters,
			},
			initOverrides,
		);

		return new runtime.JSONApiResponse(response, (jsonValue) =>
			ProviderControllerSerializedPaginatedResponseFromJSON(jsonValue),
		);
	}

	/**
	 */
	async listAvailableProviders(
		requestParameters: ListAvailableProvidersRequest,
		initOverrides?: RequestInit | runtime.InitOverrideFunction,
	): Promise<ProviderControllerSerializedPaginatedResponse> {
		const response = await this.listAvailableProvidersRaw(
			requestParameters,
			initOverrides,
		);
		return await response.value();
	}

	/**
	 */
	async listContextsRaw(
		requestParameters: ListContextsRequest,
		initOverrides?: RequestInit | runtime.InitOverrideFunction,
	): Promise<runtime.ApiResponse<ContextInfoPaginatedResponse>> {
		if (requestParameters.pageSize == null) {
			throw new runtime.RequiredError(
				"pageSize",
				'Required parameter "pageSize" was null or undefined when calling listContexts().',
			);
		}

		const queryParameters: any = {};

		if (requestParameters.pageSize != null) {
			queryParameters.page_size = requestParameters.pageSize;
		}

		if (requestParameters.nextPageToken != null) {
			queryParameters.next_page_token = requestParameters.nextPageToken;
		}

		const headerParameters: runtime.HTTPHeaders = {};

		const urlPath = `/api/task/v1/context`;

		const response = await this.request(
			{
				path: urlPath,
				method: "GET",
				headers: headerParameters,
				query: queryParameters,
			},
			initOverrides,
		);

		return new runtime.JSONApiResponse(response, (jsonValue) =>
			ContextInfoPaginatedResponseFromJSON(jsonValue),
		);
	}

	/**
	 */
	async listContexts(
		requestParameters: ListContextsRequest,
		initOverrides?: RequestInit | runtime.InitOverrideFunction,
	): Promise<ContextInfoPaginatedResponse> {
		const response = await this.listContextsRaw(
			requestParameters,
			initOverrides,
		);
		return await response.value();
	}

	/**
	 */
	async listDataEncryptionKeysRaw(
		requestParameters: ListDataEncryptionKeysRequest,
		initOverrides?: RequestInit | runtime.InitOverrideFunction,
	): Promise<runtime.ApiResponse<DataEncryptionKeyListItemPaginatedResponse>> {
		if (requestParameters.pageSize == null) {
			throw new runtime.RequiredError(
				"pageSize",
				'Required parameter "pageSize" was null or undefined when calling listDataEncryptionKeys().',
			);
		}

		const queryParameters: any = {};

		if (requestParameters.pageSize != null) {
			queryParameters.page_size = requestParameters.pageSize;
		}

		if (requestParameters.nextPageToken != null) {
			queryParameters.next_page_token = requestParameters.nextPageToken;
		}

		const headerParameters: runtime.HTTPHeaders = {};

		const urlPath = `/api/bridge/v1/encryption/data-encryption-key`;

		const response = await this.request(
			{
				path: urlPath,
				method: "GET",
				headers: headerParameters,
				query: queryParameters,
			},
			initOverrides,
		);

		return new runtime.JSONApiResponse(response, (jsonValue) =>
			DataEncryptionKeyListItemPaginatedResponseFromJSON(jsonValue),
		);
	}

	/**
	 */
	async listDataEncryptionKeys(
		requestParameters: ListDataEncryptionKeysRequest,
		initOverrides?: RequestInit | runtime.InitOverrideFunction,
	): Promise<DataEncryptionKeyListItemPaginatedResponse> {
		const response = await this.listDataEncryptionKeysRaw(
			requestParameters,
			initOverrides,
		);
		return await response.value();
	}

	/**
	 */
	async listTasksRaw(
		requestParameters: ListTasksRequest,
		initOverrides?: RequestInit | runtime.InitOverrideFunction,
	): Promise<runtime.ApiResponse<TaskPaginatedResponse>> {
		if (requestParameters.pageSize == null) {
			throw new runtime.RequiredError(
				"pageSize",
				'Required parameter "pageSize" was null or undefined when calling listTasks().',
			);
		}

		const queryParameters: any = {};

		if (requestParameters.pageSize != null) {
			queryParameters.page_size = requestParameters.pageSize;
		}

		if (requestParameters.nextPageToken != null) {
			queryParameters.next_page_token = requestParameters.nextPageToken;
		}

		const headerParameters: runtime.HTTPHeaders = {};

		const urlPath = `/api/task/v1`;

		const response = await this.request(
			{
				path: urlPath,
				method: "GET",
				headers: headerParameters,
				query: queryParameters,
			},
			initOverrides,
		);

		return new runtime.JSONApiResponse(response, (jsonValue) =>
			TaskPaginatedResponseFromJSON(jsonValue),
		);
	}

	/**
	 */
	async listTasks(
		requestParameters: ListTasksRequest,
		initOverrides?: RequestInit | runtime.InitOverrideFunction,
	): Promise<TaskPaginatedResponse> {
		const response = await this.listTasksRaw(requestParameters, initOverrides);
		return await response.value();
	}

	/**
	 */
	async listTasksByContextIdRaw(
		requestParameters: ListTasksByContextIdRequest,
		initOverrides?: RequestInit | runtime.InitOverrideFunction,
	): Promise<runtime.ApiResponse<TaskPaginatedResponse>> {
		if (requestParameters.pageSize == null) {
			throw new runtime.RequiredError(
				"pageSize",
				'Required parameter "pageSize" was null or undefined when calling listTasksByContextId().',
			);
		}

		if (requestParameters.contextId == null) {
			throw new runtime.RequiredError(
				"contextId",
				'Required parameter "contextId" was null or undefined when calling listTasksByContextId().',
			);
		}

		const queryParameters: any = {};

		if (requestParameters.pageSize != null) {
			queryParameters.page_size = requestParameters.pageSize;
		}

		if (requestParameters.nextPageToken != null) {
			queryParameters.next_page_token = requestParameters.nextPageToken;
		}

		const headerParameters: runtime.HTTPHeaders = {};

		let urlPath = `/api/task/v1/context/{context_id}/task`;
		urlPath = urlPath.replace(
			`{${"context_id"}}`,
			encodeURIComponent(String(requestParameters.contextId)),
		);

		const response = await this.request(
			{
				path: urlPath,
				method: "GET",
				headers: headerParameters,
				query: queryParameters,
			},
			initOverrides,
		);

		return new runtime.JSONApiResponse(response, (jsonValue) =>
			TaskPaginatedResponseFromJSON(jsonValue),
		);
	}

	/**
	 */
	async listTasksByContextId(
		requestParameters: ListTasksByContextIdRequest,
		initOverrides?: RequestInit | runtime.InitOverrideFunction,
	): Promise<TaskPaginatedResponse> {
		const response = await this.listTasksByContextIdRaw(
			requestParameters,
			initOverrides,
		);
		return await response.value();
	}

	/**
	 */
	async resumeUserCredentialBrokeringRaw(
		requestParameters: ResumeUserCredentialBrokeringRequest,
		initOverrides?: RequestInit | runtime.InitOverrideFunction,
	): Promise<runtime.ApiResponse<UserCredentialBrokeringResponse>> {
		const queryParameters: any = {};

		if (requestParameters.state != null) {
			queryParameters.state = requestParameters.state;
		}

		if (requestParameters.code != null) {
			queryParameters.code = requestParameters.code;
		}

		if (requestParameters.error != null) {
			queryParameters.error = requestParameters.error;
		}

		if (requestParameters.errorDescription != null) {
			queryParameters.error_description = requestParameters.errorDescription;
		}

		const headerParameters: runtime.HTTPHeaders = {};

		const urlPath = `/api/bridge/v1/generic-oauth-callback`;

		const response = await this.request(
			{
				path: urlPath,
				method: "GET",
				headers: headerParameters,
				query: queryParameters,
			},
			initOverrides,
		);

		return new runtime.JSONApiResponse(response, (jsonValue) =>
			UserCredentialBrokeringResponseFromJSON(jsonValue),
		);
	}

	/**
	 */
	async resumeUserCredentialBrokering(
		requestParameters: ResumeUserCredentialBrokeringRequest = {},
		initOverrides?: RequestInit | runtime.InitOverrideFunction,
	): Promise<UserCredentialBrokeringResponse> {
		const response = await this.resumeUserCredentialBrokeringRaw(
			requestParameters,
			initOverrides,
		);
		return await response.value();
	}

	/**
	 */
	async sendMessageRaw(
		requestParameters: SendMessageRequest,
		initOverrides?: RequestInit | runtime.InitOverrideFunction,
	): Promise<runtime.ApiResponse<CreateMessageResponse>> {
		if (requestParameters.taskId == null) {
			throw new runtime.RequiredError(
				"taskId",
				'Required parameter "taskId" was null or undefined when calling sendMessage().',
			);
		}

		if (requestParameters.createMessageRequest == null) {
			throw new runtime.RequiredError(
				"createMessageRequest",
				'Required parameter "createMessageRequest" was null or undefined when calling sendMessage().',
			);
		}

		const queryParameters: any = {};

		const headerParameters: runtime.HTTPHeaders = {};

		headerParameters["Content-Type"] = "application/json";

		let urlPath = `/api/task/v1/{task_id}/message`;
		urlPath = urlPath.replace(
			`{${"task_id"}}`,
			encodeURIComponent(String(requestParameters.taskId)),
		);

		const response = await this.request(
			{
				path: urlPath,
				method: "POST",
				headers: headerParameters,
				query: queryParameters,
				body: CreateMessageRequestToJSON(
					requestParameters.createMessageRequest,
				),
			},
			initOverrides,
		);

		return new runtime.JSONApiResponse(response, (jsonValue) =>
			CreateMessageResponseFromJSON(jsonValue),
		);
	}

	/**
	 */
	async sendMessage(
		requestParameters: SendMessageRequest,
		initOverrides?: RequestInit | runtime.InitOverrideFunction,
	): Promise<CreateMessageResponse> {
		const response = await this.sendMessageRaw(
			requestParameters,
			initOverrides,
		);
		return await response.value();
	}

	/**
	 */
	async startUserCredentialBrokeringRaw(
		requestParameters: StartUserCredentialBrokeringRequest,
		initOverrides?: RequestInit | runtime.InitOverrideFunction,
	): Promise<runtime.ApiResponse<UserCredentialBrokeringResponse>> {
		if (requestParameters.providerControllerTypeId == null) {
			throw new runtime.RequiredError(
				"providerControllerTypeId",
				'Required parameter "providerControllerTypeId" was null or undefined when calling startUserCredentialBrokering().',
			);
		}

		if (requestParameters.credentialControllerTypeId == null) {
			throw new runtime.RequiredError(
				"credentialControllerTypeId",
				'Required parameter "credentialControllerTypeId" was null or undefined when calling startUserCredentialBrokering().',
			);
		}

		if (requestParameters.startUserCredentialBrokeringParamsInner == null) {
			throw new runtime.RequiredError(
				"startUserCredentialBrokeringParamsInner",
				'Required parameter "startUserCredentialBrokeringParamsInner" was null or undefined when calling startUserCredentialBrokering().',
			);
		}

		const queryParameters: any = {};

		const headerParameters: runtime.HTTPHeaders = {};

		headerParameters["Content-Type"] = "application/json";

		let urlPath = `/api/bridge/v1/available-providers/{provider_controller_type_id}/available-credentials/{credential_controller_type_id}/credential/user-credential/broker`;
		urlPath = urlPath.replace(
			`{${"provider_controller_type_id"}}`,
			encodeURIComponent(String(requestParameters.providerControllerTypeId)),
		);
		urlPath = urlPath.replace(
			`{${"credential_controller_type_id"}}`,
			encodeURIComponent(String(requestParameters.credentialControllerTypeId)),
		);

		const response = await this.request(
			{
				path: urlPath,
				method: "POST",
				headers: headerParameters,
				query: queryParameters,
				body: StartUserCredentialBrokeringParamsInnerToJSON(
					requestParameters.startUserCredentialBrokeringParamsInner,
				),
			},
			initOverrides,
		);

		return new runtime.JSONApiResponse(response, (jsonValue) =>
			UserCredentialBrokeringResponseFromJSON(jsonValue),
		);
	}

	/**
	 */
	async startUserCredentialBrokering(
		requestParameters: StartUserCredentialBrokeringRequest,
		initOverrides?: RequestInit | runtime.InitOverrideFunction,
	): Promise<UserCredentialBrokeringResponse> {
		const response = await this.startUserCredentialBrokeringRaw(
			requestParameters,
			initOverrides,
		);
		return await response.value();
	}

	/**
	 */
	async taskHistoryRaw(
		requestParameters: TaskHistoryRequest,
		initOverrides?: RequestInit | runtime.InitOverrideFunction,
	): Promise<runtime.ApiResponse<TaskTimelineItemPaginatedResponse>> {
		if (requestParameters.pageSize == null) {
			throw new runtime.RequiredError(
				"pageSize",
				'Required parameter "pageSize" was null or undefined when calling taskHistory().',
			);
		}

		if (requestParameters.taskId == null) {
			throw new runtime.RequiredError(
				"taskId",
				'Required parameter "taskId" was null or undefined when calling taskHistory().',
			);
		}

		const queryParameters: any = {};

		if (requestParameters.pageSize != null) {
			queryParameters.page_size = requestParameters.pageSize;
		}

		if (requestParameters.nextPageToken != null) {
			queryParameters.next_page_token = requestParameters.nextPageToken;
		}

		const headerParameters: runtime.HTTPHeaders = {};

		let urlPath = `/api/task/v1/{task_id}/timeline`;
		urlPath = urlPath.replace(
			`{${"task_id"}}`,
			encodeURIComponent(String(requestParameters.taskId)),
		);

		const response = await this.request(
			{
				path: urlPath,
				method: "GET",
				headers: headerParameters,
				query: queryParameters,
			},
			initOverrides,
		);

		return new runtime.JSONApiResponse(response, (jsonValue) =>
			TaskTimelineItemPaginatedResponseFromJSON(jsonValue),
		);
	}

	/**
	 */
	async taskHistory(
		requestParameters: TaskHistoryRequest,
		initOverrides?: RequestInit | runtime.InitOverrideFunction,
	): Promise<TaskTimelineItemPaginatedResponse> {
		const response = await this.taskHistoryRaw(
			requestParameters,
			initOverrides,
		);
		return await response.value();
	}

	/**
	 */
	async updateTaskStatusRaw(
		requestParameters: UpdateTaskStatusOperationRequest,
		initOverrides?: RequestInit | runtime.InitOverrideFunction,
	): Promise<runtime.ApiResponse<any>> {
		if (requestParameters.taskId == null) {
			throw new runtime.RequiredError(
				"taskId",
				'Required parameter "taskId" was null or undefined when calling updateTaskStatus().',
			);
		}

		if (requestParameters.updateTaskStatusRequest == null) {
			throw new runtime.RequiredError(
				"updateTaskStatusRequest",
				'Required parameter "updateTaskStatusRequest" was null or undefined when calling updateTaskStatus().',
			);
		}

		const queryParameters: any = {};

		const headerParameters: runtime.HTTPHeaders = {};

		headerParameters["Content-Type"] = "application/json";

		let urlPath = `/api/task/v1/{task_id}`;
		urlPath = urlPath.replace(
			`{${"task_id"}}`,
			encodeURIComponent(String(requestParameters.taskId)),
		);

		const response = await this.request(
			{
				path: urlPath,
				method: "PUT",
				headers: headerParameters,
				query: queryParameters,
				body: UpdateTaskStatusRequestToJSON(
					requestParameters.updateTaskStatusRequest,
				),
			},
			initOverrides,
		);

		if (this.isJsonMime(response.headers.get("content-type"))) {
			return new runtime.JSONApiResponse<any>(response);
		} else {
			return new runtime.TextApiResponse(response) as any;
		}
	}

	/**
	 */
	async updateTaskStatus(
		requestParameters: UpdateTaskStatusOperationRequest,
		initOverrides?: RequestInit | runtime.InitOverrideFunction,
	): Promise<any> {
		const response = await this.updateTaskStatusRaw(
			requestParameters,
			initOverrides,
		);
		return await response.value();
	}
}
