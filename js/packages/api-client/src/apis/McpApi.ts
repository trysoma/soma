/* tslint:disable */
/* eslint-disable */
/**
 * soma
 * An open source AI agent runtime
 *
 * The version of the OpenAPI document: v1
 *
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

import type {
	AddMcpServerInstanceFunctionRequest,
	CreateMcpServerInstanceRequest,
	CreateProviderInstanceParamsInner,
	CreateResourceServerCredentialParamsInner,
	CreateUserCredentialParamsInner,
	EncryptCredentialConfigurationParamsInner,
	FunctionInstanceConfigPaginatedResponse,
	FunctionInstanceSerialized,
	FunctionInstanceSerializedPaginatedResponse,
	InvokeFunctionParamsInner,
	InvokeResult,
	McpServerInstanceSerializedWithFunctions,
	McpServerInstanceSerializedWithFunctionsPaginatedResponse,
	ProviderControllerSerializedPaginatedResponse,
	ProviderInstanceListItemPaginatedResponse,
	ProviderInstanceSerialized,
	ProviderInstanceSerializedWithEverything,
	ResourceServerCredentialSerialized,
	StartUserCredentialBrokeringParamsInner,
	UpdateMcpServerInstanceFunctionRequest,
	UpdateMcpServerInstanceRequest,
	UpdateProviderInstanceParamsInner,
	UserCredentialBrokeringResponse,
	UserCredentialSerialized,
} from "../models/index";
import {
	AddMcpServerInstanceFunctionRequestToJSON,
	CreateMcpServerInstanceRequestToJSON,
	CreateProviderInstanceParamsInnerToJSON,
	CreateResourceServerCredentialParamsInnerToJSON,
	CreateUserCredentialParamsInnerToJSON,
	EncryptCredentialConfigurationParamsInnerToJSON,
	FunctionInstanceConfigPaginatedResponseFromJSON,
	FunctionInstanceSerializedFromJSON,
	FunctionInstanceSerializedPaginatedResponseFromJSON,
	InvokeFunctionParamsInnerToJSON,
	InvokeResultFromJSON,
	McpServerInstanceSerializedWithFunctionsFromJSON,
	McpServerInstanceSerializedWithFunctionsPaginatedResponseFromJSON,
	ProviderControllerSerializedPaginatedResponseFromJSON,
	ProviderInstanceListItemPaginatedResponseFromJSON,
	ProviderInstanceSerializedFromJSON,
	ProviderInstanceSerializedWithEverythingFromJSON,
	ResourceServerCredentialSerializedFromJSON,
	StartUserCredentialBrokeringParamsInnerToJSON,
	UpdateMcpServerInstanceFunctionRequestToJSON,
	UpdateMcpServerInstanceRequestToJSON,
	UpdateProviderInstanceParamsInnerToJSON,
	UserCredentialBrokeringResponseFromJSON,
	UserCredentialSerializedFromJSON,
} from "../models/index";
import * as runtime from "../runtime";

export interface McpApiAddMcpServerInstanceFunctionOperationRequest {
	mcpServerInstanceId: string;
	addMcpServerInstanceFunctionRequest: AddMcpServerInstanceFunctionRequest;
}

export interface McpApiCreateMcpServerInstanceOperationRequest {
	createMcpServerInstanceRequest: CreateMcpServerInstanceRequest;
}

export interface McpApiCreateProviderInstanceRequest {
	providerControllerTypeId: string;
	credentialControllerTypeId: string;
	createProviderInstanceParamsInner: CreateProviderInstanceParamsInner;
}

export interface McpApiCreateResourceServerCredentialRequest {
	providerControllerTypeId: string;
	credentialControllerTypeId: string;
	createResourceServerCredentialParamsInner: CreateResourceServerCredentialParamsInner;
}

export interface McpApiCreateUserCredentialRequest {
	providerControllerTypeId: string;
	credentialControllerTypeId: string;
	createUserCredentialParamsInner: CreateUserCredentialParamsInner;
}

export interface McpApiDeleteMcpServerInstanceRequest {
	mcpServerInstanceId: string;
}

export interface McpApiDeleteProviderInstanceRequest {
	providerInstanceId: string;
}

export interface McpApiDisableFunctionRequest {
	providerInstanceId: string;
	functionControllerTypeId: string;
}

export interface McpApiEnableFunctionRequest {
	providerInstanceId: string;
	functionControllerTypeId: string;
	body: object;
}

export interface McpApiEncryptResourceServerConfigurationRequest {
	providerControllerTypeId: string;
	credentialControllerTypeId: string;
	encryptCredentialConfigurationParamsInner: EncryptCredentialConfigurationParamsInner;
}

export interface McpApiEncryptUserCredentialConfigurationRequest {
	providerControllerTypeId: string;
	credentialControllerTypeId: string;
	encryptCredentialConfigurationParamsInner: EncryptCredentialConfigurationParamsInner;
}

export interface McpApiGetMcpServerInstanceRequest {
	mcpServerInstanceId: string;
}

export interface McpApiGetProviderInstanceRequest {
	providerInstanceId: string;
}

export interface McpApiInvokeFunctionRequest {
	providerInstanceId: string;
	functionControllerTypeId: string;
	invokeFunctionParamsInner: InvokeFunctionParamsInner;
}

export interface McpApiListAvailableProvidersRequest {
	pageSize: number;
	nextPageToken?: string;
}

export interface McpApiListFunctionInstancesRequest {
	pageSize: number;
	nextPageToken?: string;
	providerInstanceId?: string;
}

export interface McpApiListMcpServerInstancesRequest {
	pageSize: number;
	nextPageToken?: string;
}

export interface McpApiListProviderInstancesRequest {
	pageSize: number;
	nextPageToken?: string;
	status?: string;
	providerControllerTypeId?: string;
}

export interface McpApiListProviderInstancesGroupedByFunctionRequest {
	pageSize: number;
	nextPageToken?: string | null;
	providerControllerTypeId?: string | null;
	functionCategory?: string | null;
}

export interface McpApiRemoveMcpServerInstanceFunctionRequest {
	mcpServerInstanceId: string;
	functionControllerTypeId: string;
	providerControllerTypeId: string;
	providerInstanceId: string;
}

export interface McpApiResumeUserCredentialBrokeringRequest {
	state?: string;
	code?: string;
	error?: string;
	errorDescription?: string;
}

export interface McpApiStartUserCredentialBrokeringRequest {
	providerControllerTypeId: string;
	credentialControllerTypeId: string;
	startUserCredentialBrokeringParamsInner: StartUserCredentialBrokeringParamsInner;
}

export interface McpApiUpdateMcpServerInstanceOperationRequest {
	mcpServerInstanceId: string;
	updateMcpServerInstanceRequest: UpdateMcpServerInstanceRequest;
}

export interface McpApiUpdateMcpServerInstanceFunctionOperationRequest {
	mcpServerInstanceId: string;
	functionControllerTypeId: string;
	providerControllerTypeId: string;
	providerInstanceId: string;
	updateMcpServerInstanceFunctionRequest: UpdateMcpServerInstanceFunctionRequest;
}

export interface McpApiUpdateProviderInstanceRequest {
	providerInstanceId: string;
	updateProviderInstanceParamsInner: UpdateProviderInstanceParamsInner;
}

/**
 *
 */
export class McpApi extends runtime.BaseAPI {
	/**
	 * Add a function mapping to an MCP server instance with a custom name
	 * Add function to MCP server instance
	 */
	async addMcpServerInstanceFunctionRaw(
		requestParameters: McpApiAddMcpServerInstanceFunctionOperationRequest,
		initOverrides?: RequestInit | runtime.InitOverrideFunction,
	): Promise<runtime.ApiResponse<McpServerInstanceSerializedWithFunctions>> {
		if (requestParameters.mcpServerInstanceId == null) {
			throw new runtime.RequiredError(
				"mcpServerInstanceId",
				'Required parameter "mcpServerInstanceId" was null or undefined when calling addMcpServerInstanceFunction().',
			);
		}

		if (requestParameters.addMcpServerInstanceFunctionRequest == null) {
			throw new runtime.RequiredError(
				"addMcpServerInstanceFunctionRequest",
				'Required parameter "addMcpServerInstanceFunctionRequest" was null or undefined when calling addMcpServerInstanceFunction().',
			);
		}

		const queryParameters: any = {};

		const headerParameters: runtime.HTTPHeaders = {};

		headerParameters["Content-Type"] = "application/json";

		if (this.configuration?.accessToken) {
			const token = this.configuration.accessToken;
			const tokenString = await token("bearer_token", []);

			if (tokenString) {
				headerParameters.Authorization = `Bearer ${tokenString}`;
			}
		}
		if (this.configuration?.apiKey) {
			headerParameters["X-API-Key"] =
				await this.configuration.apiKey("X-API-Key"); // api_key authentication
		}

		let urlPath = `/api/mcp/v1/mcp-server/{mcp_server_instance_id}/function`;
		urlPath = urlPath.replace(
			`{${"mcp_server_instance_id"}}`,
			encodeURIComponent(String(requestParameters.mcpServerInstanceId)),
		);

		const response = await this.request(
			{
				path: urlPath,
				method: "POST",
				headers: headerParameters,
				query: queryParameters,
				body: AddMcpServerInstanceFunctionRequestToJSON(
					requestParameters.addMcpServerInstanceFunctionRequest,
				),
			},
			initOverrides,
		);

		return new runtime.JSONApiResponse(response, (jsonValue) =>
			McpServerInstanceSerializedWithFunctionsFromJSON(jsonValue),
		);
	}

	/**
	 * Add a function mapping to an MCP server instance with a custom name
	 * Add function to MCP server instance
	 */
	async addMcpServerInstanceFunction(
		requestParameters: McpApiAddMcpServerInstanceFunctionOperationRequest,
		initOverrides?: RequestInit | runtime.InitOverrideFunction,
	): Promise<McpServerInstanceSerializedWithFunctions> {
		const response = await this.addMcpServerInstanceFunctionRaw(
			requestParameters,
			initOverrides,
		);
		return await response.value();
	}

	/**
	 * Create a new MCP server instance with a user-provided ID
	 * Create MCP server instance
	 */
	async createMcpServerInstanceRaw(
		requestParameters: McpApiCreateMcpServerInstanceOperationRequest,
		initOverrides?: RequestInit | runtime.InitOverrideFunction,
	): Promise<runtime.ApiResponse<McpServerInstanceSerializedWithFunctions>> {
		if (requestParameters.createMcpServerInstanceRequest == null) {
			throw new runtime.RequiredError(
				"createMcpServerInstanceRequest",
				'Required parameter "createMcpServerInstanceRequest" was null or undefined when calling createMcpServerInstance().',
			);
		}

		const queryParameters: any = {};

		const headerParameters: runtime.HTTPHeaders = {};

		headerParameters["Content-Type"] = "application/json";

		if (this.configuration?.accessToken) {
			const token = this.configuration.accessToken;
			const tokenString = await token("bearer_token", []);

			if (tokenString) {
				headerParameters.Authorization = `Bearer ${tokenString}`;
			}
		}
		if (this.configuration?.apiKey) {
			headerParameters["X-API-Key"] =
				await this.configuration.apiKey("X-API-Key"); // api_key authentication
		}

		const urlPath = `/api/mcp/v1/mcp-server`;

		const response = await this.request(
			{
				path: urlPath,
				method: "POST",
				headers: headerParameters,
				query: queryParameters,
				body: CreateMcpServerInstanceRequestToJSON(
					requestParameters.createMcpServerInstanceRequest,
				),
			},
			initOverrides,
		);

		return new runtime.JSONApiResponse(response, (jsonValue) =>
			McpServerInstanceSerializedWithFunctionsFromJSON(jsonValue),
		);
	}

	/**
	 * Create a new MCP server instance with a user-provided ID
	 * Create MCP server instance
	 */
	async createMcpServerInstance(
		requestParameters: McpApiCreateMcpServerInstanceOperationRequest,
		initOverrides?: RequestInit | runtime.InitOverrideFunction,
	): Promise<McpServerInstanceSerializedWithFunctions> {
		const response = await this.createMcpServerInstanceRaw(
			requestParameters,
			initOverrides,
		);
		return await response.value();
	}

	/**
	 * Create a new provider instance with the specified configuration
	 * Create provider
	 */
	async createProviderInstanceRaw(
		requestParameters: McpApiCreateProviderInstanceRequest,
		initOverrides?: RequestInit | runtime.InitOverrideFunction,
	): Promise<runtime.ApiResponse<ProviderInstanceSerialized>> {
		if (requestParameters.providerControllerTypeId == null) {
			throw new runtime.RequiredError(
				"providerControllerTypeId",
				'Required parameter "providerControllerTypeId" was null or undefined when calling createProviderInstance().',
			);
		}

		if (requestParameters.credentialControllerTypeId == null) {
			throw new runtime.RequiredError(
				"credentialControllerTypeId",
				'Required parameter "credentialControllerTypeId" was null or undefined when calling createProviderInstance().',
			);
		}

		if (requestParameters.createProviderInstanceParamsInner == null) {
			throw new runtime.RequiredError(
				"createProviderInstanceParamsInner",
				'Required parameter "createProviderInstanceParamsInner" was null or undefined when calling createProviderInstance().',
			);
		}

		const queryParameters: any = {};

		const headerParameters: runtime.HTTPHeaders = {};

		headerParameters["Content-Type"] = "application/json";

		if (this.configuration?.accessToken) {
			const token = this.configuration.accessToken;
			const tokenString = await token("bearer_token", []);

			if (tokenString) {
				headerParameters.Authorization = `Bearer ${tokenString}`;
			}
		}
		if (this.configuration?.apiKey) {
			headerParameters["X-API-Key"] =
				await this.configuration.apiKey("X-API-Key"); // api_key authentication
		}

		let urlPath = `/api/mcp/v1/available-providers/{provider_controller_type_id}/available-credentials/{credential_controller_type_id}`;
		urlPath = urlPath.replace(
			`{${"provider_controller_type_id"}}`,
			encodeURIComponent(String(requestParameters.providerControllerTypeId)),
		);
		urlPath = urlPath.replace(
			`{${"credential_controller_type_id"}}`,
			encodeURIComponent(String(requestParameters.credentialControllerTypeId)),
		);

		const response = await this.request(
			{
				path: urlPath,
				method: "POST",
				headers: headerParameters,
				query: queryParameters,
				body: CreateProviderInstanceParamsInnerToJSON(
					requestParameters.createProviderInstanceParamsInner,
				),
			},
			initOverrides,
		);

		return new runtime.JSONApiResponse(response, (jsonValue) =>
			ProviderInstanceSerializedFromJSON(jsonValue),
		);
	}

	/**
	 * Create a new provider instance with the specified configuration
	 * Create provider
	 */
	async createProviderInstance(
		requestParameters: McpApiCreateProviderInstanceRequest,
		initOverrides?: RequestInit | runtime.InitOverrideFunction,
	): Promise<ProviderInstanceSerialized> {
		const response = await this.createProviderInstanceRaw(
			requestParameters,
			initOverrides,
		);
		return await response.value();
	}

	/**
	 * Create a new resource server credential
	 * Create resource server credential
	 */
	async createResourceServerCredentialRaw(
		requestParameters: McpApiCreateResourceServerCredentialRequest,
		initOverrides?: RequestInit | runtime.InitOverrideFunction,
	): Promise<runtime.ApiResponse<ResourceServerCredentialSerialized>> {
		if (requestParameters.providerControllerTypeId == null) {
			throw new runtime.RequiredError(
				"providerControllerTypeId",
				'Required parameter "providerControllerTypeId" was null or undefined when calling createResourceServerCredential().',
			);
		}

		if (requestParameters.credentialControllerTypeId == null) {
			throw new runtime.RequiredError(
				"credentialControllerTypeId",
				'Required parameter "credentialControllerTypeId" was null or undefined when calling createResourceServerCredential().',
			);
		}

		if (requestParameters.createResourceServerCredentialParamsInner == null) {
			throw new runtime.RequiredError(
				"createResourceServerCredentialParamsInner",
				'Required parameter "createResourceServerCredentialParamsInner" was null or undefined when calling createResourceServerCredential().',
			);
		}

		const queryParameters: any = {};

		const headerParameters: runtime.HTTPHeaders = {};

		headerParameters["Content-Type"] = "application/json";

		if (this.configuration?.accessToken) {
			const token = this.configuration.accessToken;
			const tokenString = await token("bearer_token", []);

			if (tokenString) {
				headerParameters.Authorization = `Bearer ${tokenString}`;
			}
		}
		if (this.configuration?.apiKey) {
			headerParameters["X-API-Key"] =
				await this.configuration.apiKey("X-API-Key"); // api_key authentication
		}

		let urlPath = `/api/mcp/v1/available-providers/{provider_controller_type_id}/available-credentials/{credential_controller_type_id}/credential/resource-server`;
		urlPath = urlPath.replace(
			`{${"provider_controller_type_id"}}`,
			encodeURIComponent(String(requestParameters.providerControllerTypeId)),
		);
		urlPath = urlPath.replace(
			`{${"credential_controller_type_id"}}`,
			encodeURIComponent(String(requestParameters.credentialControllerTypeId)),
		);

		const response = await this.request(
			{
				path: urlPath,
				method: "POST",
				headers: headerParameters,
				query: queryParameters,
				body: CreateResourceServerCredentialParamsInnerToJSON(
					requestParameters.createResourceServerCredentialParamsInner,
				),
			},
			initOverrides,
		);

		return new runtime.JSONApiResponse(response, (jsonValue) =>
			ResourceServerCredentialSerializedFromJSON(jsonValue),
		);
	}

	/**
	 * Create a new resource server credential
	 * Create resource server credential
	 */
	async createResourceServerCredential(
		requestParameters: McpApiCreateResourceServerCredentialRequest,
		initOverrides?: RequestInit | runtime.InitOverrideFunction,
	): Promise<ResourceServerCredentialSerialized> {
		const response = await this.createResourceServerCredentialRaw(
			requestParameters,
			initOverrides,
		);
		return await response.value();
	}

	/**
	 * Create a new user credential
	 * Create user credential
	 */
	async createUserCredentialRaw(
		requestParameters: McpApiCreateUserCredentialRequest,
		initOverrides?: RequestInit | runtime.InitOverrideFunction,
	): Promise<runtime.ApiResponse<UserCredentialSerialized>> {
		if (requestParameters.providerControllerTypeId == null) {
			throw new runtime.RequiredError(
				"providerControllerTypeId",
				'Required parameter "providerControllerTypeId" was null or undefined when calling createUserCredential().',
			);
		}

		if (requestParameters.credentialControllerTypeId == null) {
			throw new runtime.RequiredError(
				"credentialControllerTypeId",
				'Required parameter "credentialControllerTypeId" was null or undefined when calling createUserCredential().',
			);
		}

		if (requestParameters.createUserCredentialParamsInner == null) {
			throw new runtime.RequiredError(
				"createUserCredentialParamsInner",
				'Required parameter "createUserCredentialParamsInner" was null or undefined when calling createUserCredential().',
			);
		}

		const queryParameters: any = {};

		const headerParameters: runtime.HTTPHeaders = {};

		headerParameters["Content-Type"] = "application/json";

		if (this.configuration?.accessToken) {
			const token = this.configuration.accessToken;
			const tokenString = await token("bearer_token", []);

			if (tokenString) {
				headerParameters.Authorization = `Bearer ${tokenString}`;
			}
		}
		if (this.configuration?.apiKey) {
			headerParameters["X-API-Key"] =
				await this.configuration.apiKey("X-API-Key"); // api_key authentication
		}

		let urlPath = `/api/mcp/v1/available-providers/{provider_controller_type_id}/available-credentials/{credential_controller_type_id}/credential/user-credential`;
		urlPath = urlPath.replace(
			`{${"provider_controller_type_id"}}`,
			encodeURIComponent(String(requestParameters.providerControllerTypeId)),
		);
		urlPath = urlPath.replace(
			`{${"credential_controller_type_id"}}`,
			encodeURIComponent(String(requestParameters.credentialControllerTypeId)),
		);

		const response = await this.request(
			{
				path: urlPath,
				method: "POST",
				headers: headerParameters,
				query: queryParameters,
				body: CreateUserCredentialParamsInnerToJSON(
					requestParameters.createUserCredentialParamsInner,
				),
			},
			initOverrides,
		);

		return new runtime.JSONApiResponse(response, (jsonValue) =>
			UserCredentialSerializedFromJSON(jsonValue),
		);
	}

	/**
	 * Create a new user credential
	 * Create user credential
	 */
	async createUserCredential(
		requestParameters: McpApiCreateUserCredentialRequest,
		initOverrides?: RequestInit | runtime.InitOverrideFunction,
	): Promise<UserCredentialSerialized> {
		const response = await this.createUserCredentialRaw(
			requestParameters,
			initOverrides,
		);
		return await response.value();
	}

	/**
	 * Delete an MCP server instance and all its function mappings
	 * Delete MCP server instance
	 */
	async deleteMcpServerInstanceRaw(
		requestParameters: McpApiDeleteMcpServerInstanceRequest,
		initOverrides?: RequestInit | runtime.InitOverrideFunction,
	): Promise<runtime.ApiResponse<void>> {
		if (requestParameters.mcpServerInstanceId == null) {
			throw new runtime.RequiredError(
				"mcpServerInstanceId",
				'Required parameter "mcpServerInstanceId" was null or undefined when calling deleteMcpServerInstance().',
			);
		}

		const queryParameters: any = {};

		const headerParameters: runtime.HTTPHeaders = {};

		if (this.configuration?.accessToken) {
			const token = this.configuration.accessToken;
			const tokenString = await token("bearer_token", []);

			if (tokenString) {
				headerParameters.Authorization = `Bearer ${tokenString}`;
			}
		}
		if (this.configuration?.apiKey) {
			headerParameters["X-API-Key"] =
				await this.configuration.apiKey("X-API-Key"); // api_key authentication
		}

		let urlPath = `/api/mcp/v1/mcp-server/{mcp_server_instance_id}`;
		urlPath = urlPath.replace(
			`{${"mcp_server_instance_id"}}`,
			encodeURIComponent(String(requestParameters.mcpServerInstanceId)),
		);

		const response = await this.request(
			{
				path: urlPath,
				method: "DELETE",
				headers: headerParameters,
				query: queryParameters,
			},
			initOverrides,
		);

		return new runtime.VoidApiResponse(response);
	}

	/**
	 * Delete an MCP server instance and all its function mappings
	 * Delete MCP server instance
	 */
	async deleteMcpServerInstance(
		requestParameters: McpApiDeleteMcpServerInstanceRequest,
		initOverrides?: RequestInit | runtime.InitOverrideFunction,
	): Promise<void> {
		await this.deleteMcpServerInstanceRaw(requestParameters, initOverrides);
	}

	/**
	 * Delete a provider instance by its unique identifier
	 * Delete provider
	 */
	async deleteProviderInstanceRaw(
		requestParameters: McpApiDeleteProviderInstanceRequest,
		initOverrides?: RequestInit | runtime.InitOverrideFunction,
	): Promise<runtime.ApiResponse<any>> {
		if (requestParameters.providerInstanceId == null) {
			throw new runtime.RequiredError(
				"providerInstanceId",
				'Required parameter "providerInstanceId" was null or undefined when calling deleteProviderInstance().',
			);
		}

		const queryParameters: any = {};

		const headerParameters: runtime.HTTPHeaders = {};

		if (this.configuration?.accessToken) {
			const token = this.configuration.accessToken;
			const tokenString = await token("bearer_token", []);

			if (tokenString) {
				headerParameters.Authorization = `Bearer ${tokenString}`;
			}
		}
		if (this.configuration?.apiKey) {
			headerParameters["X-API-Key"] =
				await this.configuration.apiKey("X-API-Key"); // api_key authentication
		}

		let urlPath = `/api/mcp/v1/provider/{provider_instance_id}`;
		urlPath = urlPath.replace(
			`{${"provider_instance_id"}}`,
			encodeURIComponent(String(requestParameters.providerInstanceId)),
		);

		const response = await this.request(
			{
				path: urlPath,
				method: "DELETE",
				headers: headerParameters,
				query: queryParameters,
			},
			initOverrides,
		);

		if (this.isJsonMime(response.headers.get("content-type"))) {
			return new runtime.JSONApiResponse<any>(response);
		} else {
			return new runtime.TextApiResponse(response) as any;
		}
	}

	/**
	 * Delete a provider instance by its unique identifier
	 * Delete provider
	 */
	async deleteProviderInstance(
		requestParameters: McpApiDeleteProviderInstanceRequest,
		initOverrides?: RequestInit | runtime.InitOverrideFunction,
	): Promise<any> {
		const response = await this.deleteProviderInstanceRaw(
			requestParameters,
			initOverrides,
		);
		return await response.value();
	}

	/**
	 * Disable a function for a provider instance
	 * Disable function
	 */
	async disableFunctionRaw(
		requestParameters: McpApiDisableFunctionRequest,
		initOverrides?: RequestInit | runtime.InitOverrideFunction,
	): Promise<runtime.ApiResponse<any>> {
		if (requestParameters.providerInstanceId == null) {
			throw new runtime.RequiredError(
				"providerInstanceId",
				'Required parameter "providerInstanceId" was null or undefined when calling disableFunction().',
			);
		}

		if (requestParameters.functionControllerTypeId == null) {
			throw new runtime.RequiredError(
				"functionControllerTypeId",
				'Required parameter "functionControllerTypeId" was null or undefined when calling disableFunction().',
			);
		}

		const queryParameters: any = {};

		const headerParameters: runtime.HTTPHeaders = {};

		if (this.configuration?.accessToken) {
			const token = this.configuration.accessToken;
			const tokenString = await token("bearer_token", []);

			if (tokenString) {
				headerParameters.Authorization = `Bearer ${tokenString}`;
			}
		}
		if (this.configuration?.apiKey) {
			headerParameters["X-API-Key"] =
				await this.configuration.apiKey("X-API-Key"); // api_key authentication
		}

		let urlPath = `/api/mcp/v1/provider/{provider_instance_id}/function/{function_controller_type_id}/disable`;
		urlPath = urlPath.replace(
			`{${"provider_instance_id"}}`,
			encodeURIComponent(String(requestParameters.providerInstanceId)),
		);
		urlPath = urlPath.replace(
			`{${"function_controller_type_id"}}`,
			encodeURIComponent(String(requestParameters.functionControllerTypeId)),
		);

		const response = await this.request(
			{
				path: urlPath,
				method: "POST",
				headers: headerParameters,
				query: queryParameters,
			},
			initOverrides,
		);

		if (this.isJsonMime(response.headers.get("content-type"))) {
			return new runtime.JSONApiResponse<any>(response);
		} else {
			return new runtime.TextApiResponse(response) as any;
		}
	}

	/**
	 * Disable a function for a provider instance
	 * Disable function
	 */
	async disableFunction(
		requestParameters: McpApiDisableFunctionRequest,
		initOverrides?: RequestInit | runtime.InitOverrideFunction,
	): Promise<any> {
		const response = await this.disableFunctionRaw(
			requestParameters,
			initOverrides,
		);
		return await response.value();
	}

	/**
	 * Enable a function for a provider instance
	 * Enable function
	 */
	async enableFunctionRaw(
		requestParameters: McpApiEnableFunctionRequest,
		initOverrides?: RequestInit | runtime.InitOverrideFunction,
	): Promise<runtime.ApiResponse<FunctionInstanceSerialized>> {
		if (requestParameters.providerInstanceId == null) {
			throw new runtime.RequiredError(
				"providerInstanceId",
				'Required parameter "providerInstanceId" was null or undefined when calling enableFunction().',
			);
		}

		if (requestParameters.functionControllerTypeId == null) {
			throw new runtime.RequiredError(
				"functionControllerTypeId",
				'Required parameter "functionControllerTypeId" was null or undefined when calling enableFunction().',
			);
		}

		if (requestParameters.body == null) {
			throw new runtime.RequiredError(
				"body",
				'Required parameter "body" was null or undefined when calling enableFunction().',
			);
		}

		const queryParameters: any = {};

		const headerParameters: runtime.HTTPHeaders = {};

		headerParameters["Content-Type"] = "application/json";

		if (this.configuration?.accessToken) {
			const token = this.configuration.accessToken;
			const tokenString = await token("bearer_token", []);

			if (tokenString) {
				headerParameters.Authorization = `Bearer ${tokenString}`;
			}
		}
		if (this.configuration?.apiKey) {
			headerParameters["X-API-Key"] =
				await this.configuration.apiKey("X-API-Key"); // api_key authentication
		}

		let urlPath = `/api/mcp/v1/provider/{provider_instance_id}/function/{function_controller_type_id}/enable`;
		urlPath = urlPath.replace(
			`{${"provider_instance_id"}}`,
			encodeURIComponent(String(requestParameters.providerInstanceId)),
		);
		urlPath = urlPath.replace(
			`{${"function_controller_type_id"}}`,
			encodeURIComponent(String(requestParameters.functionControllerTypeId)),
		);

		const response = await this.request(
			{
				path: urlPath,
				method: "POST",
				headers: headerParameters,
				query: queryParameters,
				body: requestParameters.body as any,
			},
			initOverrides,
		);

		return new runtime.JSONApiResponse(response, (jsonValue) =>
			FunctionInstanceSerializedFromJSON(jsonValue),
		);
	}

	/**
	 * Enable a function for a provider instance
	 * Enable function
	 */
	async enableFunction(
		requestParameters: McpApiEnableFunctionRequest,
		initOverrides?: RequestInit | runtime.InitOverrideFunction,
	): Promise<FunctionInstanceSerialized> {
		const response = await this.enableFunctionRaw(
			requestParameters,
			initOverrides,
		);
		return await response.value();
	}

	/**
	 * Encrypt a resource server credential configuration before storage
	 * Encrypt resource server config
	 */
	async encryptResourceServerConfigurationRaw(
		requestParameters: McpApiEncryptResourceServerConfigurationRequest,
		initOverrides?: RequestInit | runtime.InitOverrideFunction,
	): Promise<runtime.ApiResponse<any>> {
		if (requestParameters.providerControllerTypeId == null) {
			throw new runtime.RequiredError(
				"providerControllerTypeId",
				'Required parameter "providerControllerTypeId" was null or undefined when calling encryptResourceServerConfiguration().',
			);
		}

		if (requestParameters.credentialControllerTypeId == null) {
			throw new runtime.RequiredError(
				"credentialControllerTypeId",
				'Required parameter "credentialControllerTypeId" was null or undefined when calling encryptResourceServerConfiguration().',
			);
		}

		if (requestParameters.encryptCredentialConfigurationParamsInner == null) {
			throw new runtime.RequiredError(
				"encryptCredentialConfigurationParamsInner",
				'Required parameter "encryptCredentialConfigurationParamsInner" was null or undefined when calling encryptResourceServerConfiguration().',
			);
		}

		const queryParameters: any = {};

		const headerParameters: runtime.HTTPHeaders = {};

		headerParameters["Content-Type"] = "application/json";

		if (this.configuration?.accessToken) {
			const token = this.configuration.accessToken;
			const tokenString = await token("bearer_token", []);

			if (tokenString) {
				headerParameters.Authorization = `Bearer ${tokenString}`;
			}
		}
		if (this.configuration?.apiKey) {
			headerParameters["X-API-Key"] =
				await this.configuration.apiKey("X-API-Key"); // api_key authentication
		}

		let urlPath = `/api/mcp/v1/available-providers/{provider_controller_type_id}/available-credentials/{credential_controller_type_id}/credential/resource-server/encrypt`;
		urlPath = urlPath.replace(
			`{${"provider_controller_type_id"}}`,
			encodeURIComponent(String(requestParameters.providerControllerTypeId)),
		);
		urlPath = urlPath.replace(
			`{${"credential_controller_type_id"}}`,
			encodeURIComponent(String(requestParameters.credentialControllerTypeId)),
		);

		const response = await this.request(
			{
				path: urlPath,
				method: "POST",
				headers: headerParameters,
				query: queryParameters,
				body: EncryptCredentialConfigurationParamsInnerToJSON(
					requestParameters.encryptCredentialConfigurationParamsInner,
				),
			},
			initOverrides,
		);

		if (this.isJsonMime(response.headers.get("content-type"))) {
			return new runtime.JSONApiResponse<any>(response);
		} else {
			return new runtime.TextApiResponse(response) as any;
		}
	}

	/**
	 * Encrypt a resource server credential configuration before storage
	 * Encrypt resource server config
	 */
	async encryptResourceServerConfiguration(
		requestParameters: McpApiEncryptResourceServerConfigurationRequest,
		initOverrides?: RequestInit | runtime.InitOverrideFunction,
	): Promise<any> {
		const response = await this.encryptResourceServerConfigurationRaw(
			requestParameters,
			initOverrides,
		);
		return await response.value();
	}

	/**
	 * Encrypt a user credential configuration before storage
	 * Encrypt user credential config
	 */
	async encryptUserCredentialConfigurationRaw(
		requestParameters: McpApiEncryptUserCredentialConfigurationRequest,
		initOverrides?: RequestInit | runtime.InitOverrideFunction,
	): Promise<runtime.ApiResponse<any>> {
		if (requestParameters.providerControllerTypeId == null) {
			throw new runtime.RequiredError(
				"providerControllerTypeId",
				'Required parameter "providerControllerTypeId" was null or undefined when calling encryptUserCredentialConfiguration().',
			);
		}

		if (requestParameters.credentialControllerTypeId == null) {
			throw new runtime.RequiredError(
				"credentialControllerTypeId",
				'Required parameter "credentialControllerTypeId" was null or undefined when calling encryptUserCredentialConfiguration().',
			);
		}

		if (requestParameters.encryptCredentialConfigurationParamsInner == null) {
			throw new runtime.RequiredError(
				"encryptCredentialConfigurationParamsInner",
				'Required parameter "encryptCredentialConfigurationParamsInner" was null or undefined when calling encryptUserCredentialConfiguration().',
			);
		}

		const queryParameters: any = {};

		const headerParameters: runtime.HTTPHeaders = {};

		headerParameters["Content-Type"] = "application/json";

		if (this.configuration?.accessToken) {
			const token = this.configuration.accessToken;
			const tokenString = await token("bearer_token", []);

			if (tokenString) {
				headerParameters.Authorization = `Bearer ${tokenString}`;
			}
		}
		if (this.configuration?.apiKey) {
			headerParameters["X-API-Key"] =
				await this.configuration.apiKey("X-API-Key"); // api_key authentication
		}

		let urlPath = `/api/mcp/v1/available-providers/{provider_controller_type_id}/available-credentials/{credential_controller_type_id}/credential/user-credential/encrypt`;
		urlPath = urlPath.replace(
			`{${"provider_controller_type_id"}}`,
			encodeURIComponent(String(requestParameters.providerControllerTypeId)),
		);
		urlPath = urlPath.replace(
			`{${"credential_controller_type_id"}}`,
			encodeURIComponent(String(requestParameters.credentialControllerTypeId)),
		);

		const response = await this.request(
			{
				path: urlPath,
				method: "POST",
				headers: headerParameters,
				query: queryParameters,
				body: EncryptCredentialConfigurationParamsInnerToJSON(
					requestParameters.encryptCredentialConfigurationParamsInner,
				),
			},
			initOverrides,
		);

		if (this.isJsonMime(response.headers.get("content-type"))) {
			return new runtime.JSONApiResponse<any>(response);
		} else {
			return new runtime.TextApiResponse(response) as any;
		}
	}

	/**
	 * Encrypt a user credential configuration before storage
	 * Encrypt user credential config
	 */
	async encryptUserCredentialConfiguration(
		requestParameters: McpApiEncryptUserCredentialConfigurationRequest,
		initOverrides?: RequestInit | runtime.InitOverrideFunction,
	): Promise<any> {
		const response = await this.encryptUserCredentialConfigurationRaw(
			requestParameters,
			initOverrides,
		);
		return await response.value();
	}

	/**
	 * Get the OpenAPI specification for all function instances
	 * Get function OpenAPI spec
	 */
	async getFunctionInstancesOpenapiSpecRaw(
		initOverrides?: RequestInit | runtime.InitOverrideFunction,
	): Promise<runtime.ApiResponse<string>> {
		const queryParameters: any = {};

		const headerParameters: runtime.HTTPHeaders = {};

		if (this.configuration?.accessToken) {
			const token = this.configuration.accessToken;
			const tokenString = await token("bearer_token", []);

			if (tokenString) {
				headerParameters.Authorization = `Bearer ${tokenString}`;
			}
		}
		if (this.configuration?.apiKey) {
			headerParameters["X-API-Key"] =
				await this.configuration.apiKey("X-API-Key"); // api_key authentication
		}

		const urlPath = `/api/mcp/v1/function-instances/openapi.json`;

		const response = await this.request(
			{
				path: urlPath,
				method: "GET",
				headers: headerParameters,
				query: queryParameters,
			},
			initOverrides,
		);

		if (this.isJsonMime(response.headers.get("content-type"))) {
			return new runtime.JSONApiResponse<string>(response);
		} else {
			return new runtime.TextApiResponse(response) as any;
		}
	}

	/**
	 * Get the OpenAPI specification for all function instances
	 * Get function OpenAPI spec
	 */
	async getFunctionInstancesOpenapiSpec(
		initOverrides?: RequestInit | runtime.InitOverrideFunction,
	): Promise<string> {
		const response =
			await this.getFunctionInstancesOpenapiSpecRaw(initOverrides);
		return await response.value();
	}

	/**
	 * Retrieve an MCP server instance by its ID
	 * Get MCP server instance
	 */
	async getMcpServerInstanceRaw(
		requestParameters: McpApiGetMcpServerInstanceRequest,
		initOverrides?: RequestInit | runtime.InitOverrideFunction,
	): Promise<runtime.ApiResponse<McpServerInstanceSerializedWithFunctions>> {
		if (requestParameters.mcpServerInstanceId == null) {
			throw new runtime.RequiredError(
				"mcpServerInstanceId",
				'Required parameter "mcpServerInstanceId" was null or undefined when calling getMcpServerInstance().',
			);
		}

		const queryParameters: any = {};

		const headerParameters: runtime.HTTPHeaders = {};

		if (this.configuration?.accessToken) {
			const token = this.configuration.accessToken;
			const tokenString = await token("bearer_token", []);

			if (tokenString) {
				headerParameters.Authorization = `Bearer ${tokenString}`;
			}
		}
		if (this.configuration?.apiKey) {
			headerParameters["X-API-Key"] =
				await this.configuration.apiKey("X-API-Key"); // api_key authentication
		}

		let urlPath = `/api/mcp/v1/mcp-server/{mcp_server_instance_id}`;
		urlPath = urlPath.replace(
			`{${"mcp_server_instance_id"}}`,
			encodeURIComponent(String(requestParameters.mcpServerInstanceId)),
		);

		const response = await this.request(
			{
				path: urlPath,
				method: "GET",
				headers: headerParameters,
				query: queryParameters,
			},
			initOverrides,
		);

		return new runtime.JSONApiResponse(response, (jsonValue) =>
			McpServerInstanceSerializedWithFunctionsFromJSON(jsonValue),
		);
	}

	/**
	 * Retrieve an MCP server instance by its ID
	 * Get MCP server instance
	 */
	async getMcpServerInstance(
		requestParameters: McpApiGetMcpServerInstanceRequest,
		initOverrides?: RequestInit | runtime.InitOverrideFunction,
	): Promise<McpServerInstanceSerializedWithFunctions> {
		const response = await this.getMcpServerInstanceRaw(
			requestParameters,
			initOverrides,
		);
		return await response.value();
	}

	/**
	 * Retrieve a provider instance by its unique identifier
	 * Get provider
	 */
	async getProviderInstanceRaw(
		requestParameters: McpApiGetProviderInstanceRequest,
		initOverrides?: RequestInit | runtime.InitOverrideFunction,
	): Promise<runtime.ApiResponse<ProviderInstanceSerializedWithEverything>> {
		if (requestParameters.providerInstanceId == null) {
			throw new runtime.RequiredError(
				"providerInstanceId",
				'Required parameter "providerInstanceId" was null or undefined when calling getProviderInstance().',
			);
		}

		const queryParameters: any = {};

		const headerParameters: runtime.HTTPHeaders = {};

		if (this.configuration?.accessToken) {
			const token = this.configuration.accessToken;
			const tokenString = await token("bearer_token", []);

			if (tokenString) {
				headerParameters.Authorization = `Bearer ${tokenString}`;
			}
		}
		if (this.configuration?.apiKey) {
			headerParameters["X-API-Key"] =
				await this.configuration.apiKey("X-API-Key"); // api_key authentication
		}

		let urlPath = `/api/mcp/v1/provider/{provider_instance_id}`;
		urlPath = urlPath.replace(
			`{${"provider_instance_id"}}`,
			encodeURIComponent(String(requestParameters.providerInstanceId)),
		);

		const response = await this.request(
			{
				path: urlPath,
				method: "GET",
				headers: headerParameters,
				query: queryParameters,
			},
			initOverrides,
		);

		return new runtime.JSONApiResponse(response, (jsonValue) =>
			ProviderInstanceSerializedWithEverythingFromJSON(jsonValue),
		);
	}

	/**
	 * Retrieve a provider instance by its unique identifier
	 * Get provider
	 */
	async getProviderInstance(
		requestParameters: McpApiGetProviderInstanceRequest,
		initOverrides?: RequestInit | runtime.InitOverrideFunction,
	): Promise<ProviderInstanceSerializedWithEverything> {
		const response = await this.getProviderInstanceRaw(
			requestParameters,
			initOverrides,
		);
		return await response.value();
	}

	/**
	 * Invoke a function on a provider instance
	 * Invoke function
	 */
	async invokeFunctionRaw(
		requestParameters: McpApiInvokeFunctionRequest,
		initOverrides?: RequestInit | runtime.InitOverrideFunction,
	): Promise<runtime.ApiResponse<InvokeResult>> {
		if (requestParameters.providerInstanceId == null) {
			throw new runtime.RequiredError(
				"providerInstanceId",
				'Required parameter "providerInstanceId" was null or undefined when calling invokeFunction().',
			);
		}

		if (requestParameters.functionControllerTypeId == null) {
			throw new runtime.RequiredError(
				"functionControllerTypeId",
				'Required parameter "functionControllerTypeId" was null or undefined when calling invokeFunction().',
			);
		}

		if (requestParameters.invokeFunctionParamsInner == null) {
			throw new runtime.RequiredError(
				"invokeFunctionParamsInner",
				'Required parameter "invokeFunctionParamsInner" was null or undefined when calling invokeFunction().',
			);
		}

		const queryParameters: any = {};

		const headerParameters: runtime.HTTPHeaders = {};

		headerParameters["Content-Type"] = "application/json";

		if (this.configuration?.accessToken) {
			const token = this.configuration.accessToken;
			const tokenString = await token("bearer_token", []);

			if (tokenString) {
				headerParameters.Authorization = `Bearer ${tokenString}`;
			}
		}
		if (this.configuration?.apiKey) {
			headerParameters["X-API-Key"] =
				await this.configuration.apiKey("X-API-Key"); // api_key authentication
		}

		let urlPath = `/api/mcp/v1/provider/{provider_instance_id}/function/{function_controller_type_id}/invoke`;
		urlPath = urlPath.replace(
			`{${"provider_instance_id"}}`,
			encodeURIComponent(String(requestParameters.providerInstanceId)),
		);
		urlPath = urlPath.replace(
			`{${"function_controller_type_id"}}`,
			encodeURIComponent(String(requestParameters.functionControllerTypeId)),
		);

		const response = await this.request(
			{
				path: urlPath,
				method: "POST",
				headers: headerParameters,
				query: queryParameters,
				body: InvokeFunctionParamsInnerToJSON(
					requestParameters.invokeFunctionParamsInner,
				),
			},
			initOverrides,
		);

		return new runtime.JSONApiResponse(response, (jsonValue) =>
			InvokeResultFromJSON(jsonValue),
		);
	}

	/**
	 * Invoke a function on a provider instance
	 * Invoke function
	 */
	async invokeFunction(
		requestParameters: McpApiInvokeFunctionRequest,
		initOverrides?: RequestInit | runtime.InitOverrideFunction,
	): Promise<InvokeResult> {
		const response = await this.invokeFunctionRaw(
			requestParameters,
			initOverrides,
		);
		return await response.value();
	}

	/**
	 * List all available provider types that can be instantiated
	 * List providers
	 */
	async listAvailableProvidersRaw(
		requestParameters: McpApiListAvailableProvidersRequest,
		initOverrides?: RequestInit | runtime.InitOverrideFunction,
	): Promise<
		runtime.ApiResponse<ProviderControllerSerializedPaginatedResponse>
	> {
		if (requestParameters.pageSize == null) {
			throw new runtime.RequiredError(
				"pageSize",
				'Required parameter "pageSize" was null or undefined when calling listAvailableProviders().',
			);
		}

		const queryParameters: any = {};

		if (requestParameters.pageSize != null) {
			queryParameters.page_size = requestParameters.pageSize;
		}

		if (requestParameters.nextPageToken != null) {
			queryParameters.next_page_token = requestParameters.nextPageToken;
		}

		const headerParameters: runtime.HTTPHeaders = {};

		if (this.configuration?.accessToken) {
			const token = this.configuration.accessToken;
			const tokenString = await token("bearer_token", []);

			if (tokenString) {
				headerParameters.Authorization = `Bearer ${tokenString}`;
			}
		}
		if (this.configuration?.apiKey) {
			headerParameters["X-API-Key"] =
				await this.configuration.apiKey("X-API-Key"); // api_key authentication
		}

		const urlPath = `/api/mcp/v1/available-providers`;

		const response = await this.request(
			{
				path: urlPath,
				method: "GET",
				headers: headerParameters,
				query: queryParameters,
			},
			initOverrides,
		);

		return new runtime.JSONApiResponse(response, (jsonValue) =>
			ProviderControllerSerializedPaginatedResponseFromJSON(jsonValue),
		);
	}

	/**
	 * List all available provider types that can be instantiated
	 * List providers
	 */
	async listAvailableProviders(
		requestParameters: McpApiListAvailableProvidersRequest,
		initOverrides?: RequestInit | runtime.InitOverrideFunction,
	): Promise<ProviderControllerSerializedPaginatedResponse> {
		const response = await this.listAvailableProvidersRaw(
			requestParameters,
			initOverrides,
		);
		return await response.value();
	}

	/**
	 * List all function instances with optional filtering by provider instance
	 * List function instances
	 */
	async listFunctionInstancesRaw(
		requestParameters: McpApiListFunctionInstancesRequest,
		initOverrides?: RequestInit | runtime.InitOverrideFunction,
	): Promise<runtime.ApiResponse<FunctionInstanceSerializedPaginatedResponse>> {
		if (requestParameters.pageSize == null) {
			throw new runtime.RequiredError(
				"pageSize",
				'Required parameter "pageSize" was null or undefined when calling listFunctionInstances().',
			);
		}

		const queryParameters: any = {};

		if (requestParameters.pageSize != null) {
			queryParameters.page_size = requestParameters.pageSize;
		}

		if (requestParameters.nextPageToken != null) {
			queryParameters.next_page_token = requestParameters.nextPageToken;
		}

		if (requestParameters.providerInstanceId != null) {
			queryParameters.provider_instance_id =
				requestParameters.providerInstanceId;
		}

		const headerParameters: runtime.HTTPHeaders = {};

		if (this.configuration?.accessToken) {
			const token = this.configuration.accessToken;
			const tokenString = await token("bearer_token", []);

			if (tokenString) {
				headerParameters.Authorization = `Bearer ${tokenString}`;
			}
		}
		if (this.configuration?.apiKey) {
			headerParameters["X-API-Key"] =
				await this.configuration.apiKey("X-API-Key"); // api_key authentication
		}

		const urlPath = `/api/mcp/v1/function-instances`;

		const response = await this.request(
			{
				path: urlPath,
				method: "GET",
				headers: headerParameters,
				query: queryParameters,
			},
			initOverrides,
		);

		return new runtime.JSONApiResponse(response, (jsonValue) =>
			FunctionInstanceSerializedPaginatedResponseFromJSON(jsonValue),
		);
	}

	/**
	 * List all function instances with optional filtering by provider instance
	 * List function instances
	 */
	async listFunctionInstances(
		requestParameters: McpApiListFunctionInstancesRequest,
		initOverrides?: RequestInit | runtime.InitOverrideFunction,
	): Promise<FunctionInstanceSerializedPaginatedResponse> {
		const response = await this.listFunctionInstancesRaw(
			requestParameters,
			initOverrides,
		);
		return await response.value();
	}

	/**
	 * List all MCP server instances with pagination
	 * List MCP server instances
	 */
	async listMcpServerInstancesRaw(
		requestParameters: McpApiListMcpServerInstancesRequest,
		initOverrides?: RequestInit | runtime.InitOverrideFunction,
	): Promise<
		runtime.ApiResponse<McpServerInstanceSerializedWithFunctionsPaginatedResponse>
	> {
		if (requestParameters.pageSize == null) {
			throw new runtime.RequiredError(
				"pageSize",
				'Required parameter "pageSize" was null or undefined when calling listMcpServerInstances().',
			);
		}

		const queryParameters: any = {};

		if (requestParameters.pageSize != null) {
			queryParameters.page_size = requestParameters.pageSize;
		}

		if (requestParameters.nextPageToken != null) {
			queryParameters.next_page_token = requestParameters.nextPageToken;
		}

		const headerParameters: runtime.HTTPHeaders = {};

		if (this.configuration?.accessToken) {
			const token = this.configuration.accessToken;
			const tokenString = await token("bearer_token", []);

			if (tokenString) {
				headerParameters.Authorization = `Bearer ${tokenString}`;
			}
		}
		if (this.configuration?.apiKey) {
			headerParameters["X-API-Key"] =
				await this.configuration.apiKey("X-API-Key"); // api_key authentication
		}

		const urlPath = `/api/mcp/v1/mcp-server`;

		const response = await this.request(
			{
				path: urlPath,
				method: "GET",
				headers: headerParameters,
				query: queryParameters,
			},
			initOverrides,
		);

		return new runtime.JSONApiResponse(response, (jsonValue) =>
			McpServerInstanceSerializedWithFunctionsPaginatedResponseFromJSON(
				jsonValue,
			),
		);
	}

	/**
	 * List all MCP server instances with pagination
	 * List MCP server instances
	 */
	async listMcpServerInstances(
		requestParameters: McpApiListMcpServerInstancesRequest,
		initOverrides?: RequestInit | runtime.InitOverrideFunction,
	): Promise<McpServerInstanceSerializedWithFunctionsPaginatedResponse> {
		const response = await this.listMcpServerInstancesRaw(
			requestParameters,
			initOverrides,
		);
		return await response.value();
	}

	/**
	 * List all provider instances with optional filtering by status and provider type
	 * List provider instances
	 */
	async listProviderInstancesRaw(
		requestParameters: McpApiListProviderInstancesRequest,
		initOverrides?: RequestInit | runtime.InitOverrideFunction,
	): Promise<runtime.ApiResponse<ProviderInstanceListItemPaginatedResponse>> {
		if (requestParameters.pageSize == null) {
			throw new runtime.RequiredError(
				"pageSize",
				'Required parameter "pageSize" was null or undefined when calling listProviderInstances().',
			);
		}

		const queryParameters: any = {};

		if (requestParameters.pageSize != null) {
			queryParameters.page_size = requestParameters.pageSize;
		}

		if (requestParameters.nextPageToken != null) {
			queryParameters.next_page_token = requestParameters.nextPageToken;
		}

		if (requestParameters.status != null) {
			queryParameters.status = requestParameters.status;
		}

		if (requestParameters.providerControllerTypeId != null) {
			queryParameters.provider_controller_type_id =
				requestParameters.providerControllerTypeId;
		}

		const headerParameters: runtime.HTTPHeaders = {};

		if (this.configuration?.accessToken) {
			const token = this.configuration.accessToken;
			const tokenString = await token("bearer_token", []);

			if (tokenString) {
				headerParameters.Authorization = `Bearer ${tokenString}`;
			}
		}
		if (this.configuration?.apiKey) {
			headerParameters["X-API-Key"] =
				await this.configuration.apiKey("X-API-Key"); // api_key authentication
		}

		const urlPath = `/api/mcp/v1/provider`;

		const response = await this.request(
			{
				path: urlPath,
				method: "GET",
				headers: headerParameters,
				query: queryParameters,
			},
			initOverrides,
		);

		return new runtime.JSONApiResponse(response, (jsonValue) =>
			ProviderInstanceListItemPaginatedResponseFromJSON(jsonValue),
		);
	}

	/**
	 * List all provider instances with optional filtering by status and provider type
	 * List provider instances
	 */
	async listProviderInstances(
		requestParameters: McpApiListProviderInstancesRequest,
		initOverrides?: RequestInit | runtime.InitOverrideFunction,
	): Promise<ProviderInstanceListItemPaginatedResponse> {
		const response = await this.listProviderInstancesRaw(
			requestParameters,
			initOverrides,
		);
		return await response.value();
	}

	/**
	 * List provider instances grouped by their associated functions
	 * List providers by function
	 */
	async listProviderInstancesGroupedByFunctionRaw(
		requestParameters: McpApiListProviderInstancesGroupedByFunctionRequest,
		initOverrides?: RequestInit | runtime.InitOverrideFunction,
	): Promise<runtime.ApiResponse<FunctionInstanceConfigPaginatedResponse>> {
		if (requestParameters.pageSize == null) {
			throw new runtime.RequiredError(
				"pageSize",
				'Required parameter "pageSize" was null or undefined when calling listProviderInstancesGroupedByFunction().',
			);
		}

		const queryParameters: any = {};

		if (requestParameters.nextPageToken != null) {
			queryParameters.next_page_token = requestParameters.nextPageToken;
		}

		if (requestParameters.pageSize != null) {
			queryParameters.page_size = requestParameters.pageSize;
		}

		if (requestParameters.providerControllerTypeId != null) {
			queryParameters.provider_controller_type_id =
				requestParameters.providerControllerTypeId;
		}

		if (requestParameters.functionCategory != null) {
			queryParameters.function_category = requestParameters.functionCategory;
		}

		const headerParameters: runtime.HTTPHeaders = {};

		if (this.configuration?.accessToken) {
			const token = this.configuration.accessToken;
			const tokenString = await token("bearer_token", []);

			if (tokenString) {
				headerParameters.Authorization = `Bearer ${tokenString}`;
			}
		}
		if (this.configuration?.apiKey) {
			headerParameters["X-API-Key"] =
				await this.configuration.apiKey("X-API-Key"); // api_key authentication
		}

		const urlPath = `/api/mcp/v1/provider/grouped-by-function`;

		const response = await this.request(
			{
				path: urlPath,
				method: "GET",
				headers: headerParameters,
				query: queryParameters,
			},
			initOverrides,
		);

		return new runtime.JSONApiResponse(response, (jsonValue) =>
			FunctionInstanceConfigPaginatedResponseFromJSON(jsonValue),
		);
	}

	/**
	 * List provider instances grouped by their associated functions
	 * List providers by function
	 */
	async listProviderInstancesGroupedByFunction(
		requestParameters: McpApiListProviderInstancesGroupedByFunctionRequest,
		initOverrides?: RequestInit | runtime.InitOverrideFunction,
	): Promise<FunctionInstanceConfigPaginatedResponse> {
		const response = await this.listProviderInstancesGroupedByFunctionRaw(
			requestParameters,
			initOverrides,
		);
		return await response.value();
	}

	/**
	 * Remove a function mapping from an MCP server instance
	 * Remove function from MCP server instance
	 */
	async removeMcpServerInstanceFunctionRaw(
		requestParameters: McpApiRemoveMcpServerInstanceFunctionRequest,
		initOverrides?: RequestInit | runtime.InitOverrideFunction,
	): Promise<runtime.ApiResponse<McpServerInstanceSerializedWithFunctions>> {
		if (requestParameters.mcpServerInstanceId == null) {
			throw new runtime.RequiredError(
				"mcpServerInstanceId",
				'Required parameter "mcpServerInstanceId" was null or undefined when calling removeMcpServerInstanceFunction().',
			);
		}

		if (requestParameters.functionControllerTypeId == null) {
			throw new runtime.RequiredError(
				"functionControllerTypeId",
				'Required parameter "functionControllerTypeId" was null or undefined when calling removeMcpServerInstanceFunction().',
			);
		}

		if (requestParameters.providerControllerTypeId == null) {
			throw new runtime.RequiredError(
				"providerControllerTypeId",
				'Required parameter "providerControllerTypeId" was null or undefined when calling removeMcpServerInstanceFunction().',
			);
		}

		if (requestParameters.providerInstanceId == null) {
			throw new runtime.RequiredError(
				"providerInstanceId",
				'Required parameter "providerInstanceId" was null or undefined when calling removeMcpServerInstanceFunction().',
			);
		}

		const queryParameters: any = {};

		const headerParameters: runtime.HTTPHeaders = {};

		if (this.configuration?.accessToken) {
			const token = this.configuration.accessToken;
			const tokenString = await token("bearer_token", []);

			if (tokenString) {
				headerParameters.Authorization = `Bearer ${tokenString}`;
			}
		}
		if (this.configuration?.apiKey) {
			headerParameters["X-API-Key"] =
				await this.configuration.apiKey("X-API-Key"); // api_key authentication
		}

		let urlPath = `/api/mcp/v1/mcp-server/{mcp_server_instance_id}/function/{function_controller_type_id}/{provider_controller_type_id}/{provider_instance_id}`;
		urlPath = urlPath.replace(
			`{${"mcp_server_instance_id"}}`,
			encodeURIComponent(String(requestParameters.mcpServerInstanceId)),
		);
		urlPath = urlPath.replace(
			`{${"function_controller_type_id"}}`,
			encodeURIComponent(String(requestParameters.functionControllerTypeId)),
		);
		urlPath = urlPath.replace(
			`{${"provider_controller_type_id"}}`,
			encodeURIComponent(String(requestParameters.providerControllerTypeId)),
		);
		urlPath = urlPath.replace(
			`{${"provider_instance_id"}}`,
			encodeURIComponent(String(requestParameters.providerInstanceId)),
		);

		const response = await this.request(
			{
				path: urlPath,
				method: "DELETE",
				headers: headerParameters,
				query: queryParameters,
			},
			initOverrides,
		);

		return new runtime.JSONApiResponse(response, (jsonValue) =>
			McpServerInstanceSerializedWithFunctionsFromJSON(jsonValue),
		);
	}

	/**
	 * Remove a function mapping from an MCP server instance
	 * Remove function from MCP server instance
	 */
	async removeMcpServerInstanceFunction(
		requestParameters: McpApiRemoveMcpServerInstanceFunctionRequest,
		initOverrides?: RequestInit | runtime.InitOverrideFunction,
	): Promise<McpServerInstanceSerializedWithFunctions> {
		const response = await this.removeMcpServerInstanceFunctionRaw(
			requestParameters,
			initOverrides,
		);
		return await response.value();
	}

	/**
	 * Handle OAuth callback to complete user credential brokering flow
	 * OAuth callback
	 */
	async resumeUserCredentialBrokeringRaw(
		requestParameters: McpApiResumeUserCredentialBrokeringRequest,
		initOverrides?: RequestInit | runtime.InitOverrideFunction,
	): Promise<runtime.ApiResponse<UserCredentialBrokeringResponse>> {
		const queryParameters: any = {};

		if (requestParameters.state != null) {
			queryParameters.state = requestParameters.state;
		}

		if (requestParameters.code != null) {
			queryParameters.code = requestParameters.code;
		}

		if (requestParameters.error != null) {
			queryParameters.error = requestParameters.error;
		}

		if (requestParameters.errorDescription != null) {
			queryParameters.error_description = requestParameters.errorDescription;
		}

		const headerParameters: runtime.HTTPHeaders = {};

		if (this.configuration?.accessToken) {
			const token = this.configuration.accessToken;
			const tokenString = await token("bearer_token", []);

			if (tokenString) {
				headerParameters.Authorization = `Bearer ${tokenString}`;
			}
		}
		if (this.configuration?.apiKey) {
			headerParameters["X-API-Key"] =
				await this.configuration.apiKey("X-API-Key"); // api_key authentication
		}

		const urlPath = `/api/mcp/v1/generic-oauth-callback`;

		const response = await this.request(
			{
				path: urlPath,
				method: "GET",
				headers: headerParameters,
				query: queryParameters,
			},
			initOverrides,
		);

		return new runtime.JSONApiResponse(response, (jsonValue) =>
			UserCredentialBrokeringResponseFromJSON(jsonValue),
		);
	}

	/**
	 * Handle OAuth callback to complete user credential brokering flow
	 * OAuth callback
	 */
	async resumeUserCredentialBrokering(
		requestParameters: McpApiResumeUserCredentialBrokeringRequest = {},
		initOverrides?: RequestInit | runtime.InitOverrideFunction,
	): Promise<UserCredentialBrokeringResponse> {
		const response = await this.resumeUserCredentialBrokeringRaw(
			requestParameters,
			initOverrides,
		);
		return await response.value();
	}

	/**
	 * Start the OAuth flow for user credential brokering
	 * Start credential brokering
	 */
	async startUserCredentialBrokeringRaw(
		requestParameters: McpApiStartUserCredentialBrokeringRequest,
		initOverrides?: RequestInit | runtime.InitOverrideFunction,
	): Promise<runtime.ApiResponse<UserCredentialBrokeringResponse>> {
		if (requestParameters.providerControllerTypeId == null) {
			throw new runtime.RequiredError(
				"providerControllerTypeId",
				'Required parameter "providerControllerTypeId" was null or undefined when calling startUserCredentialBrokering().',
			);
		}

		if (requestParameters.credentialControllerTypeId == null) {
			throw new runtime.RequiredError(
				"credentialControllerTypeId",
				'Required parameter "credentialControllerTypeId" was null or undefined when calling startUserCredentialBrokering().',
			);
		}

		if (requestParameters.startUserCredentialBrokeringParamsInner == null) {
			throw new runtime.RequiredError(
				"startUserCredentialBrokeringParamsInner",
				'Required parameter "startUserCredentialBrokeringParamsInner" was null or undefined when calling startUserCredentialBrokering().',
			);
		}

		const queryParameters: any = {};

		const headerParameters: runtime.HTTPHeaders = {};

		headerParameters["Content-Type"] = "application/json";

		if (this.configuration?.accessToken) {
			const token = this.configuration.accessToken;
			const tokenString = await token("bearer_token", []);

			if (tokenString) {
				headerParameters.Authorization = `Bearer ${tokenString}`;
			}
		}
		if (this.configuration?.apiKey) {
			headerParameters["X-API-Key"] =
				await this.configuration.apiKey("X-API-Key"); // api_key authentication
		}

		let urlPath = `/api/mcp/v1/available-providers/{provider_controller_type_id}/available-credentials/{credential_controller_type_id}/credential/user-credential/broker`;
		urlPath = urlPath.replace(
			`{${"provider_controller_type_id"}}`,
			encodeURIComponent(String(requestParameters.providerControllerTypeId)),
		);
		urlPath = urlPath.replace(
			`{${"credential_controller_type_id"}}`,
			encodeURIComponent(String(requestParameters.credentialControllerTypeId)),
		);

		const response = await this.request(
			{
				path: urlPath,
				method: "POST",
				headers: headerParameters,
				query: queryParameters,
				body: StartUserCredentialBrokeringParamsInnerToJSON(
					requestParameters.startUserCredentialBrokeringParamsInner,
				),
			},
			initOverrides,
		);

		return new runtime.JSONApiResponse(response, (jsonValue) =>
			UserCredentialBrokeringResponseFromJSON(jsonValue),
		);
	}

	/**
	 * Start the OAuth flow for user credential brokering
	 * Start credential brokering
	 */
	async startUserCredentialBrokering(
		requestParameters: McpApiStartUserCredentialBrokeringRequest,
		initOverrides?: RequestInit | runtime.InitOverrideFunction,
	): Promise<UserCredentialBrokeringResponse> {
		const response = await this.startUserCredentialBrokeringRaw(
			requestParameters,
			initOverrides,
		);
		return await response.value();
	}

	/**
	 * Update an MCP server instance name
	 * Update MCP server instance
	 */
	async updateMcpServerInstanceRaw(
		requestParameters: McpApiUpdateMcpServerInstanceOperationRequest,
		initOverrides?: RequestInit | runtime.InitOverrideFunction,
	): Promise<runtime.ApiResponse<McpServerInstanceSerializedWithFunctions>> {
		if (requestParameters.mcpServerInstanceId == null) {
			throw new runtime.RequiredError(
				"mcpServerInstanceId",
				'Required parameter "mcpServerInstanceId" was null or undefined when calling updateMcpServerInstance().',
			);
		}

		if (requestParameters.updateMcpServerInstanceRequest == null) {
			throw new runtime.RequiredError(
				"updateMcpServerInstanceRequest",
				'Required parameter "updateMcpServerInstanceRequest" was null or undefined when calling updateMcpServerInstance().',
			);
		}

		const queryParameters: any = {};

		const headerParameters: runtime.HTTPHeaders = {};

		headerParameters["Content-Type"] = "application/json";

		if (this.configuration?.accessToken) {
			const token = this.configuration.accessToken;
			const tokenString = await token("bearer_token", []);

			if (tokenString) {
				headerParameters.Authorization = `Bearer ${tokenString}`;
			}
		}
		if (this.configuration?.apiKey) {
			headerParameters["X-API-Key"] =
				await this.configuration.apiKey("X-API-Key"); // api_key authentication
		}

		let urlPath = `/api/mcp/v1/mcp-server/{mcp_server_instance_id}`;
		urlPath = urlPath.replace(
			`{${"mcp_server_instance_id"}}`,
			encodeURIComponent(String(requestParameters.mcpServerInstanceId)),
		);

		const response = await this.request(
			{
				path: urlPath,
				method: "PATCH",
				headers: headerParameters,
				query: queryParameters,
				body: UpdateMcpServerInstanceRequestToJSON(
					requestParameters.updateMcpServerInstanceRequest,
				),
			},
			initOverrides,
		);

		return new runtime.JSONApiResponse(response, (jsonValue) =>
			McpServerInstanceSerializedWithFunctionsFromJSON(jsonValue),
		);
	}

	/**
	 * Update an MCP server instance name
	 * Update MCP server instance
	 */
	async updateMcpServerInstance(
		requestParameters: McpApiUpdateMcpServerInstanceOperationRequest,
		initOverrides?: RequestInit | runtime.InitOverrideFunction,
	): Promise<McpServerInstanceSerializedWithFunctions> {
		const response = await this.updateMcpServerInstanceRaw(
			requestParameters,
			initOverrides,
		);
		return await response.value();
	}

	/**
	 * Update the function name and description for a function mapping
	 * Update function in MCP server instance
	 */
	async updateMcpServerInstanceFunctionRaw(
		requestParameters: McpApiUpdateMcpServerInstanceFunctionOperationRequest,
		initOverrides?: RequestInit | runtime.InitOverrideFunction,
	): Promise<runtime.ApiResponse<McpServerInstanceSerializedWithFunctions>> {
		if (requestParameters.mcpServerInstanceId == null) {
			throw new runtime.RequiredError(
				"mcpServerInstanceId",
				'Required parameter "mcpServerInstanceId" was null or undefined when calling updateMcpServerInstanceFunction().',
			);
		}

		if (requestParameters.functionControllerTypeId == null) {
			throw new runtime.RequiredError(
				"functionControllerTypeId",
				'Required parameter "functionControllerTypeId" was null or undefined when calling updateMcpServerInstanceFunction().',
			);
		}

		if (requestParameters.providerControllerTypeId == null) {
			throw new runtime.RequiredError(
				"providerControllerTypeId",
				'Required parameter "providerControllerTypeId" was null or undefined when calling updateMcpServerInstanceFunction().',
			);
		}

		if (requestParameters.providerInstanceId == null) {
			throw new runtime.RequiredError(
				"providerInstanceId",
				'Required parameter "providerInstanceId" was null or undefined when calling updateMcpServerInstanceFunction().',
			);
		}

		if (requestParameters.updateMcpServerInstanceFunctionRequest == null) {
			throw new runtime.RequiredError(
				"updateMcpServerInstanceFunctionRequest",
				'Required parameter "updateMcpServerInstanceFunctionRequest" was null or undefined when calling updateMcpServerInstanceFunction().',
			);
		}

		const queryParameters: any = {};

		const headerParameters: runtime.HTTPHeaders = {};

		headerParameters["Content-Type"] = "application/json";

		if (this.configuration?.accessToken) {
			const token = this.configuration.accessToken;
			const tokenString = await token("bearer_token", []);

			if (tokenString) {
				headerParameters.Authorization = `Bearer ${tokenString}`;
			}
		}
		if (this.configuration?.apiKey) {
			headerParameters["X-API-Key"] =
				await this.configuration.apiKey("X-API-Key"); // api_key authentication
		}

		let urlPath = `/api/mcp/v1/mcp-server/{mcp_server_instance_id}/function/{function_controller_type_id}/{provider_controller_type_id}/{provider_instance_id}`;
		urlPath = urlPath.replace(
			`{${"mcp_server_instance_id"}}`,
			encodeURIComponent(String(requestParameters.mcpServerInstanceId)),
		);
		urlPath = urlPath.replace(
			`{${"function_controller_type_id"}}`,
			encodeURIComponent(String(requestParameters.functionControllerTypeId)),
		);
		urlPath = urlPath.replace(
			`{${"provider_controller_type_id"}}`,
			encodeURIComponent(String(requestParameters.providerControllerTypeId)),
		);
		urlPath = urlPath.replace(
			`{${"provider_instance_id"}}`,
			encodeURIComponent(String(requestParameters.providerInstanceId)),
		);

		const response = await this.request(
			{
				path: urlPath,
				method: "PATCH",
				headers: headerParameters,
				query: queryParameters,
				body: UpdateMcpServerInstanceFunctionRequestToJSON(
					requestParameters.updateMcpServerInstanceFunctionRequest,
				),
			},
			initOverrides,
		);

		return new runtime.JSONApiResponse(response, (jsonValue) =>
			McpServerInstanceSerializedWithFunctionsFromJSON(jsonValue),
		);
	}

	/**
	 * Update the function name and description for a function mapping
	 * Update function in MCP server instance
	 */
	async updateMcpServerInstanceFunction(
		requestParameters: McpApiUpdateMcpServerInstanceFunctionOperationRequest,
		initOverrides?: RequestInit | runtime.InitOverrideFunction,
	): Promise<McpServerInstanceSerializedWithFunctions> {
		const response = await this.updateMcpServerInstanceFunctionRaw(
			requestParameters,
			initOverrides,
		);
		return await response.value();
	}

	/**
	 * Update an existing provider instance configuration
	 * Update provider
	 */
	async updateProviderInstanceRaw(
		requestParameters: McpApiUpdateProviderInstanceRequest,
		initOverrides?: RequestInit | runtime.InitOverrideFunction,
	): Promise<runtime.ApiResponse<any>> {
		if (requestParameters.providerInstanceId == null) {
			throw new runtime.RequiredError(
				"providerInstanceId",
				'Required parameter "providerInstanceId" was null or undefined when calling updateProviderInstance().',
			);
		}

		if (requestParameters.updateProviderInstanceParamsInner == null) {
			throw new runtime.RequiredError(
				"updateProviderInstanceParamsInner",
				'Required parameter "updateProviderInstanceParamsInner" was null or undefined when calling updateProviderInstance().',
			);
		}

		const queryParameters: any = {};

		const headerParameters: runtime.HTTPHeaders = {};

		headerParameters["Content-Type"] = "application/json";

		if (this.configuration?.accessToken) {
			const token = this.configuration.accessToken;
			const tokenString = await token("bearer_token", []);

			if (tokenString) {
				headerParameters.Authorization = `Bearer ${tokenString}`;
			}
		}
		if (this.configuration?.apiKey) {
			headerParameters["X-API-Key"] =
				await this.configuration.apiKey("X-API-Key"); // api_key authentication
		}

		let urlPath = `/api/mcp/v1/provider/{provider_instance_id}`;
		urlPath = urlPath.replace(
			`{${"provider_instance_id"}}`,
			encodeURIComponent(String(requestParameters.providerInstanceId)),
		);

		const response = await this.request(
			{
				path: urlPath,
				method: "PATCH",
				headers: headerParameters,
				query: queryParameters,
				body: UpdateProviderInstanceParamsInnerToJSON(
					requestParameters.updateProviderInstanceParamsInner,
				),
			},
			initOverrides,
		);

		if (this.isJsonMime(response.headers.get("content-type"))) {
			return new runtime.JSONApiResponse<any>(response);
		} else {
			return new runtime.TextApiResponse(response) as any;
		}
	}

	/**
	 * Update an existing provider instance configuration
	 * Update provider
	 */
	async updateProviderInstance(
		requestParameters: McpApiUpdateProviderInstanceRequest,
		initOverrides?: RequestInit | runtime.InitOverrideFunction,
	): Promise<any> {
		const response = await this.updateProviderInstanceRaw(
			requestParameters,
			initOverrides,
		);
		return await response.value();
	}
}
