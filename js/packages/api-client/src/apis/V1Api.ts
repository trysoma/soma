/* tslint:disable */
/* eslint-disable */
/**
 * soma
 * An open source AI agent runtime
 *
 * The version of the OpenAPI document: v1
 *
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

import type {
	AddGroupMemberRequest,
	AddMcpServerInstanceFunctionRequest,
	ContextInfoPaginatedResponse,
	CreateApiKeyParams,
	CreateApiKeyResponse,
	CreateDataEncryptionKeyParamsRoute,
	CreateDekAliasRequest,
	CreateGroupRequest,
	CreateMcpServerInstanceRequest,
	CreateMessageRequest,
	CreateMessageResponse,
	CreateProviderInstanceParamsInner,
	CreateResourceServerCredentialParamsInner,
	CreateSecretRequest,
	CreateUserAuthFlowConfigParams,
	CreateUserAuthFlowConfigResponse,
	CreateUserCredentialParamsInner,
	CreateUserRequest,
	CreateVariableRequest,
	DataEncryptionKey,
	DataEncryptionKeyAlias,
	DataEncryptionKeyListItemPaginatedResponse,
	DeleteSecretResponse,
	DeleteVariableResponse,
	EncryptCredentialConfigurationParamsInner,
	EncryptedApiKeyConfig,
	EnvelopeEncryptionKey,
	EnvelopeEncryptionKeyPaginatedResponse,
	FunctionInstanceConfigPaginatedResponse,
	FunctionInstanceSerialized,
	FunctionInstanceSerializedPaginatedResponse,
	GetUserAuthFlowConfigResponse,
	Group,
	GroupMemberWithUserPaginatedResponse,
	GroupPaginatedResponse,
	Identity,
	ImportDataEncryptionKeyParamsRoute,
	ImportSecretRequest,
	ImportUserAuthFlowConfigParams,
	ImportVariableRequest,
	InvokeFunctionParamsInner,
	InvokeResult,
	JwkResponsePaginatedResponse,
	JwksResponse,
	ListAgentsResponse,
	ListApiKeysResponse,
	ListDecryptedSecretsResponse,
	ListSecretsResponse,
	ListUserAuthFlowConfigResponse,
	ListVariablesResponse,
	McpServerInstanceSerializedWithFunctions,
	McpServerInstanceSerializedWithFunctionsPaginatedResponse,
	MigrateAllDataEncryptionKeysParamsRoute,
	MigrateDataEncryptionKeyParamsRoute,
	NormalizedTokenIssuanceResult,
	ProviderControllerSerializedPaginatedResponse,
	ProviderInstanceListItemPaginatedResponse,
	ProviderInstanceSerialized,
	ProviderInstanceSerializedWithEverything,
	RefreshTokenRequest,
	ResourceServerCredentialSerialized,
	ScimGroup,
	ScimListResponse,
	ScimPatchRequest,
	ScimUser,
	Secret,
	StartUserCredentialBrokeringParamsInner,
	StsTokenConfig,
	StsTokenConfigPaginatedResponse,
	TaskPaginatedResponse,
	TaskTimelineItemPaginatedResponse,
	TaskWithDetails,
	TokenResponse,
	UpdateAliasParams,
	UpdateGroupRequest,
	UpdateMcpServerInstanceFunctionRequest,
	UpdateMcpServerInstanceRequest,
	UpdateProviderInstanceParamsInner,
	UpdateSecretRequest,
	UpdateTaskStatusRequest,
	UpdateUserRequest,
	UpdateVariableRequest,
	User,
	UserCredentialBrokeringResponse,
	UserCredentialSerialized,
	UserGroupWithGroupPaginatedResponse,
	UserPaginatedResponse,
	Variable,
} from "../models/index";
import {
	AddGroupMemberRequestToJSON,
	AddMcpServerInstanceFunctionRequestToJSON,
	ContextInfoPaginatedResponseFromJSON,
	CreateApiKeyParamsToJSON,
	CreateApiKeyResponseFromJSON,
	CreateDataEncryptionKeyParamsRouteToJSON,
	CreateDekAliasRequestToJSON,
	CreateGroupRequestToJSON,
	CreateMcpServerInstanceRequestToJSON,
	CreateMessageRequestToJSON,
	CreateMessageResponseFromJSON,
	CreateProviderInstanceParamsInnerToJSON,
	CreateResourceServerCredentialParamsInnerToJSON,
	CreateSecretRequestToJSON,
	CreateUserAuthFlowConfigParamsToJSON,
	CreateUserAuthFlowConfigResponseFromJSON,
	CreateUserCredentialParamsInnerToJSON,
	CreateUserRequestToJSON,
	CreateVariableRequestToJSON,
	DataEncryptionKeyAliasFromJSON,
	DataEncryptionKeyFromJSON,
	DataEncryptionKeyListItemPaginatedResponseFromJSON,
	DeleteSecretResponseFromJSON,
	DeleteVariableResponseFromJSON,
	EncryptCredentialConfigurationParamsInnerToJSON,
	EncryptedApiKeyConfigToJSON,
	EnvelopeEncryptionKeyFromJSON,
	EnvelopeEncryptionKeyPaginatedResponseFromJSON,
	EnvelopeEncryptionKeyToJSON,
	FunctionInstanceConfigPaginatedResponseFromJSON,
	FunctionInstanceSerializedFromJSON,
	FunctionInstanceSerializedPaginatedResponseFromJSON,
	GetUserAuthFlowConfigResponseFromJSON,
	GroupFromJSON,
	GroupMemberWithUserPaginatedResponseFromJSON,
	GroupPaginatedResponseFromJSON,
	IdentityFromJSON,
	ImportDataEncryptionKeyParamsRouteToJSON,
	ImportSecretRequestToJSON,
	ImportUserAuthFlowConfigParamsToJSON,
	ImportVariableRequestToJSON,
	InvokeFunctionParamsInnerToJSON,
	InvokeResultFromJSON,
	JwkResponsePaginatedResponseFromJSON,
	JwksResponseFromJSON,
	ListAgentsResponseFromJSON,
	ListApiKeysResponseFromJSON,
	ListDecryptedSecretsResponseFromJSON,
	ListSecretsResponseFromJSON,
	ListUserAuthFlowConfigResponseFromJSON,
	ListVariablesResponseFromJSON,
	McpServerInstanceSerializedWithFunctionsFromJSON,
	McpServerInstanceSerializedWithFunctionsPaginatedResponseFromJSON,
	MigrateAllDataEncryptionKeysParamsRouteToJSON,
	MigrateDataEncryptionKeyParamsRouteToJSON,
	NormalizedTokenIssuanceResultFromJSON,
	ProviderControllerSerializedPaginatedResponseFromJSON,
	ProviderInstanceListItemPaginatedResponseFromJSON,
	ProviderInstanceSerializedFromJSON,
	ProviderInstanceSerializedWithEverythingFromJSON,
	RefreshTokenRequestToJSON,
	ResourceServerCredentialSerializedFromJSON,
	ScimGroupFromJSON,
	ScimGroupToJSON,
	ScimListResponseFromJSON,
	ScimPatchRequestToJSON,
	ScimUserFromJSON,
	ScimUserToJSON,
	SecretFromJSON,
	StartUserCredentialBrokeringParamsInnerToJSON,
	StsTokenConfigFromJSON,
	StsTokenConfigPaginatedResponseFromJSON,
	StsTokenConfigToJSON,
	TaskPaginatedResponseFromJSON,
	TaskTimelineItemPaginatedResponseFromJSON,
	TaskWithDetailsFromJSON,
	TokenResponseFromJSON,
	UpdateAliasParamsToJSON,
	UpdateGroupRequestToJSON,
	UpdateMcpServerInstanceFunctionRequestToJSON,
	UpdateMcpServerInstanceRequestToJSON,
	UpdateProviderInstanceParamsInnerToJSON,
	UpdateSecretRequestToJSON,
	UpdateTaskStatusRequestToJSON,
	UpdateUserRequestToJSON,
	UpdateVariableRequestToJSON,
	UserCredentialBrokeringResponseFromJSON,
	UserCredentialSerializedFromJSON,
	UserFromJSON,
	UserGroupWithGroupPaginatedResponseFromJSON,
	UserPaginatedResponseFromJSON,
	VariableFromJSON,
} from "../models/index";
import * as runtime from "../runtime";

export interface V1ApiAddGroupMemberOperationRequest {
	groupId: string;
	addGroupMemberRequest: AddGroupMemberRequest;
}

export interface V1ApiAddMcpServerInstanceFunctionOperationRequest {
	mcpServerInstanceId: string;
	addMcpServerInstanceFunctionRequest: AddMcpServerInstanceFunctionRequest;
}

export interface V1ApiCreateDataEncryptionKeyRequest {
	envelopeId: string;
	createDataEncryptionKeyParamsRoute: CreateDataEncryptionKeyParamsRoute;
}

export interface V1ApiCreateDekAliasOperationRequest {
	createDekAliasRequest: CreateDekAliasRequest;
}

export interface V1ApiCreateEnvelopeEncryptionKeyRequest {
	envelopeEncryptionKey: EnvelopeEncryptionKey;
}

export interface V1ApiCreateGroupOperationRequest {
	createGroupRequest: CreateGroupRequest;
}

export interface V1ApiCreateMcpServerInstanceOperationRequest {
	createMcpServerInstanceRequest: CreateMcpServerInstanceRequest;
}

export interface V1ApiCreateProviderInstanceRequest {
	providerControllerTypeId: string;
	credentialControllerTypeId: string;
	createProviderInstanceParamsInner: CreateProviderInstanceParamsInner;
}

export interface V1ApiCreateResourceServerCredentialRequest {
	providerControllerTypeId: string;
	credentialControllerTypeId: string;
	createResourceServerCredentialParamsInner: CreateResourceServerCredentialParamsInner;
}

export interface V1ApiCreateSecretOperationRequest {
	createSecretRequest: CreateSecretRequest;
}

export interface V1ApiCreateUserOperationRequest {
	createUserRequest: CreateUserRequest;
}

export interface V1ApiCreateUserCredentialRequest {
	providerControllerTypeId: string;
	credentialControllerTypeId: string;
	createUserCredentialParamsInner: CreateUserCredentialParamsInner;
}

export interface V1ApiCreateVariableOperationRequest {
	createVariableRequest: CreateVariableRequest;
}

export interface V1ApiDeleteDekAliasRequest {
	alias: string;
}

export interface V1ApiDeleteGroupRequest {
	groupId: string;
}

export interface V1ApiDeleteMcpServerInstanceRequest {
	mcpServerInstanceId: string;
}

export interface V1ApiDeleteProviderInstanceRequest {
	providerInstanceId: string;
}

export interface V1ApiDeleteSecretRequest {
	secretId: string;
}

export interface V1ApiDeleteUserRequest {
	userId: string;
}

export interface V1ApiDeleteVariableRequest {
	variableId: string;
}

export interface V1ApiDisableFunctionRequest {
	providerInstanceId: string;
	functionControllerTypeId: string;
}

export interface V1ApiEnableFunctionRequest {
	providerInstanceId: string;
	functionControllerTypeId: string;
	body: object;
}

export interface V1ApiEncryptResourceServerConfigurationRequest {
	providerControllerTypeId: string;
	credentialControllerTypeId: string;
	encryptCredentialConfigurationParamsInner: EncryptCredentialConfigurationParamsInner;
}

export interface V1ApiEncryptUserCredentialConfigurationRequest {
	providerControllerTypeId: string;
	credentialControllerTypeId: string;
	encryptCredentialConfigurationParamsInner: EncryptCredentialConfigurationParamsInner;
}

export interface V1ApiGetAgentCardRequest {
	projectId: string;
	agentId: string;
}

export interface V1ApiGetDekByAliasOrIdRequest {
	alias: string;
}

export interface V1ApiGetGroupRequest {
	groupId: string;
}

export interface V1ApiGetMcpServerInstanceRequest {
	mcpServerInstanceId: string;
}

export interface V1ApiGetProviderInstanceRequest {
	providerInstanceId: string;
}

export interface V1ApiGetSecretByIdRequest {
	secretId: string;
}

export interface V1ApiGetSecretByKeyRequest {
	key: string;
}

export interface V1ApiGetTaskByIdRequest {
	taskId: string;
}

export interface V1ApiGetUserRequest {
	userId: string;
}

export interface V1ApiGetVariableByIdRequest {
	variableId: string;
}

export interface V1ApiGetVariableByKeyRequest {
	key: string;
}

export interface V1ApiHandleA2aJsonrpcRequestRequest {
	projectId: string;
	agentId: string;
	body: object;
}

export interface V1ApiImportDataEncryptionKeyRequest {
	envelopeId: string;
	importDataEncryptionKeyParamsRoute: ImportDataEncryptionKeyParamsRoute;
}

export interface V1ApiImportSecretOperationRequest {
	importSecretRequest: ImportSecretRequest;
}

export interface V1ApiImportVariableOperationRequest {
	importVariableRequest: ImportVariableRequest;
}

export interface V1ApiInvokeFunctionRequest {
	providerInstanceId: string;
	functionControllerTypeId: string;
	invokeFunctionParamsInner: InvokeFunctionParamsInner;
}

export interface V1ApiListAvailableProvidersRequest {
	pageSize: number;
	nextPageToken?: string;
}

export interface V1ApiListContextsRequest {
	pageSize: number;
	nextPageToken?: string;
}

export interface V1ApiListDataEncryptionKeysByEnvelopeRequest {
	envelopeId: string;
	pageSize: number;
	nextPageToken?: string;
}

export interface V1ApiListDecryptedSecretsRequest {
	pageSize: number;
	nextPageToken?: string;
}

export interface V1ApiListEnvelopeEncryptionKeysRequest {
	pageSize: number;
	nextPageToken?: string;
}

export interface V1ApiListFunctionInstancesRequest {
	pageSize: number;
	nextPageToken?: string;
	providerInstanceId?: string;
}

export interface V1ApiListGroupMembersRequest {
	groupId: string;
	pageSize: number;
	nextPageToken?: string;
}

export interface V1ApiListGroupsRequest {
	pageSize: number;
	nextPageToken?: string;
}

export interface V1ApiListMcpServerInstancesRequest {
	pageSize: number;
	nextPageToken?: string;
}

export interface V1ApiListProviderInstancesRequest {
	pageSize: number;
	nextPageToken?: string;
	status?: string;
	providerControllerTypeId?: string;
}

export interface V1ApiListProviderInstancesGroupedByFunctionRequest {
	pageSize: number;
	nextPageToken?: string | null;
	providerControllerTypeId?: string | null;
	functionCategory?: string | null;
}

export interface V1ApiListSecretsRequest {
	pageSize: number;
	nextPageToken?: string;
}

export interface V1ApiListTasksRequest {
	pageSize: number;
	nextPageToken?: string;
}

export interface V1ApiListTasksByContextIdRequest {
	pageSize: number;
	contextId: string;
	nextPageToken?: string;
}

export interface V1ApiListUserGroupsRequest {
	userId: string;
	pageSize: number;
	nextPageToken?: string;
}

export interface V1ApiListUsersRequest {
	pageSize: number;
	nextPageToken?: string;
	userType?: string;
	role?: string;
}

export interface V1ApiListVariablesRequest {
	pageSize: number;
	nextPageToken?: string;
}

export interface V1ApiMigrateAllDataEncryptionKeysRequest {
	envelopeId: string;
	migrateAllDataEncryptionKeysParamsRoute: MigrateAllDataEncryptionKeysParamsRoute;
}

export interface V1ApiMigrateDataEncryptionKeyRequest {
	envelopeId: string;
	dekId: string;
	migrateDataEncryptionKeyParamsRoute: MigrateDataEncryptionKeyParamsRoute;
}

export interface V1ApiRemoveGroupMemberRequest {
	groupId: string;
	userId: string;
}

export interface V1ApiRemoveMcpServerInstanceFunctionRequest {
	mcpServerInstanceId: string;
	functionControllerTypeId: string;
	providerControllerTypeId: string;
	providerInstanceId: string;
}

export interface V1ApiResumeUserCredentialBrokeringRequest {
	state?: string;
	code?: string;
	error?: string;
	errorDescription?: string;
}

export interface V1ApiRouteAuthCallbackRequest {
	code?: string | null;
	state?: string | null;
	error?: string | null;
	errorDescription?: string | null;
}

export interface V1ApiRouteCreateApiKeyRequest {
	createApiKeyParams: CreateApiKeyParams;
}

export interface V1ApiRouteCreateStsConfigRequest {
	stsTokenConfig: StsTokenConfig;
}

export interface V1ApiRouteCreateUserAuthFlowConfigRequest {
	createUserAuthFlowConfigParams: CreateUserAuthFlowConfigParams;
}

export interface V1ApiRouteDeleteApiKeyRequest {
	id: string;
}

export interface V1ApiRouteDeleteStsConfigRequest {
	id: string;
}

export interface V1ApiRouteDeleteUserAuthFlowConfigRequest {
	id: string;
}

export interface V1ApiRouteExchangeStsTokenRequest {
	stsConfigId: string;
}

export interface V1ApiRouteGetStsConfigRequest {
	id: string;
}

export interface V1ApiRouteGetUserAuthFlowConfigRequest {
	id: string;
}

export interface V1ApiRouteImportApiKeyRequest {
	encryptedApiKeyConfig: EncryptedApiKeyConfig;
}

export interface V1ApiRouteImportUserAuthFlowConfigRequest {
	importUserAuthFlowConfigParams: ImportUserAuthFlowConfigParams;
}

export interface V1ApiRouteInvalidateJwkRequest {
	kid: string;
}

export interface V1ApiRouteListApiKeysRequest {
	pageSize: number;
	nextPageToken?: string;
}

export interface V1ApiRouteListJwksRequest {
	pageSize: number;
	nextPageToken?: string;
}

export interface V1ApiRouteListStsConfigsRequest {
	pageSize: number;
	nextPageToken?: string;
}

export interface V1ApiRouteListUserAuthFlowConfigsRequest {
	pageSize?: number | null;
	nextPageToken?: string | null;
	type?: string | null;
}

export interface V1ApiRouteRefreshTokenRequest {
	refreshTokenRequest?: RefreshTokenRequest;
}

export interface V1ApiRouteStartAuthorizationRequest {
	configId: string;
	redirectAfterLogin?: string | null;
}

export interface V1ApiScimCreateGroupRequest {
	scimGroup: ScimGroup;
}

export interface V1ApiScimCreateUserRequest {
	scimUser: ScimUser;
}

export interface V1ApiScimDeleteGroupRequest {
	groupId: string;
}

export interface V1ApiScimDeleteUserRequest {
	userId: string;
}

export interface V1ApiScimGetGroupRequest {
	groupId: string;
}

export interface V1ApiScimGetUserRequest {
	userId: string;
}

export interface V1ApiScimListGroupsRequest {
	filter?: string;
	sortBy?: string;
	sortOrder?: string;
	startIndex?: number;
	count?: number;
}

export interface V1ApiScimListUsersRequest {
	filter?: string;
	sortBy?: string;
	sortOrder?: string;
	startIndex?: number;
	count?: number;
}

export interface V1ApiScimPatchGroupRequest {
	groupId: string;
	scimPatchRequest: ScimPatchRequest;
}

export interface V1ApiScimPatchUserRequest {
	userId: string;
	scimPatchRequest: ScimPatchRequest;
}

export interface V1ApiScimReplaceGroupRequest {
	groupId: string;
	scimGroup: ScimGroup;
}

export interface V1ApiScimReplaceUserRequest {
	userId: string;
	scimUser: ScimUser;
}

export interface V1ApiSendMessageRequest {
	taskId: string;
	createMessageRequest: CreateMessageRequest;
}

export interface V1ApiStartUserCredentialBrokeringRequest {
	providerControllerTypeId: string;
	credentialControllerTypeId: string;
	startUserCredentialBrokeringParamsInner: StartUserCredentialBrokeringParamsInner;
}

export interface V1ApiTaskHistoryRequest {
	pageSize: number;
	taskId: string;
	nextPageToken?: string;
}

export interface V1ApiUpdateDekAliasRequest {
	alias: string;
	updateAliasParams: UpdateAliasParams;
}

export interface V1ApiUpdateGroupOperationRequest {
	groupId: string;
	updateGroupRequest: UpdateGroupRequest;
}

export interface V1ApiUpdateMcpServerInstanceOperationRequest {
	mcpServerInstanceId: string;
	updateMcpServerInstanceRequest: UpdateMcpServerInstanceRequest;
}

export interface V1ApiUpdateMcpServerInstanceFunctionOperationRequest {
	mcpServerInstanceId: string;
	functionControllerTypeId: string;
	providerControllerTypeId: string;
	providerInstanceId: string;
	updateMcpServerInstanceFunctionRequest: UpdateMcpServerInstanceFunctionRequest;
}

export interface V1ApiUpdateProviderInstanceRequest {
	providerInstanceId: string;
	updateProviderInstanceParamsInner: UpdateProviderInstanceParamsInner;
}

export interface V1ApiUpdateSecretOperationRequest {
	secretId: string;
	updateSecretRequest: UpdateSecretRequest;
}

export interface V1ApiUpdateTaskStatusOperationRequest {
	taskId: string;
	updateTaskStatusRequest: UpdateTaskStatusRequest;
}

export interface V1ApiUpdateUserOperationRequest {
	userId: string;
	updateUserRequest: UpdateUserRequest;
}

export interface V1ApiUpdateVariableOperationRequest {
	variableId: string;
	updateVariableRequest: UpdateVariableRequest;
}

/**
 *
 */
export class V1Api extends runtime.BaseAPI {
	/**
	 * Add a user to a group
	 * Add group member
	 */
	async addGroupMemberRaw(
		requestParameters: V1ApiAddGroupMemberOperationRequest,
		initOverrides?: RequestInit | runtime.InitOverrideFunction,
	): Promise<runtime.ApiResponse<void>> {
		if (requestParameters.groupId == null) {
			throw new runtime.RequiredError(
				"groupId",
				'Required parameter "groupId" was null or undefined when calling addGroupMember().',
			);
		}

		if (requestParameters.addGroupMemberRequest == null) {
			throw new runtime.RequiredError(
				"addGroupMemberRequest",
				'Required parameter "addGroupMemberRequest" was null or undefined when calling addGroupMember().',
			);
		}

		const queryParameters: any = {};

		const headerParameters: runtime.HTTPHeaders = {};

		headerParameters["Content-Type"] = "application/json";

		if (this.configuration?.accessToken) {
			const token = this.configuration.accessToken;
			const tokenString = await token("bearer_token", []);

			if (tokenString) {
				headerParameters.Authorization = `Bearer ${tokenString}`;
			}
		}
		if (this.configuration?.apiKey) {
			headerParameters["X-API-Key"] =
				await this.configuration.apiKey("X-API-Key"); // api_key authentication
		}

		let urlPath = `/api/identity/v1/groups/{group_id}/members`;
		urlPath = urlPath.replace(
			`{${"group_id"}}`,
			encodeURIComponent(String(requestParameters.groupId)),
		);

		const response = await this.request(
			{
				path: urlPath,
				method: "POST",
				headers: headerParameters,
				query: queryParameters,
				body: AddGroupMemberRequestToJSON(
					requestParameters.addGroupMemberRequest,
				),
			},
			initOverrides,
		);

		return new runtime.VoidApiResponse(response);
	}

	/**
	 * Add a user to a group
	 * Add group member
	 */
	async addGroupMember(
		requestParameters: V1ApiAddGroupMemberOperationRequest,
		initOverrides?: RequestInit | runtime.InitOverrideFunction,
	): Promise<void> {
		await this.addGroupMemberRaw(requestParameters, initOverrides);
	}

	/**
	 * Add a function mapping to an MCP server instance with a custom name
	 * Add function to MCP server instance
	 */
	async addMcpServerInstanceFunctionRaw(
		requestParameters: V1ApiAddMcpServerInstanceFunctionOperationRequest,
		initOverrides?: RequestInit | runtime.InitOverrideFunction,
	): Promise<runtime.ApiResponse<McpServerInstanceSerializedWithFunctions>> {
		if (requestParameters.mcpServerInstanceId == null) {
			throw new runtime.RequiredError(
				"mcpServerInstanceId",
				'Required parameter "mcpServerInstanceId" was null or undefined when calling addMcpServerInstanceFunction().',
			);
		}

		if (requestParameters.addMcpServerInstanceFunctionRequest == null) {
			throw new runtime.RequiredError(
				"addMcpServerInstanceFunctionRequest",
				'Required parameter "addMcpServerInstanceFunctionRequest" was null or undefined when calling addMcpServerInstanceFunction().',
			);
		}

		const queryParameters: any = {};

		const headerParameters: runtime.HTTPHeaders = {};

		headerParameters["Content-Type"] = "application/json";

		if (this.configuration?.accessToken) {
			const token = this.configuration.accessToken;
			const tokenString = await token("bearer_token", []);

			if (tokenString) {
				headerParameters.Authorization = `Bearer ${tokenString}`;
			}
		}
		if (this.configuration?.apiKey) {
			headerParameters["X-API-Key"] =
				await this.configuration.apiKey("X-API-Key"); // api_key authentication
		}

		let urlPath = `/api/mcp/v1/mcp-server/{mcp_server_instance_id}/function`;
		urlPath = urlPath.replace(
			`{${"mcp_server_instance_id"}}`,
			encodeURIComponent(String(requestParameters.mcpServerInstanceId)),
		);

		const response = await this.request(
			{
				path: urlPath,
				method: "POST",
				headers: headerParameters,
				query: queryParameters,
				body: AddMcpServerInstanceFunctionRequestToJSON(
					requestParameters.addMcpServerInstanceFunctionRequest,
				),
			},
			initOverrides,
		);

		return new runtime.JSONApiResponse(response, (jsonValue) =>
			McpServerInstanceSerializedWithFunctionsFromJSON(jsonValue),
		);
	}

	/**
	 * Add a function mapping to an MCP server instance with a custom name
	 * Add function to MCP server instance
	 */
	async addMcpServerInstanceFunction(
		requestParameters: V1ApiAddMcpServerInstanceFunctionOperationRequest,
		initOverrides?: RequestInit | runtime.InitOverrideFunction,
	): Promise<McpServerInstanceSerializedWithFunctions> {
		const response = await this.addMcpServerInstanceFunctionRaw(
			requestParameters,
			initOverrides,
		);
		return await response.value();
	}

	/**
	 * Create a new data encryption key (DEK) encrypted with the specified envelope encryption key
	 * Create data key
	 */
	async createDataEncryptionKeyRaw(
		requestParameters: V1ApiCreateDataEncryptionKeyRequest,
		initOverrides?: RequestInit | runtime.InitOverrideFunction,
	): Promise<runtime.ApiResponse<DataEncryptionKey>> {
		if (requestParameters.envelopeId == null) {
			throw new runtime.RequiredError(
				"envelopeId",
				'Required parameter "envelopeId" was null or undefined when calling createDataEncryptionKey().',
			);
		}

		if (requestParameters.createDataEncryptionKeyParamsRoute == null) {
			throw new runtime.RequiredError(
				"createDataEncryptionKeyParamsRoute",
				'Required parameter "createDataEncryptionKeyParamsRoute" was null or undefined when calling createDataEncryptionKey().',
			);
		}

		const queryParameters: any = {};

		const headerParameters: runtime.HTTPHeaders = {};

		headerParameters["Content-Type"] = "application/json";

		if (this.configuration?.accessToken) {
			const token = this.configuration.accessToken;
			const tokenString = await token("bearer_token", []);

			if (tokenString) {
				headerParameters.Authorization = `Bearer ${tokenString}`;
			}
		}
		if (this.configuration?.apiKey) {
			headerParameters["X-API-Key"] =
				await this.configuration.apiKey("X-API-Key"); // api_key authentication
		}

		let urlPath = `/api/encryption/v1/envelope/{envelope_id}/dek`;
		urlPath = urlPath.replace(
			`{${"envelope_id"}}`,
			encodeURIComponent(String(requestParameters.envelopeId)),
		);

		const response = await this.request(
			{
				path: urlPath,
				method: "POST",
				headers: headerParameters,
				query: queryParameters,
				body: CreateDataEncryptionKeyParamsRouteToJSON(
					requestParameters.createDataEncryptionKeyParamsRoute,
				),
			},
			initOverrides,
		);

		return new runtime.JSONApiResponse(response, (jsonValue) =>
			DataEncryptionKeyFromJSON(jsonValue),
		);
	}

	/**
	 * Create a new data encryption key (DEK) encrypted with the specified envelope encryption key
	 * Create data key
	 */
	async createDataEncryptionKey(
		requestParameters: V1ApiCreateDataEncryptionKeyRequest,
		initOverrides?: RequestInit | runtime.InitOverrideFunction,
	): Promise<DataEncryptionKey> {
		const response = await this.createDataEncryptionKeyRaw(
			requestParameters,
			initOverrides,
		);
		return await response.value();
	}

	/**
	 * Create an alias for a data encryption key to enable lookup by friendly name
	 * Create DEK alias
	 */
	async createDekAliasRaw(
		requestParameters: V1ApiCreateDekAliasOperationRequest,
		initOverrides?: RequestInit | runtime.InitOverrideFunction,
	): Promise<runtime.ApiResponse<DataEncryptionKeyAlias>> {
		if (requestParameters.createDekAliasRequest == null) {
			throw new runtime.RequiredError(
				"createDekAliasRequest",
				'Required parameter "createDekAliasRequest" was null or undefined when calling createDekAlias().',
			);
		}

		const queryParameters: any = {};

		const headerParameters: runtime.HTTPHeaders = {};

		headerParameters["Content-Type"] = "application/json";

		if (this.configuration?.accessToken) {
			const token = this.configuration.accessToken;
			const tokenString = await token("bearer_token", []);

			if (tokenString) {
				headerParameters.Authorization = `Bearer ${tokenString}`;
			}
		}
		if (this.configuration?.apiKey) {
			headerParameters["X-API-Key"] =
				await this.configuration.apiKey("X-API-Key"); // api_key authentication
		}

		const urlPath = `/api/encryption/v1/dek/alias`;

		const response = await this.request(
			{
				path: urlPath,
				method: "POST",
				headers: headerParameters,
				query: queryParameters,
				body: CreateDekAliasRequestToJSON(
					requestParameters.createDekAliasRequest,
				),
			},
			initOverrides,
		);

		return new runtime.JSONApiResponse(response, (jsonValue) =>
			DataEncryptionKeyAliasFromJSON(jsonValue),
		);
	}

	/**
	 * Create an alias for a data encryption key to enable lookup by friendly name
	 * Create DEK alias
	 */
	async createDekAlias(
		requestParameters: V1ApiCreateDekAliasOperationRequest,
		initOverrides?: RequestInit | runtime.InitOverrideFunction,
	): Promise<DataEncryptionKeyAlias> {
		const response = await this.createDekAliasRaw(
			requestParameters,
			initOverrides,
		);
		return await response.value();
	}

	/**
	 * Create a new envelope encryption key (master key) for encrypting data encryption keys
	 * Create envelope key
	 */
	async createEnvelopeEncryptionKeyRaw(
		requestParameters: V1ApiCreateEnvelopeEncryptionKeyRequest,
		initOverrides?: RequestInit | runtime.InitOverrideFunction,
	): Promise<runtime.ApiResponse<EnvelopeEncryptionKey>> {
		if (requestParameters.envelopeEncryptionKey == null) {
			throw new runtime.RequiredError(
				"envelopeEncryptionKey",
				'Required parameter "envelopeEncryptionKey" was null or undefined when calling createEnvelopeEncryptionKey().',
			);
		}

		const queryParameters: any = {};

		const headerParameters: runtime.HTTPHeaders = {};

		headerParameters["Content-Type"] = "application/json";

		if (this.configuration?.accessToken) {
			const token = this.configuration.accessToken;
			const tokenString = await token("bearer_token", []);

			if (tokenString) {
				headerParameters.Authorization = `Bearer ${tokenString}`;
			}
		}
		if (this.configuration?.apiKey) {
			headerParameters["X-API-Key"] =
				await this.configuration.apiKey("X-API-Key"); // api_key authentication
		}

		const urlPath = `/api/encryption/v1/envelope`;

		const response = await this.request(
			{
				path: urlPath,
				method: "POST",
				headers: headerParameters,
				query: queryParameters,
				body: EnvelopeEncryptionKeyToJSON(
					requestParameters.envelopeEncryptionKey,
				),
			},
			initOverrides,
		);

		return new runtime.JSONApiResponse(response, (jsonValue) =>
			EnvelopeEncryptionKeyFromJSON(jsonValue),
		);
	}

	/**
	 * Create a new envelope encryption key (master key) for encrypting data encryption keys
	 * Create envelope key
	 */
	async createEnvelopeEncryptionKey(
		requestParameters: V1ApiCreateEnvelopeEncryptionKeyRequest,
		initOverrides?: RequestInit | runtime.InitOverrideFunction,
	): Promise<EnvelopeEncryptionKey> {
		const response = await this.createEnvelopeEncryptionKeyRaw(
			requestParameters,
			initOverrides,
		);
		return await response.value();
	}

	/**
	 * Create a new group with the specified name
	 * Create group
	 */
	async createGroupRaw(
		requestParameters: V1ApiCreateGroupOperationRequest,
		initOverrides?: RequestInit | runtime.InitOverrideFunction,
	): Promise<runtime.ApiResponse<Group>> {
		if (requestParameters.createGroupRequest == null) {
			throw new runtime.RequiredError(
				"createGroupRequest",
				'Required parameter "createGroupRequest" was null or undefined when calling createGroup().',
			);
		}

		const queryParameters: any = {};

		const headerParameters: runtime.HTTPHeaders = {};

		headerParameters["Content-Type"] = "application/json";

		if (this.configuration?.accessToken) {
			const token = this.configuration.accessToken;
			const tokenString = await token("bearer_token", []);

			if (tokenString) {
				headerParameters.Authorization = `Bearer ${tokenString}`;
			}
		}
		if (this.configuration?.apiKey) {
			headerParameters["X-API-Key"] =
				await this.configuration.apiKey("X-API-Key"); // api_key authentication
		}

		const urlPath = `/api/identity/v1/groups`;

		const response = await this.request(
			{
				path: urlPath,
				method: "POST",
				headers: headerParameters,
				query: queryParameters,
				body: CreateGroupRequestToJSON(requestParameters.createGroupRequest),
			},
			initOverrides,
		);

		return new runtime.JSONApiResponse(response, (jsonValue) =>
			GroupFromJSON(jsonValue),
		);
	}

	/**
	 * Create a new group with the specified name
	 * Create group
	 */
	async createGroup(
		requestParameters: V1ApiCreateGroupOperationRequest,
		initOverrides?: RequestInit | runtime.InitOverrideFunction,
	): Promise<Group> {
		const response = await this.createGroupRaw(
			requestParameters,
			initOverrides,
		);
		return await response.value();
	}

	/**
	 * Create a new MCP server instance with a user-provided ID
	 * Create MCP server instance
	 */
	async createMcpServerInstanceRaw(
		requestParameters: V1ApiCreateMcpServerInstanceOperationRequest,
		initOverrides?: RequestInit | runtime.InitOverrideFunction,
	): Promise<runtime.ApiResponse<McpServerInstanceSerializedWithFunctions>> {
		if (requestParameters.createMcpServerInstanceRequest == null) {
			throw new runtime.RequiredError(
				"createMcpServerInstanceRequest",
				'Required parameter "createMcpServerInstanceRequest" was null or undefined when calling createMcpServerInstance().',
			);
		}

		const queryParameters: any = {};

		const headerParameters: runtime.HTTPHeaders = {};

		headerParameters["Content-Type"] = "application/json";

		if (this.configuration?.accessToken) {
			const token = this.configuration.accessToken;
			const tokenString = await token("bearer_token", []);

			if (tokenString) {
				headerParameters.Authorization = `Bearer ${tokenString}`;
			}
		}
		if (this.configuration?.apiKey) {
			headerParameters["X-API-Key"] =
				await this.configuration.apiKey("X-API-Key"); // api_key authentication
		}

		const urlPath = `/api/mcp/v1/mcp-server`;

		const response = await this.request(
			{
				path: urlPath,
				method: "POST",
				headers: headerParameters,
				query: queryParameters,
				body: CreateMcpServerInstanceRequestToJSON(
					requestParameters.createMcpServerInstanceRequest,
				),
			},
			initOverrides,
		);

		return new runtime.JSONApiResponse(response, (jsonValue) =>
			McpServerInstanceSerializedWithFunctionsFromJSON(jsonValue),
		);
	}

	/**
	 * Create a new MCP server instance with a user-provided ID
	 * Create MCP server instance
	 */
	async createMcpServerInstance(
		requestParameters: V1ApiCreateMcpServerInstanceOperationRequest,
		initOverrides?: RequestInit | runtime.InitOverrideFunction,
	): Promise<McpServerInstanceSerializedWithFunctions> {
		const response = await this.createMcpServerInstanceRaw(
			requestParameters,
			initOverrides,
		);
		return await response.value();
	}

	/**
	 * Create a new provider instance with the specified configuration
	 * Create provider
	 */
	async createProviderInstanceRaw(
		requestParameters: V1ApiCreateProviderInstanceRequest,
		initOverrides?: RequestInit | runtime.InitOverrideFunction,
	): Promise<runtime.ApiResponse<ProviderInstanceSerialized>> {
		if (requestParameters.providerControllerTypeId == null) {
			throw new runtime.RequiredError(
				"providerControllerTypeId",
				'Required parameter "providerControllerTypeId" was null or undefined when calling createProviderInstance().',
			);
		}

		if (requestParameters.credentialControllerTypeId == null) {
			throw new runtime.RequiredError(
				"credentialControllerTypeId",
				'Required parameter "credentialControllerTypeId" was null or undefined when calling createProviderInstance().',
			);
		}

		if (requestParameters.createProviderInstanceParamsInner == null) {
			throw new runtime.RequiredError(
				"createProviderInstanceParamsInner",
				'Required parameter "createProviderInstanceParamsInner" was null or undefined when calling createProviderInstance().',
			);
		}

		const queryParameters: any = {};

		const headerParameters: runtime.HTTPHeaders = {};

		headerParameters["Content-Type"] = "application/json";

		if (this.configuration?.accessToken) {
			const token = this.configuration.accessToken;
			const tokenString = await token("bearer_token", []);

			if (tokenString) {
				headerParameters.Authorization = `Bearer ${tokenString}`;
			}
		}
		if (this.configuration?.apiKey) {
			headerParameters["X-API-Key"] =
				await this.configuration.apiKey("X-API-Key"); // api_key authentication
		}

		let urlPath = `/api/mcp/v1/available-providers/{provider_controller_type_id}/available-credentials/{credential_controller_type_id}`;
		urlPath = urlPath.replace(
			`{${"provider_controller_type_id"}}`,
			encodeURIComponent(String(requestParameters.providerControllerTypeId)),
		);
		urlPath = urlPath.replace(
			`{${"credential_controller_type_id"}}`,
			encodeURIComponent(String(requestParameters.credentialControllerTypeId)),
		);

		const response = await this.request(
			{
				path: urlPath,
				method: "POST",
				headers: headerParameters,
				query: queryParameters,
				body: CreateProviderInstanceParamsInnerToJSON(
					requestParameters.createProviderInstanceParamsInner,
				),
			},
			initOverrides,
		);

		return new runtime.JSONApiResponse(response, (jsonValue) =>
			ProviderInstanceSerializedFromJSON(jsonValue),
		);
	}

	/**
	 * Create a new provider instance with the specified configuration
	 * Create provider
	 */
	async createProviderInstance(
		requestParameters: V1ApiCreateProviderInstanceRequest,
		initOverrides?: RequestInit | runtime.InitOverrideFunction,
	): Promise<ProviderInstanceSerialized> {
		const response = await this.createProviderInstanceRaw(
			requestParameters,
			initOverrides,
		);
		return await response.value();
	}

	/**
	 * Create a new resource server credential
	 * Create resource server credential
	 */
	async createResourceServerCredentialRaw(
		requestParameters: V1ApiCreateResourceServerCredentialRequest,
		initOverrides?: RequestInit | runtime.InitOverrideFunction,
	): Promise<runtime.ApiResponse<ResourceServerCredentialSerialized>> {
		if (requestParameters.providerControllerTypeId == null) {
			throw new runtime.RequiredError(
				"providerControllerTypeId",
				'Required parameter "providerControllerTypeId" was null or undefined when calling createResourceServerCredential().',
			);
		}

		if (requestParameters.credentialControllerTypeId == null) {
			throw new runtime.RequiredError(
				"credentialControllerTypeId",
				'Required parameter "credentialControllerTypeId" was null or undefined when calling createResourceServerCredential().',
			);
		}

		if (requestParameters.createResourceServerCredentialParamsInner == null) {
			throw new runtime.RequiredError(
				"createResourceServerCredentialParamsInner",
				'Required parameter "createResourceServerCredentialParamsInner" was null or undefined when calling createResourceServerCredential().',
			);
		}

		const queryParameters: any = {};

		const headerParameters: runtime.HTTPHeaders = {};

		headerParameters["Content-Type"] = "application/json";

		if (this.configuration?.accessToken) {
			const token = this.configuration.accessToken;
			const tokenString = await token("bearer_token", []);

			if (tokenString) {
				headerParameters.Authorization = `Bearer ${tokenString}`;
			}
		}
		if (this.configuration?.apiKey) {
			headerParameters["X-API-Key"] =
				await this.configuration.apiKey("X-API-Key"); // api_key authentication
		}

		let urlPath = `/api/mcp/v1/available-providers/{provider_controller_type_id}/available-credentials/{credential_controller_type_id}/credential/resource-server`;
		urlPath = urlPath.replace(
			`{${"provider_controller_type_id"}}`,
			encodeURIComponent(String(requestParameters.providerControllerTypeId)),
		);
		urlPath = urlPath.replace(
			`{${"credential_controller_type_id"}}`,
			encodeURIComponent(String(requestParameters.credentialControllerTypeId)),
		);

		const response = await this.request(
			{
				path: urlPath,
				method: "POST",
				headers: headerParameters,
				query: queryParameters,
				body: CreateResourceServerCredentialParamsInnerToJSON(
					requestParameters.createResourceServerCredentialParamsInner,
				),
			},
			initOverrides,
		);

		return new runtime.JSONApiResponse(response, (jsonValue) =>
			ResourceServerCredentialSerializedFromJSON(jsonValue),
		);
	}

	/**
	 * Create a new resource server credential
	 * Create resource server credential
	 */
	async createResourceServerCredential(
		requestParameters: V1ApiCreateResourceServerCredentialRequest,
		initOverrides?: RequestInit | runtime.InitOverrideFunction,
	): Promise<ResourceServerCredentialSerialized> {
		const response = await this.createResourceServerCredentialRaw(
			requestParameters,
			initOverrides,
		);
		return await response.value();
	}

	/**
	 * Create a new encrypted secret with the specified key and value
	 * Create secret
	 */
	async createSecretRaw(
		requestParameters: V1ApiCreateSecretOperationRequest,
		initOverrides?: RequestInit | runtime.InitOverrideFunction,
	): Promise<runtime.ApiResponse<Secret>> {
		if (requestParameters.createSecretRequest == null) {
			throw new runtime.RequiredError(
				"createSecretRequest",
				'Required parameter "createSecretRequest" was null or undefined when calling createSecret().',
			);
		}

		const queryParameters: any = {};

		const headerParameters: runtime.HTTPHeaders = {};

		headerParameters["Content-Type"] = "application/json";

		if (this.configuration?.accessToken) {
			const token = this.configuration.accessToken;
			const tokenString = await token("bearer_token", []);

			if (tokenString) {
				headerParameters.Authorization = `Bearer ${tokenString}`;
			}
		}
		if (this.configuration?.apiKey) {
			headerParameters["X-API-Key"] =
				await this.configuration.apiKey("X-API-Key"); // api_key authentication
		}

		const urlPath = `/api/environment/v1/secret`;

		const response = await this.request(
			{
				path: urlPath,
				method: "POST",
				headers: headerParameters,
				query: queryParameters,
				body: CreateSecretRequestToJSON(requestParameters.createSecretRequest),
			},
			initOverrides,
		);

		return new runtime.JSONApiResponse(response, (jsonValue) =>
			SecretFromJSON(jsonValue),
		);
	}

	/**
	 * Create a new encrypted secret with the specified key and value
	 * Create secret
	 */
	async createSecret(
		requestParameters: V1ApiCreateSecretOperationRequest,
		initOverrides?: RequestInit | runtime.InitOverrideFunction,
	): Promise<Secret> {
		const response = await this.createSecretRaw(
			requestParameters,
			initOverrides,
		);
		return await response.value();
	}

	/**
	 * Create a new user with the specified attributes
	 * Create user
	 */
	async createUserRaw(
		requestParameters: V1ApiCreateUserOperationRequest,
		initOverrides?: RequestInit | runtime.InitOverrideFunction,
	): Promise<runtime.ApiResponse<User>> {
		if (requestParameters.createUserRequest == null) {
			throw new runtime.RequiredError(
				"createUserRequest",
				'Required parameter "createUserRequest" was null or undefined when calling createUser().',
			);
		}

		const queryParameters: any = {};

		const headerParameters: runtime.HTTPHeaders = {};

		headerParameters["Content-Type"] = "application/json";

		if (this.configuration?.accessToken) {
			const token = this.configuration.accessToken;
			const tokenString = await token("bearer_token", []);

			if (tokenString) {
				headerParameters.Authorization = `Bearer ${tokenString}`;
			}
		}
		if (this.configuration?.apiKey) {
			headerParameters["X-API-Key"] =
				await this.configuration.apiKey("X-API-Key"); // api_key authentication
		}

		const urlPath = `/api/identity/v1/users`;

		const response = await this.request(
			{
				path: urlPath,
				method: "POST",
				headers: headerParameters,
				query: queryParameters,
				body: CreateUserRequestToJSON(requestParameters.createUserRequest),
			},
			initOverrides,
		);

		return new runtime.JSONApiResponse(response, (jsonValue) =>
			UserFromJSON(jsonValue),
		);
	}

	/**
	 * Create a new user with the specified attributes
	 * Create user
	 */
	async createUser(
		requestParameters: V1ApiCreateUserOperationRequest,
		initOverrides?: RequestInit | runtime.InitOverrideFunction,
	): Promise<User> {
		const response = await this.createUserRaw(requestParameters, initOverrides);
		return await response.value();
	}

	/**
	 * Create a new user credential
	 * Create user credential
	 */
	async createUserCredentialRaw(
		requestParameters: V1ApiCreateUserCredentialRequest,
		initOverrides?: RequestInit | runtime.InitOverrideFunction,
	): Promise<runtime.ApiResponse<UserCredentialSerialized>> {
		if (requestParameters.providerControllerTypeId == null) {
			throw new runtime.RequiredError(
				"providerControllerTypeId",
				'Required parameter "providerControllerTypeId" was null or undefined when calling createUserCredential().',
			);
		}

		if (requestParameters.credentialControllerTypeId == null) {
			throw new runtime.RequiredError(
				"credentialControllerTypeId",
				'Required parameter "credentialControllerTypeId" was null or undefined when calling createUserCredential().',
			);
		}

		if (requestParameters.createUserCredentialParamsInner == null) {
			throw new runtime.RequiredError(
				"createUserCredentialParamsInner",
				'Required parameter "createUserCredentialParamsInner" was null or undefined when calling createUserCredential().',
			);
		}

		const queryParameters: any = {};

		const headerParameters: runtime.HTTPHeaders = {};

		headerParameters["Content-Type"] = "application/json";

		if (this.configuration?.accessToken) {
			const token = this.configuration.accessToken;
			const tokenString = await token("bearer_token", []);

			if (tokenString) {
				headerParameters.Authorization = `Bearer ${tokenString}`;
			}
		}
		if (this.configuration?.apiKey) {
			headerParameters["X-API-Key"] =
				await this.configuration.apiKey("X-API-Key"); // api_key authentication
		}

		let urlPath = `/api/mcp/v1/available-providers/{provider_controller_type_id}/available-credentials/{credential_controller_type_id}/credential/user-credential`;
		urlPath = urlPath.replace(
			`{${"provider_controller_type_id"}}`,
			encodeURIComponent(String(requestParameters.providerControllerTypeId)),
		);
		urlPath = urlPath.replace(
			`{${"credential_controller_type_id"}}`,
			encodeURIComponent(String(requestParameters.credentialControllerTypeId)),
		);

		const response = await this.request(
			{
				path: urlPath,
				method: "POST",
				headers: headerParameters,
				query: queryParameters,
				body: CreateUserCredentialParamsInnerToJSON(
					requestParameters.createUserCredentialParamsInner,
				),
			},
			initOverrides,
		);

		return new runtime.JSONApiResponse(response, (jsonValue) =>
			UserCredentialSerializedFromJSON(jsonValue),
		);
	}

	/**
	 * Create a new user credential
	 * Create user credential
	 */
	async createUserCredential(
		requestParameters: V1ApiCreateUserCredentialRequest,
		initOverrides?: RequestInit | runtime.InitOverrideFunction,
	): Promise<UserCredentialSerialized> {
		const response = await this.createUserCredentialRaw(
			requestParameters,
			initOverrides,
		);
		return await response.value();
	}

	/**
	 * Create a new environment variable with the specified key and value
	 * Create variable
	 */
	async createVariableRaw(
		requestParameters: V1ApiCreateVariableOperationRequest,
		initOverrides?: RequestInit | runtime.InitOverrideFunction,
	): Promise<runtime.ApiResponse<Variable>> {
		if (requestParameters.createVariableRequest == null) {
			throw new runtime.RequiredError(
				"createVariableRequest",
				'Required parameter "createVariableRequest" was null or undefined when calling createVariable().',
			);
		}

		const queryParameters: any = {};

		const headerParameters: runtime.HTTPHeaders = {};

		headerParameters["Content-Type"] = "application/json";

		if (this.configuration?.accessToken) {
			const token = this.configuration.accessToken;
			const tokenString = await token("bearer_token", []);

			if (tokenString) {
				headerParameters.Authorization = `Bearer ${tokenString}`;
			}
		}
		if (this.configuration?.apiKey) {
			headerParameters["X-API-Key"] =
				await this.configuration.apiKey("X-API-Key"); // api_key authentication
		}

		const urlPath = `/api/environment/v1/variable`;

		const response = await this.request(
			{
				path: urlPath,
				method: "POST",
				headers: headerParameters,
				query: queryParameters,
				body: CreateVariableRequestToJSON(
					requestParameters.createVariableRequest,
				),
			},
			initOverrides,
		);

		return new runtime.JSONApiResponse(response, (jsonValue) =>
			VariableFromJSON(jsonValue),
		);
	}

	/**
	 * Create a new environment variable with the specified key and value
	 * Create variable
	 */
	async createVariable(
		requestParameters: V1ApiCreateVariableOperationRequest,
		initOverrides?: RequestInit | runtime.InitOverrideFunction,
	): Promise<Variable> {
		const response = await this.createVariableRaw(
			requestParameters,
			initOverrides,
		);
		return await response.value();
	}

	/**
	 * Delete an alias for a data encryption key
	 * Delete DEK alias
	 */
	async deleteDekAliasRaw(
		requestParameters: V1ApiDeleteDekAliasRequest,
		initOverrides?: RequestInit | runtime.InitOverrideFunction,
	): Promise<runtime.ApiResponse<void>> {
		if (requestParameters.alias == null) {
			throw new runtime.RequiredError(
				"alias",
				'Required parameter "alias" was null or undefined when calling deleteDekAlias().',
			);
		}

		const queryParameters: any = {};

		const headerParameters: runtime.HTTPHeaders = {};

		if (this.configuration?.accessToken) {
			const token = this.configuration.accessToken;
			const tokenString = await token("bearer_token", []);

			if (tokenString) {
				headerParameters.Authorization = `Bearer ${tokenString}`;
			}
		}
		if (this.configuration?.apiKey) {
			headerParameters["X-API-Key"] =
				await this.configuration.apiKey("X-API-Key"); // api_key authentication
		}

		let urlPath = `/api/encryption/v1/dek/alias/{alias}`;
		urlPath = urlPath.replace(
			`{${"alias"}}`,
			encodeURIComponent(String(requestParameters.alias)),
		);

		const response = await this.request(
			{
				path: urlPath,
				method: "DELETE",
				headers: headerParameters,
				query: queryParameters,
			},
			initOverrides,
		);

		return new runtime.VoidApiResponse(response);
	}

	/**
	 * Delete an alias for a data encryption key
	 * Delete DEK alias
	 */
	async deleteDekAlias(
		requestParameters: V1ApiDeleteDekAliasRequest,
		initOverrides?: RequestInit | runtime.InitOverrideFunction,
	): Promise<void> {
		await this.deleteDekAliasRaw(requestParameters, initOverrides);
	}

	/**
	 * Delete a group by its unique identifier
	 * Delete group
	 */
	async deleteGroupRaw(
		requestParameters: V1ApiDeleteGroupRequest,
		initOverrides?: RequestInit | runtime.InitOverrideFunction,
	): Promise<runtime.ApiResponse<void>> {
		if (requestParameters.groupId == null) {
			throw new runtime.RequiredError(
				"groupId",
				'Required parameter "groupId" was null or undefined when calling deleteGroup().',
			);
		}

		const queryParameters: any = {};

		const headerParameters: runtime.HTTPHeaders = {};

		if (this.configuration?.accessToken) {
			const token = this.configuration.accessToken;
			const tokenString = await token("bearer_token", []);

			if (tokenString) {
				headerParameters.Authorization = `Bearer ${tokenString}`;
			}
		}
		if (this.configuration?.apiKey) {
			headerParameters["X-API-Key"] =
				await this.configuration.apiKey("X-API-Key"); // api_key authentication
		}

		let urlPath = `/api/identity/v1/groups/{group_id}`;
		urlPath = urlPath.replace(
			`{${"group_id"}}`,
			encodeURIComponent(String(requestParameters.groupId)),
		);

		const response = await this.request(
			{
				path: urlPath,
				method: "DELETE",
				headers: headerParameters,
				query: queryParameters,
			},
			initOverrides,
		);

		return new runtime.VoidApiResponse(response);
	}

	/**
	 * Delete a group by its unique identifier
	 * Delete group
	 */
	async deleteGroup(
		requestParameters: V1ApiDeleteGroupRequest,
		initOverrides?: RequestInit | runtime.InitOverrideFunction,
	): Promise<void> {
		await this.deleteGroupRaw(requestParameters, initOverrides);
	}

	/**
	 * Delete an MCP server instance and all its function mappings
	 * Delete MCP server instance
	 */
	async deleteMcpServerInstanceRaw(
		requestParameters: V1ApiDeleteMcpServerInstanceRequest,
		initOverrides?: RequestInit | runtime.InitOverrideFunction,
	): Promise<runtime.ApiResponse<void>> {
		if (requestParameters.mcpServerInstanceId == null) {
			throw new runtime.RequiredError(
				"mcpServerInstanceId",
				'Required parameter "mcpServerInstanceId" was null or undefined when calling deleteMcpServerInstance().',
			);
		}

		const queryParameters: any = {};

		const headerParameters: runtime.HTTPHeaders = {};

		if (this.configuration?.accessToken) {
			const token = this.configuration.accessToken;
			const tokenString = await token("bearer_token", []);

			if (tokenString) {
				headerParameters.Authorization = `Bearer ${tokenString}`;
			}
		}
		if (this.configuration?.apiKey) {
			headerParameters["X-API-Key"] =
				await this.configuration.apiKey("X-API-Key"); // api_key authentication
		}

		let urlPath = `/api/mcp/v1/mcp-server/{mcp_server_instance_id}`;
		urlPath = urlPath.replace(
			`{${"mcp_server_instance_id"}}`,
			encodeURIComponent(String(requestParameters.mcpServerInstanceId)),
		);

		const response = await this.request(
			{
				path: urlPath,
				method: "DELETE",
				headers: headerParameters,
				query: queryParameters,
			},
			initOverrides,
		);

		return new runtime.VoidApiResponse(response);
	}

	/**
	 * Delete an MCP server instance and all its function mappings
	 * Delete MCP server instance
	 */
	async deleteMcpServerInstance(
		requestParameters: V1ApiDeleteMcpServerInstanceRequest,
		initOverrides?: RequestInit | runtime.InitOverrideFunction,
	): Promise<void> {
		await this.deleteMcpServerInstanceRaw(requestParameters, initOverrides);
	}

	/**
	 * Delete a provider instance by its unique identifier
	 * Delete provider
	 */
	async deleteProviderInstanceRaw(
		requestParameters: V1ApiDeleteProviderInstanceRequest,
		initOverrides?: RequestInit | runtime.InitOverrideFunction,
	): Promise<runtime.ApiResponse<any>> {
		if (requestParameters.providerInstanceId == null) {
			throw new runtime.RequiredError(
				"providerInstanceId",
				'Required parameter "providerInstanceId" was null or undefined when calling deleteProviderInstance().',
			);
		}

		const queryParameters: any = {};

		const headerParameters: runtime.HTTPHeaders = {};

		if (this.configuration?.accessToken) {
			const token = this.configuration.accessToken;
			const tokenString = await token("bearer_token", []);

			if (tokenString) {
				headerParameters.Authorization = `Bearer ${tokenString}`;
			}
		}
		if (this.configuration?.apiKey) {
			headerParameters["X-API-Key"] =
				await this.configuration.apiKey("X-API-Key"); // api_key authentication
		}

		let urlPath = `/api/mcp/v1/provider/{provider_instance_id}`;
		urlPath = urlPath.replace(
			`{${"provider_instance_id"}}`,
			encodeURIComponent(String(requestParameters.providerInstanceId)),
		);

		const response = await this.request(
			{
				path: urlPath,
				method: "DELETE",
				headers: headerParameters,
				query: queryParameters,
			},
			initOverrides,
		);

		if (this.isJsonMime(response.headers.get("content-type"))) {
			return new runtime.JSONApiResponse<any>(response);
		} else {
			return new runtime.TextApiResponse(response) as any;
		}
	}

	/**
	 * Delete a provider instance by its unique identifier
	 * Delete provider
	 */
	async deleteProviderInstance(
		requestParameters: V1ApiDeleteProviderInstanceRequest,
		initOverrides?: RequestInit | runtime.InitOverrideFunction,
	): Promise<any> {
		const response = await this.deleteProviderInstanceRaw(
			requestParameters,
			initOverrides,
		);
		return await response.value();
	}

	/**
	 * Delete a secret by its unique identifier
	 * Delete secret
	 */
	async deleteSecretRaw(
		requestParameters: V1ApiDeleteSecretRequest,
		initOverrides?: RequestInit | runtime.InitOverrideFunction,
	): Promise<runtime.ApiResponse<DeleteSecretResponse>> {
		if (requestParameters.secretId == null) {
			throw new runtime.RequiredError(
				"secretId",
				'Required parameter "secretId" was null or undefined when calling deleteSecret().',
			);
		}

		const queryParameters: any = {};

		const headerParameters: runtime.HTTPHeaders = {};

		if (this.configuration?.accessToken) {
			const token = this.configuration.accessToken;
			const tokenString = await token("bearer_token", []);

			if (tokenString) {
				headerParameters.Authorization = `Bearer ${tokenString}`;
			}
		}
		if (this.configuration?.apiKey) {
			headerParameters["X-API-Key"] =
				await this.configuration.apiKey("X-API-Key"); // api_key authentication
		}

		let urlPath = `/api/environment/v1/secret/{secret_id}`;
		urlPath = urlPath.replace(
			`{${"secret_id"}}`,
			encodeURIComponent(String(requestParameters.secretId)),
		);

		const response = await this.request(
			{
				path: urlPath,
				method: "DELETE",
				headers: headerParameters,
				query: queryParameters,
			},
			initOverrides,
		);

		return new runtime.JSONApiResponse(response, (jsonValue) =>
			DeleteSecretResponseFromJSON(jsonValue),
		);
	}

	/**
	 * Delete a secret by its unique identifier
	 * Delete secret
	 */
	async deleteSecret(
		requestParameters: V1ApiDeleteSecretRequest,
		initOverrides?: RequestInit | runtime.InitOverrideFunction,
	): Promise<DeleteSecretResponse> {
		const response = await this.deleteSecretRaw(
			requestParameters,
			initOverrides,
		);
		return await response.value();
	}

	/**
	 * Delete a user by their unique identifier
	 * Delete user
	 */
	async deleteUserRaw(
		requestParameters: V1ApiDeleteUserRequest,
		initOverrides?: RequestInit | runtime.InitOverrideFunction,
	): Promise<runtime.ApiResponse<void>> {
		if (requestParameters.userId == null) {
			throw new runtime.RequiredError(
				"userId",
				'Required parameter "userId" was null or undefined when calling deleteUser().',
			);
		}

		const queryParameters: any = {};

		const headerParameters: runtime.HTTPHeaders = {};

		if (this.configuration?.accessToken) {
			const token = this.configuration.accessToken;
			const tokenString = await token("bearer_token", []);

			if (tokenString) {
				headerParameters.Authorization = `Bearer ${tokenString}`;
			}
		}
		if (this.configuration?.apiKey) {
			headerParameters["X-API-Key"] =
				await this.configuration.apiKey("X-API-Key"); // api_key authentication
		}

		let urlPath = `/api/identity/v1/users/{user_id}`;
		urlPath = urlPath.replace(
			`{${"user_id"}}`,
			encodeURIComponent(String(requestParameters.userId)),
		);

		const response = await this.request(
			{
				path: urlPath,
				method: "DELETE",
				headers: headerParameters,
				query: queryParameters,
			},
			initOverrides,
		);

		return new runtime.VoidApiResponse(response);
	}

	/**
	 * Delete a user by their unique identifier
	 * Delete user
	 */
	async deleteUser(
		requestParameters: V1ApiDeleteUserRequest,
		initOverrides?: RequestInit | runtime.InitOverrideFunction,
	): Promise<void> {
		await this.deleteUserRaw(requestParameters, initOverrides);
	}

	/**
	 * Delete an environment variable by its unique identifier
	 * Delete variable
	 */
	async deleteVariableRaw(
		requestParameters: V1ApiDeleteVariableRequest,
		initOverrides?: RequestInit | runtime.InitOverrideFunction,
	): Promise<runtime.ApiResponse<DeleteVariableResponse>> {
		if (requestParameters.variableId == null) {
			throw new runtime.RequiredError(
				"variableId",
				'Required parameter "variableId" was null or undefined when calling deleteVariable().',
			);
		}

		const queryParameters: any = {};

		const headerParameters: runtime.HTTPHeaders = {};

		if (this.configuration?.accessToken) {
			const token = this.configuration.accessToken;
			const tokenString = await token("bearer_token", []);

			if (tokenString) {
				headerParameters.Authorization = `Bearer ${tokenString}`;
			}
		}
		if (this.configuration?.apiKey) {
			headerParameters["X-API-Key"] =
				await this.configuration.apiKey("X-API-Key"); // api_key authentication
		}

		let urlPath = `/api/environment/v1/variable/{variable_id}`;
		urlPath = urlPath.replace(
			`{${"variable_id"}}`,
			encodeURIComponent(String(requestParameters.variableId)),
		);

		const response = await this.request(
			{
				path: urlPath,
				method: "DELETE",
				headers: headerParameters,
				query: queryParameters,
			},
			initOverrides,
		);

		return new runtime.JSONApiResponse(response, (jsonValue) =>
			DeleteVariableResponseFromJSON(jsonValue),
		);
	}

	/**
	 * Delete an environment variable by its unique identifier
	 * Delete variable
	 */
	async deleteVariable(
		requestParameters: V1ApiDeleteVariableRequest,
		initOverrides?: RequestInit | runtime.InitOverrideFunction,
	): Promise<DeleteVariableResponse> {
		const response = await this.deleteVariableRaw(
			requestParameters,
			initOverrides,
		);
		return await response.value();
	}

	/**
	 * Disable a function for a provider instance
	 * Disable function
	 */
	async disableFunctionRaw(
		requestParameters: V1ApiDisableFunctionRequest,
		initOverrides?: RequestInit | runtime.InitOverrideFunction,
	): Promise<runtime.ApiResponse<any>> {
		if (requestParameters.providerInstanceId == null) {
			throw new runtime.RequiredError(
				"providerInstanceId",
				'Required parameter "providerInstanceId" was null or undefined when calling disableFunction().',
			);
		}

		if (requestParameters.functionControllerTypeId == null) {
			throw new runtime.RequiredError(
				"functionControllerTypeId",
				'Required parameter "functionControllerTypeId" was null or undefined when calling disableFunction().',
			);
		}

		const queryParameters: any = {};

		const headerParameters: runtime.HTTPHeaders = {};

		if (this.configuration?.accessToken) {
			const token = this.configuration.accessToken;
			const tokenString = await token("bearer_token", []);

			if (tokenString) {
				headerParameters.Authorization = `Bearer ${tokenString}`;
			}
		}
		if (this.configuration?.apiKey) {
			headerParameters["X-API-Key"] =
				await this.configuration.apiKey("X-API-Key"); // api_key authentication
		}

		let urlPath = `/api/mcp/v1/provider/{provider_instance_id}/function/{function_controller_type_id}/disable`;
		urlPath = urlPath.replace(
			`{${"provider_instance_id"}}`,
			encodeURIComponent(String(requestParameters.providerInstanceId)),
		);
		urlPath = urlPath.replace(
			`{${"function_controller_type_id"}}`,
			encodeURIComponent(String(requestParameters.functionControllerTypeId)),
		);

		const response = await this.request(
			{
				path: urlPath,
				method: "POST",
				headers: headerParameters,
				query: queryParameters,
			},
			initOverrides,
		);

		if (this.isJsonMime(response.headers.get("content-type"))) {
			return new runtime.JSONApiResponse<any>(response);
		} else {
			return new runtime.TextApiResponse(response) as any;
		}
	}

	/**
	 * Disable a function for a provider instance
	 * Disable function
	 */
	async disableFunction(
		requestParameters: V1ApiDisableFunctionRequest,
		initOverrides?: RequestInit | runtime.InitOverrideFunction,
	): Promise<any> {
		const response = await this.disableFunctionRaw(
			requestParameters,
			initOverrides,
		);
		return await response.value();
	}

	/**
	 * Enable a function for a provider instance
	 * Enable function
	 */
	async enableFunctionRaw(
		requestParameters: V1ApiEnableFunctionRequest,
		initOverrides?: RequestInit | runtime.InitOverrideFunction,
	): Promise<runtime.ApiResponse<FunctionInstanceSerialized>> {
		if (requestParameters.providerInstanceId == null) {
			throw new runtime.RequiredError(
				"providerInstanceId",
				'Required parameter "providerInstanceId" was null or undefined when calling enableFunction().',
			);
		}

		if (requestParameters.functionControllerTypeId == null) {
			throw new runtime.RequiredError(
				"functionControllerTypeId",
				'Required parameter "functionControllerTypeId" was null or undefined when calling enableFunction().',
			);
		}

		if (requestParameters.body == null) {
			throw new runtime.RequiredError(
				"body",
				'Required parameter "body" was null or undefined when calling enableFunction().',
			);
		}

		const queryParameters: any = {};

		const headerParameters: runtime.HTTPHeaders = {};

		headerParameters["Content-Type"] = "application/json";

		if (this.configuration?.accessToken) {
			const token = this.configuration.accessToken;
			const tokenString = await token("bearer_token", []);

			if (tokenString) {
				headerParameters.Authorization = `Bearer ${tokenString}`;
			}
		}
		if (this.configuration?.apiKey) {
			headerParameters["X-API-Key"] =
				await this.configuration.apiKey("X-API-Key"); // api_key authentication
		}

		let urlPath = `/api/mcp/v1/provider/{provider_instance_id}/function/{function_controller_type_id}/enable`;
		urlPath = urlPath.replace(
			`{${"provider_instance_id"}}`,
			encodeURIComponent(String(requestParameters.providerInstanceId)),
		);
		urlPath = urlPath.replace(
			`{${"function_controller_type_id"}}`,
			encodeURIComponent(String(requestParameters.functionControllerTypeId)),
		);

		const response = await this.request(
			{
				path: urlPath,
				method: "POST",
				headers: headerParameters,
				query: queryParameters,
				body: requestParameters.body as any,
			},
			initOverrides,
		);

		return new runtime.JSONApiResponse(response, (jsonValue) =>
			FunctionInstanceSerializedFromJSON(jsonValue),
		);
	}

	/**
	 * Enable a function for a provider instance
	 * Enable function
	 */
	async enableFunction(
		requestParameters: V1ApiEnableFunctionRequest,
		initOverrides?: RequestInit | runtime.InitOverrideFunction,
	): Promise<FunctionInstanceSerialized> {
		const response = await this.enableFunctionRaw(
			requestParameters,
			initOverrides,
		);
		return await response.value();
	}

	/**
	 * Encrypt a resource server credential configuration before storage
	 * Encrypt resource server config
	 */
	async encryptResourceServerConfigurationRaw(
		requestParameters: V1ApiEncryptResourceServerConfigurationRequest,
		initOverrides?: RequestInit | runtime.InitOverrideFunction,
	): Promise<runtime.ApiResponse<any>> {
		if (requestParameters.providerControllerTypeId == null) {
			throw new runtime.RequiredError(
				"providerControllerTypeId",
				'Required parameter "providerControllerTypeId" was null or undefined when calling encryptResourceServerConfiguration().',
			);
		}

		if (requestParameters.credentialControllerTypeId == null) {
			throw new runtime.RequiredError(
				"credentialControllerTypeId",
				'Required parameter "credentialControllerTypeId" was null or undefined when calling encryptResourceServerConfiguration().',
			);
		}

		if (requestParameters.encryptCredentialConfigurationParamsInner == null) {
			throw new runtime.RequiredError(
				"encryptCredentialConfigurationParamsInner",
				'Required parameter "encryptCredentialConfigurationParamsInner" was null or undefined when calling encryptResourceServerConfiguration().',
			);
		}

		const queryParameters: any = {};

		const headerParameters: runtime.HTTPHeaders = {};

		headerParameters["Content-Type"] = "application/json";

		if (this.configuration?.accessToken) {
			const token = this.configuration.accessToken;
			const tokenString = await token("bearer_token", []);

			if (tokenString) {
				headerParameters.Authorization = `Bearer ${tokenString}`;
			}
		}
		if (this.configuration?.apiKey) {
			headerParameters["X-API-Key"] =
				await this.configuration.apiKey("X-API-Key"); // api_key authentication
		}

		let urlPath = `/api/mcp/v1/available-providers/{provider_controller_type_id}/available-credentials/{credential_controller_type_id}/credential/resource-server/encrypt`;
		urlPath = urlPath.replace(
			`{${"provider_controller_type_id"}}`,
			encodeURIComponent(String(requestParameters.providerControllerTypeId)),
		);
		urlPath = urlPath.replace(
			`{${"credential_controller_type_id"}}`,
			encodeURIComponent(String(requestParameters.credentialControllerTypeId)),
		);

		const response = await this.request(
			{
				path: urlPath,
				method: "POST",
				headers: headerParameters,
				query: queryParameters,
				body: EncryptCredentialConfigurationParamsInnerToJSON(
					requestParameters.encryptCredentialConfigurationParamsInner,
				),
			},
			initOverrides,
		);

		if (this.isJsonMime(response.headers.get("content-type"))) {
			return new runtime.JSONApiResponse<any>(response);
		} else {
			return new runtime.TextApiResponse(response) as any;
		}
	}

	/**
	 * Encrypt a resource server credential configuration before storage
	 * Encrypt resource server config
	 */
	async encryptResourceServerConfiguration(
		requestParameters: V1ApiEncryptResourceServerConfigurationRequest,
		initOverrides?: RequestInit | runtime.InitOverrideFunction,
	): Promise<any> {
		const response = await this.encryptResourceServerConfigurationRaw(
			requestParameters,
			initOverrides,
		);
		return await response.value();
	}

	/**
	 * Encrypt a user credential configuration before storage
	 * Encrypt user credential config
	 */
	async encryptUserCredentialConfigurationRaw(
		requestParameters: V1ApiEncryptUserCredentialConfigurationRequest,
		initOverrides?: RequestInit | runtime.InitOverrideFunction,
	): Promise<runtime.ApiResponse<any>> {
		if (requestParameters.providerControllerTypeId == null) {
			throw new runtime.RequiredError(
				"providerControllerTypeId",
				'Required parameter "providerControllerTypeId" was null or undefined when calling encryptUserCredentialConfiguration().',
			);
		}

		if (requestParameters.credentialControllerTypeId == null) {
			throw new runtime.RequiredError(
				"credentialControllerTypeId",
				'Required parameter "credentialControllerTypeId" was null or undefined when calling encryptUserCredentialConfiguration().',
			);
		}

		if (requestParameters.encryptCredentialConfigurationParamsInner == null) {
			throw new runtime.RequiredError(
				"encryptCredentialConfigurationParamsInner",
				'Required parameter "encryptCredentialConfigurationParamsInner" was null or undefined when calling encryptUserCredentialConfiguration().',
			);
		}

		const queryParameters: any = {};

		const headerParameters: runtime.HTTPHeaders = {};

		headerParameters["Content-Type"] = "application/json";

		if (this.configuration?.accessToken) {
			const token = this.configuration.accessToken;
			const tokenString = await token("bearer_token", []);

			if (tokenString) {
				headerParameters.Authorization = `Bearer ${tokenString}`;
			}
		}
		if (this.configuration?.apiKey) {
			headerParameters["X-API-Key"] =
				await this.configuration.apiKey("X-API-Key"); // api_key authentication
		}

		let urlPath = `/api/mcp/v1/available-providers/{provider_controller_type_id}/available-credentials/{credential_controller_type_id}/credential/user-credential/encrypt`;
		urlPath = urlPath.replace(
			`{${"provider_controller_type_id"}}`,
			encodeURIComponent(String(requestParameters.providerControllerTypeId)),
		);
		urlPath = urlPath.replace(
			`{${"credential_controller_type_id"}}`,
			encodeURIComponent(String(requestParameters.credentialControllerTypeId)),
		);

		const response = await this.request(
			{
				path: urlPath,
				method: "POST",
				headers: headerParameters,
				query: queryParameters,
				body: EncryptCredentialConfigurationParamsInnerToJSON(
					requestParameters.encryptCredentialConfigurationParamsInner,
				),
			},
			initOverrides,
		);

		if (this.isJsonMime(response.headers.get("content-type"))) {
			return new runtime.JSONApiResponse<any>(response);
		} else {
			return new runtime.TextApiResponse(response) as any;
		}
	}

	/**
	 * Encrypt a user credential configuration before storage
	 * Encrypt user credential config
	 */
	async encryptUserCredentialConfiguration(
		requestParameters: V1ApiEncryptUserCredentialConfigurationRequest,
		initOverrides?: RequestInit | runtime.InitOverrideFunction,
	): Promise<any> {
		const response = await this.encryptUserCredentialConfigurationRaw(
			requestParameters,
			initOverrides,
		);
		return await response.value();
	}

	/**
	 * Get the agent card describing agent capabilities and metadata for a specific agent
	 * Get agent card for specific agent
	 */
	async getAgentCardRaw(
		requestParameters: V1ApiGetAgentCardRequest,
		initOverrides?: RequestInit | runtime.InitOverrideFunction,
	): Promise<runtime.ApiResponse<object>> {
		if (requestParameters.projectId == null) {
			throw new runtime.RequiredError(
				"projectId",
				'Required parameter "projectId" was null or undefined when calling getAgentCard().',
			);
		}

		if (requestParameters.agentId == null) {
			throw new runtime.RequiredError(
				"agentId",
				'Required parameter "agentId" was null or undefined when calling getAgentCard().',
			);
		}

		const queryParameters: any = {};

		const headerParameters: runtime.HTTPHeaders = {};

		if (this.configuration?.accessToken) {
			const token = this.configuration.accessToken;
			const tokenString = await token("bearer_token", []);

			if (tokenString) {
				headerParameters.Authorization = `Bearer ${tokenString}`;
			}
		}
		if (this.configuration?.apiKey) {
			headerParameters["X-API-Key"] =
				await this.configuration.apiKey("X-API-Key"); // api_key authentication
		}

		let urlPath = `/api/agent/{project_id}/{agent_id}/a2a/.well-known/agent.json`;
		urlPath = urlPath.replace(
			`{${"project_id"}}`,
			encodeURIComponent(String(requestParameters.projectId)),
		);
		urlPath = urlPath.replace(
			`{${"agent_id"}}`,
			encodeURIComponent(String(requestParameters.agentId)),
		);

		const response = await this.request(
			{
				path: urlPath,
				method: "GET",
				headers: headerParameters,
				query: queryParameters,
			},
			initOverrides,
		);

		return new runtime.JSONApiResponse<any>(response);
	}

	/**
	 * Get the agent card describing agent capabilities and metadata for a specific agent
	 * Get agent card for specific agent
	 */
	async getAgentCard(
		requestParameters: V1ApiGetAgentCardRequest,
		initOverrides?: RequestInit | runtime.InitOverrideFunction,
	): Promise<object> {
		const response = await this.getAgentCardRaw(
			requestParameters,
			initOverrides,
		);
		return await response.value();
	}

	/**
	 * Retrieve a data encryption key by its alias or ID
	 * Get DEK by alias
	 */
	async getDekByAliasOrIdRaw(
		requestParameters: V1ApiGetDekByAliasOrIdRequest,
		initOverrides?: RequestInit | runtime.InitOverrideFunction,
	): Promise<runtime.ApiResponse<DataEncryptionKey>> {
		if (requestParameters.alias == null) {
			throw new runtime.RequiredError(
				"alias",
				'Required parameter "alias" was null or undefined when calling getDekByAliasOrId().',
			);
		}

		const queryParameters: any = {};

		const headerParameters: runtime.HTTPHeaders = {};

		if (this.configuration?.accessToken) {
			const token = this.configuration.accessToken;
			const tokenString = await token("bearer_token", []);

			if (tokenString) {
				headerParameters.Authorization = `Bearer ${tokenString}`;
			}
		}
		if (this.configuration?.apiKey) {
			headerParameters["X-API-Key"] =
				await this.configuration.apiKey("X-API-Key"); // api_key authentication
		}

		let urlPath = `/api/encryption/v1/dek/alias/{alias}`;
		urlPath = urlPath.replace(
			`{${"alias"}}`,
			encodeURIComponent(String(requestParameters.alias)),
		);

		const response = await this.request(
			{
				path: urlPath,
				method: "GET",
				headers: headerParameters,
				query: queryParameters,
			},
			initOverrides,
		);

		return new runtime.JSONApiResponse(response, (jsonValue) =>
			DataEncryptionKeyFromJSON(jsonValue),
		);
	}

	/**
	 * Retrieve a data encryption key by its alias or ID
	 * Get DEK by alias
	 */
	async getDekByAliasOrId(
		requestParameters: V1ApiGetDekByAliasOrIdRequest,
		initOverrides?: RequestInit | runtime.InitOverrideFunction,
	): Promise<DataEncryptionKey> {
		const response = await this.getDekByAliasOrIdRaw(
			requestParameters,
			initOverrides,
		);
		return await response.value();
	}

	/**
	 * Get the OpenAPI specification for all function instances
	 * Get function OpenAPI spec
	 */
	async getFunctionInstancesOpenapiSpecRaw(
		initOverrides?: RequestInit | runtime.InitOverrideFunction,
	): Promise<runtime.ApiResponse<string>> {
		const queryParameters: any = {};

		const headerParameters: runtime.HTTPHeaders = {};

		if (this.configuration?.accessToken) {
			const token = this.configuration.accessToken;
			const tokenString = await token("bearer_token", []);

			if (tokenString) {
				headerParameters.Authorization = `Bearer ${tokenString}`;
			}
		}
		if (this.configuration?.apiKey) {
			headerParameters["X-API-Key"] =
				await this.configuration.apiKey("X-API-Key"); // api_key authentication
		}

		const urlPath = `/api/mcp/v1/function-instances/openapi.json`;

		const response = await this.request(
			{
				path: urlPath,
				method: "GET",
				headers: headerParameters,
				query: queryParameters,
			},
			initOverrides,
		);

		if (this.isJsonMime(response.headers.get("content-type"))) {
			return new runtime.JSONApiResponse<string>(response);
		} else {
			return new runtime.TextApiResponse(response) as any;
		}
	}

	/**
	 * Get the OpenAPI specification for all function instances
	 * Get function OpenAPI spec
	 */
	async getFunctionInstancesOpenapiSpec(
		initOverrides?: RequestInit | runtime.InitOverrideFunction,
	): Promise<string> {
		const response =
			await this.getFunctionInstancesOpenapiSpecRaw(initOverrides);
		return await response.value();
	}

	/**
	 * Retrieve a group by its unique identifier
	 * Get group
	 */
	async getGroupRaw(
		requestParameters: V1ApiGetGroupRequest,
		initOverrides?: RequestInit | runtime.InitOverrideFunction,
	): Promise<runtime.ApiResponse<Group>> {
		if (requestParameters.groupId == null) {
			throw new runtime.RequiredError(
				"groupId",
				'Required parameter "groupId" was null or undefined when calling getGroup().',
			);
		}

		const queryParameters: any = {};

		const headerParameters: runtime.HTTPHeaders = {};

		if (this.configuration?.accessToken) {
			const token = this.configuration.accessToken;
			const tokenString = await token("bearer_token", []);

			if (tokenString) {
				headerParameters.Authorization = `Bearer ${tokenString}`;
			}
		}
		if (this.configuration?.apiKey) {
			headerParameters["X-API-Key"] =
				await this.configuration.apiKey("X-API-Key"); // api_key authentication
		}

		let urlPath = `/api/identity/v1/groups/{group_id}`;
		urlPath = urlPath.replace(
			`{${"group_id"}}`,
			encodeURIComponent(String(requestParameters.groupId)),
		);

		const response = await this.request(
			{
				path: urlPath,
				method: "GET",
				headers: headerParameters,
				query: queryParameters,
			},
			initOverrides,
		);

		return new runtime.JSONApiResponse(response, (jsonValue) =>
			GroupFromJSON(jsonValue),
		);
	}

	/**
	 * Retrieve a group by its unique identifier
	 * Get group
	 */
	async getGroup(
		requestParameters: V1ApiGetGroupRequest,
		initOverrides?: RequestInit | runtime.InitOverrideFunction,
	): Promise<Group> {
		const response = await this.getGroupRaw(requestParameters, initOverrides);
		return await response.value();
	}

	/**
	 * Get the current runtime configuration
	 * Get runtime config
	 */
	async getInternalRuntimeConfigRaw(
		initOverrides?: RequestInit | runtime.InitOverrideFunction,
	): Promise<runtime.ApiResponse<object>> {
		const queryParameters: any = {};

		const headerParameters: runtime.HTTPHeaders = {};

		if (this.configuration?.accessToken) {
			const token = this.configuration.accessToken;
			const tokenString = await token("bearer_token", []);

			if (tokenString) {
				headerParameters.Authorization = `Bearer ${tokenString}`;
			}
		}
		if (this.configuration?.apiKey) {
			headerParameters["X-API-Key"] =
				await this.configuration.apiKey("X-API-Key"); // api_key authentication
		}

		const urlPath = `/_internal/v1/runtime_config`;

		const response = await this.request(
			{
				path: urlPath,
				method: "GET",
				headers: headerParameters,
				query: queryParameters,
			},
			initOverrides,
		);

		return new runtime.JSONApiResponse<any>(response);
	}

	/**
	 * Get the current runtime configuration
	 * Get runtime config
	 */
	async getInternalRuntimeConfig(
		initOverrides?: RequestInit | runtime.InitOverrideFunction,
	): Promise<object> {
		const response = await this.getInternalRuntimeConfigRaw(initOverrides);
		return await response.value();
	}

	/**
	 * Retrieve an MCP server instance by its ID
	 * Get MCP server instance
	 */
	async getMcpServerInstanceRaw(
		requestParameters: V1ApiGetMcpServerInstanceRequest,
		initOverrides?: RequestInit | runtime.InitOverrideFunction,
	): Promise<runtime.ApiResponse<McpServerInstanceSerializedWithFunctions>> {
		if (requestParameters.mcpServerInstanceId == null) {
			throw new runtime.RequiredError(
				"mcpServerInstanceId",
				'Required parameter "mcpServerInstanceId" was null or undefined when calling getMcpServerInstance().',
			);
		}

		const queryParameters: any = {};

		const headerParameters: runtime.HTTPHeaders = {};

		if (this.configuration?.accessToken) {
			const token = this.configuration.accessToken;
			const tokenString = await token("bearer_token", []);

			if (tokenString) {
				headerParameters.Authorization = `Bearer ${tokenString}`;
			}
		}
		if (this.configuration?.apiKey) {
			headerParameters["X-API-Key"] =
				await this.configuration.apiKey("X-API-Key"); // api_key authentication
		}

		let urlPath = `/api/mcp/v1/mcp-server/{mcp_server_instance_id}`;
		urlPath = urlPath.replace(
			`{${"mcp_server_instance_id"}}`,
			encodeURIComponent(String(requestParameters.mcpServerInstanceId)),
		);

		const response = await this.request(
			{
				path: urlPath,
				method: "GET",
				headers: headerParameters,
				query: queryParameters,
			},
			initOverrides,
		);

		return new runtime.JSONApiResponse(response, (jsonValue) =>
			McpServerInstanceSerializedWithFunctionsFromJSON(jsonValue),
		);
	}

	/**
	 * Retrieve an MCP server instance by its ID
	 * Get MCP server instance
	 */
	async getMcpServerInstance(
		requestParameters: V1ApiGetMcpServerInstanceRequest,
		initOverrides?: RequestInit | runtime.InitOverrideFunction,
	): Promise<McpServerInstanceSerializedWithFunctions> {
		const response = await this.getMcpServerInstanceRaw(
			requestParameters,
			initOverrides,
		);
		return await response.value();
	}

	/**
	 * Retrieve a provider instance by its unique identifier
	 * Get provider
	 */
	async getProviderInstanceRaw(
		requestParameters: V1ApiGetProviderInstanceRequest,
		initOverrides?: RequestInit | runtime.InitOverrideFunction,
	): Promise<runtime.ApiResponse<ProviderInstanceSerializedWithEverything>> {
		if (requestParameters.providerInstanceId == null) {
			throw new runtime.RequiredError(
				"providerInstanceId",
				'Required parameter "providerInstanceId" was null or undefined when calling getProviderInstance().',
			);
		}

		const queryParameters: any = {};

		const headerParameters: runtime.HTTPHeaders = {};

		if (this.configuration?.accessToken) {
			const token = this.configuration.accessToken;
			const tokenString = await token("bearer_token", []);

			if (tokenString) {
				headerParameters.Authorization = `Bearer ${tokenString}`;
			}
		}
		if (this.configuration?.apiKey) {
			headerParameters["X-API-Key"] =
				await this.configuration.apiKey("X-API-Key"); // api_key authentication
		}

		let urlPath = `/api/mcp/v1/provider/{provider_instance_id}`;
		urlPath = urlPath.replace(
			`{${"provider_instance_id"}}`,
			encodeURIComponent(String(requestParameters.providerInstanceId)),
		);

		const response = await this.request(
			{
				path: urlPath,
				method: "GET",
				headers: headerParameters,
				query: queryParameters,
			},
			initOverrides,
		);

		return new runtime.JSONApiResponse(response, (jsonValue) =>
			ProviderInstanceSerializedWithEverythingFromJSON(jsonValue),
		);
	}

	/**
	 * Retrieve a provider instance by its unique identifier
	 * Get provider
	 */
	async getProviderInstance(
		requestParameters: V1ApiGetProviderInstanceRequest,
		initOverrides?: RequestInit | runtime.InitOverrideFunction,
	): Promise<ProviderInstanceSerializedWithEverything> {
		const response = await this.getProviderInstanceRaw(
			requestParameters,
			initOverrides,
		);
		return await response.value();
	}

	/**
	 * Retrieve a secret by its unique identifier
	 * Get secret
	 */
	async getSecretByIdRaw(
		requestParameters: V1ApiGetSecretByIdRequest,
		initOverrides?: RequestInit | runtime.InitOverrideFunction,
	): Promise<runtime.ApiResponse<Secret>> {
		if (requestParameters.secretId == null) {
			throw new runtime.RequiredError(
				"secretId",
				'Required parameter "secretId" was null or undefined when calling getSecretById().',
			);
		}

		const queryParameters: any = {};

		const headerParameters: runtime.HTTPHeaders = {};

		if (this.configuration?.accessToken) {
			const token = this.configuration.accessToken;
			const tokenString = await token("bearer_token", []);

			if (tokenString) {
				headerParameters.Authorization = `Bearer ${tokenString}`;
			}
		}
		if (this.configuration?.apiKey) {
			headerParameters["X-API-Key"] =
				await this.configuration.apiKey("X-API-Key"); // api_key authentication
		}

		let urlPath = `/api/environment/v1/secret/{secret_id}`;
		urlPath = urlPath.replace(
			`{${"secret_id"}}`,
			encodeURIComponent(String(requestParameters.secretId)),
		);

		const response = await this.request(
			{
				path: urlPath,
				method: "GET",
				headers: headerParameters,
				query: queryParameters,
			},
			initOverrides,
		);

		return new runtime.JSONApiResponse(response, (jsonValue) =>
			SecretFromJSON(jsonValue),
		);
	}

	/**
	 * Retrieve a secret by its unique identifier
	 * Get secret
	 */
	async getSecretById(
		requestParameters: V1ApiGetSecretByIdRequest,
		initOverrides?: RequestInit | runtime.InitOverrideFunction,
	): Promise<Secret> {
		const response = await this.getSecretByIdRaw(
			requestParameters,
			initOverrides,
		);
		return await response.value();
	}

	/**
	 * Retrieve a secret by its key name
	 * Get secret by key
	 */
	async getSecretByKeyRaw(
		requestParameters: V1ApiGetSecretByKeyRequest,
		initOverrides?: RequestInit | runtime.InitOverrideFunction,
	): Promise<runtime.ApiResponse<Secret>> {
		if (requestParameters.key == null) {
			throw new runtime.RequiredError(
				"key",
				'Required parameter "key" was null or undefined when calling getSecretByKey().',
			);
		}

		const queryParameters: any = {};

		const headerParameters: runtime.HTTPHeaders = {};

		if (this.configuration?.accessToken) {
			const token = this.configuration.accessToken;
			const tokenString = await token("bearer_token", []);

			if (tokenString) {
				headerParameters.Authorization = `Bearer ${tokenString}`;
			}
		}
		if (this.configuration?.apiKey) {
			headerParameters["X-API-Key"] =
				await this.configuration.apiKey("X-API-Key"); // api_key authentication
		}

		let urlPath = `/api/environment/v1/secret/key/{key}`;
		urlPath = urlPath.replace(
			`{${"key"}}`,
			encodeURIComponent(String(requestParameters.key)),
		);

		const response = await this.request(
			{
				path: urlPath,
				method: "GET",
				headers: headerParameters,
				query: queryParameters,
			},
			initOverrides,
		);

		return new runtime.JSONApiResponse(response, (jsonValue) =>
			SecretFromJSON(jsonValue),
		);
	}

	/**
	 * Retrieve a secret by its key name
	 * Get secret by key
	 */
	async getSecretByKey(
		requestParameters: V1ApiGetSecretByKeyRequest,
		initOverrides?: RequestInit | runtime.InitOverrideFunction,
	): Promise<Secret> {
		const response = await this.getSecretByKeyRaw(
			requestParameters,
			initOverrides,
		);
		return await response.value();
	}

	/**
	 * Retrieve a task by its unique identifier
	 * Get task
	 */
	async getTaskByIdRaw(
		requestParameters: V1ApiGetTaskByIdRequest,
		initOverrides?: RequestInit | runtime.InitOverrideFunction,
	): Promise<runtime.ApiResponse<TaskWithDetails>> {
		if (requestParameters.taskId == null) {
			throw new runtime.RequiredError(
				"taskId",
				'Required parameter "taskId" was null or undefined when calling getTaskById().',
			);
		}

		const queryParameters: any = {};

		const headerParameters: runtime.HTTPHeaders = {};

		if (this.configuration?.accessToken) {
			const token = this.configuration.accessToken;
			const tokenString = await token("bearer_token", []);

			if (tokenString) {
				headerParameters.Authorization = `Bearer ${tokenString}`;
			}
		}
		if (this.configuration?.apiKey) {
			headerParameters["X-API-Key"] =
				await this.configuration.apiKey("X-API-Key"); // api_key authentication
		}

		let urlPath = `/api/task/v1/{task_id}`;
		urlPath = urlPath.replace(
			`{${"task_id"}}`,
			encodeURIComponent(String(requestParameters.taskId)),
		);

		const response = await this.request(
			{
				path: urlPath,
				method: "GET",
				headers: headerParameters,
				query: queryParameters,
			},
			initOverrides,
		);

		return new runtime.JSONApiResponse(response, (jsonValue) =>
			TaskWithDetailsFromJSON(jsonValue),
		);
	}

	/**
	 * Retrieve a task by its unique identifier
	 * Get task
	 */
	async getTaskById(
		requestParameters: V1ApiGetTaskByIdRequest,
		initOverrides?: RequestInit | runtime.InitOverrideFunction,
	): Promise<TaskWithDetails> {
		const response = await this.getTaskByIdRaw(
			requestParameters,
			initOverrides,
		);
		return await response.value();
	}

	/**
	 * Retrieve a user by their unique identifier
	 * Get user
	 */
	async getUserRaw(
		requestParameters: V1ApiGetUserRequest,
		initOverrides?: RequestInit | runtime.InitOverrideFunction,
	): Promise<runtime.ApiResponse<User>> {
		if (requestParameters.userId == null) {
			throw new runtime.RequiredError(
				"userId",
				'Required parameter "userId" was null or undefined when calling getUser().',
			);
		}

		const queryParameters: any = {};

		const headerParameters: runtime.HTTPHeaders = {};

		if (this.configuration?.accessToken) {
			const token = this.configuration.accessToken;
			const tokenString = await token("bearer_token", []);

			if (tokenString) {
				headerParameters.Authorization = `Bearer ${tokenString}`;
			}
		}
		if (this.configuration?.apiKey) {
			headerParameters["X-API-Key"] =
				await this.configuration.apiKey("X-API-Key"); // api_key authentication
		}

		let urlPath = `/api/identity/v1/users/{user_id}`;
		urlPath = urlPath.replace(
			`{${"user_id"}}`,
			encodeURIComponent(String(requestParameters.userId)),
		);

		const response = await this.request(
			{
				path: urlPath,
				method: "GET",
				headers: headerParameters,
				query: queryParameters,
			},
			initOverrides,
		);

		return new runtime.JSONApiResponse(response, (jsonValue) =>
			UserFromJSON(jsonValue),
		);
	}

	/**
	 * Retrieve a user by their unique identifier
	 * Get user
	 */
	async getUser(
		requestParameters: V1ApiGetUserRequest,
		initOverrides?: RequestInit | runtime.InitOverrideFunction,
	): Promise<User> {
		const response = await this.getUserRaw(requestParameters, initOverrides);
		return await response.value();
	}

	/**
	 * Retrieve an environment variable by its unique identifier
	 * Get variable
	 */
	async getVariableByIdRaw(
		requestParameters: V1ApiGetVariableByIdRequest,
		initOverrides?: RequestInit | runtime.InitOverrideFunction,
	): Promise<runtime.ApiResponse<Variable>> {
		if (requestParameters.variableId == null) {
			throw new runtime.RequiredError(
				"variableId",
				'Required parameter "variableId" was null or undefined when calling getVariableById().',
			);
		}

		const queryParameters: any = {};

		const headerParameters: runtime.HTTPHeaders = {};

		if (this.configuration?.accessToken) {
			const token = this.configuration.accessToken;
			const tokenString = await token("bearer_token", []);

			if (tokenString) {
				headerParameters.Authorization = `Bearer ${tokenString}`;
			}
		}
		if (this.configuration?.apiKey) {
			headerParameters["X-API-Key"] =
				await this.configuration.apiKey("X-API-Key"); // api_key authentication
		}

		let urlPath = `/api/environment/v1/variable/{variable_id}`;
		urlPath = urlPath.replace(
			`{${"variable_id"}}`,
			encodeURIComponent(String(requestParameters.variableId)),
		);

		const response = await this.request(
			{
				path: urlPath,
				method: "GET",
				headers: headerParameters,
				query: queryParameters,
			},
			initOverrides,
		);

		return new runtime.JSONApiResponse(response, (jsonValue) =>
			VariableFromJSON(jsonValue),
		);
	}

	/**
	 * Retrieve an environment variable by its unique identifier
	 * Get variable
	 */
	async getVariableById(
		requestParameters: V1ApiGetVariableByIdRequest,
		initOverrides?: RequestInit | runtime.InitOverrideFunction,
	): Promise<Variable> {
		const response = await this.getVariableByIdRaw(
			requestParameters,
			initOverrides,
		);
		return await response.value();
	}

	/**
	 * Retrieve an environment variable by its key name
	 * Get variable by key
	 */
	async getVariableByKeyRaw(
		requestParameters: V1ApiGetVariableByKeyRequest,
		initOverrides?: RequestInit | runtime.InitOverrideFunction,
	): Promise<runtime.ApiResponse<Variable>> {
		if (requestParameters.key == null) {
			throw new runtime.RequiredError(
				"key",
				'Required parameter "key" was null or undefined when calling getVariableByKey().',
			);
		}

		const queryParameters: any = {};

		const headerParameters: runtime.HTTPHeaders = {};

		if (this.configuration?.accessToken) {
			const token = this.configuration.accessToken;
			const tokenString = await token("bearer_token", []);

			if (tokenString) {
				headerParameters.Authorization = `Bearer ${tokenString}`;
			}
		}
		if (this.configuration?.apiKey) {
			headerParameters["X-API-Key"] =
				await this.configuration.apiKey("X-API-Key"); // api_key authentication
		}

		let urlPath = `/api/environment/v1/variable/key/{key}`;
		urlPath = urlPath.replace(
			`{${"key"}}`,
			encodeURIComponent(String(requestParameters.key)),
		);

		const response = await this.request(
			{
				path: urlPath,
				method: "GET",
				headers: headerParameters,
				query: queryParameters,
			},
			initOverrides,
		);

		return new runtime.JSONApiResponse(response, (jsonValue) =>
			VariableFromJSON(jsonValue),
		);
	}

	/**
	 * Retrieve an environment variable by its key name
	 * Get variable by key
	 */
	async getVariableByKey(
		requestParameters: V1ApiGetVariableByKeyRequest,
		initOverrides?: RequestInit | runtime.InitOverrideFunction,
	): Promise<Variable> {
		const response = await this.getVariableByKeyRaw(
			requestParameters,
			initOverrides,
		);
		return await response.value();
	}

	/**
	 * Handle JSON-RPC requests for agent-to-agent communication for a specific agent
	 * Handle A2A JSON-RPC for specific agent
	 */
	async handleA2aJsonrpcRequestRaw(
		requestParameters: V1ApiHandleA2aJsonrpcRequestRequest,
		initOverrides?: RequestInit | runtime.InitOverrideFunction,
	): Promise<runtime.ApiResponse<void>> {
		if (requestParameters.projectId == null) {
			throw new runtime.RequiredError(
				"projectId",
				'Required parameter "projectId" was null or undefined when calling handleA2aJsonrpcRequest().',
			);
		}

		if (requestParameters.agentId == null) {
			throw new runtime.RequiredError(
				"agentId",
				'Required parameter "agentId" was null or undefined when calling handleA2aJsonrpcRequest().',
			);
		}

		if (requestParameters.body == null) {
			throw new runtime.RequiredError(
				"body",
				'Required parameter "body" was null or undefined when calling handleA2aJsonrpcRequest().',
			);
		}

		const queryParameters: any = {};

		const headerParameters: runtime.HTTPHeaders = {};

		headerParameters["Content-Type"] = "application/json";

		if (this.configuration?.accessToken) {
			const token = this.configuration.accessToken;
			const tokenString = await token("bearer_token", []);

			if (tokenString) {
				headerParameters.Authorization = `Bearer ${tokenString}`;
			}
		}
		if (this.configuration?.apiKey) {
			headerParameters["X-API-Key"] =
				await this.configuration.apiKey("X-API-Key"); // api_key authentication
		}

		let urlPath = `/api/agent/{project_id}/{agent_id}/a2a`;
		urlPath = urlPath.replace(
			`{${"project_id"}}`,
			encodeURIComponent(String(requestParameters.projectId)),
		);
		urlPath = urlPath.replace(
			`{${"agent_id"}}`,
			encodeURIComponent(String(requestParameters.agentId)),
		);

		const response = await this.request(
			{
				path: urlPath,
				method: "POST",
				headers: headerParameters,
				query: queryParameters,
				body: requestParameters.body as any,
			},
			initOverrides,
		);

		return new runtime.VoidApiResponse(response);
	}

	/**
	 * Handle JSON-RPC requests for agent-to-agent communication for a specific agent
	 * Handle A2A JSON-RPC for specific agent
	 */
	async handleA2aJsonrpcRequest(
		requestParameters: V1ApiHandleA2aJsonrpcRequestRequest,
		initOverrides?: RequestInit | runtime.InitOverrideFunction,
	): Promise<void> {
		await this.handleA2aJsonrpcRequestRaw(requestParameters, initOverrides);
	}

	/**
	 * Check the health status of the service and SDK server connectivity
	 * Health check
	 */
	async healthCheckRaw(
		initOverrides?: RequestInit | runtime.InitOverrideFunction,
	): Promise<runtime.ApiResponse<object>> {
		const queryParameters: any = {};

		const headerParameters: runtime.HTTPHeaders = {};

		if (this.configuration?.accessToken) {
			const token = this.configuration.accessToken;
			const tokenString = await token("bearer_token", []);

			if (tokenString) {
				headerParameters.Authorization = `Bearer ${tokenString}`;
			}
		}
		if (this.configuration?.apiKey) {
			headerParameters["X-API-Key"] =
				await this.configuration.apiKey("X-API-Key"); // api_key authentication
		}

		const urlPath = `/_internal/v1/health`;

		const response = await this.request(
			{
				path: urlPath,
				method: "GET",
				headers: headerParameters,
				query: queryParameters,
			},
			initOverrides,
		);

		return new runtime.JSONApiResponse<any>(response);
	}

	/**
	 * Check the health status of the service and SDK server connectivity
	 * Health check
	 */
	async healthCheck(
		initOverrides?: RequestInit | runtime.InitOverrideFunction,
	): Promise<object> {
		const response = await this.healthCheckRaw(initOverrides);
		return await response.value();
	}

	/**
	 * Import an existing pre-encrypted data encryption key into the system
	 * Import data key
	 */
	async importDataEncryptionKeyRaw(
		requestParameters: V1ApiImportDataEncryptionKeyRequest,
		initOverrides?: RequestInit | runtime.InitOverrideFunction,
	): Promise<runtime.ApiResponse<DataEncryptionKey>> {
		if (requestParameters.envelopeId == null) {
			throw new runtime.RequiredError(
				"envelopeId",
				'Required parameter "envelopeId" was null or undefined when calling importDataEncryptionKey().',
			);
		}

		if (requestParameters.importDataEncryptionKeyParamsRoute == null) {
			throw new runtime.RequiredError(
				"importDataEncryptionKeyParamsRoute",
				'Required parameter "importDataEncryptionKeyParamsRoute" was null or undefined when calling importDataEncryptionKey().',
			);
		}

		const queryParameters: any = {};

		const headerParameters: runtime.HTTPHeaders = {};

		headerParameters["Content-Type"] = "application/json";

		if (this.configuration?.accessToken) {
			const token = this.configuration.accessToken;
			const tokenString = await token("bearer_token", []);

			if (tokenString) {
				headerParameters.Authorization = `Bearer ${tokenString}`;
			}
		}
		if (this.configuration?.apiKey) {
			headerParameters["X-API-Key"] =
				await this.configuration.apiKey("X-API-Key"); // api_key authentication
		}

		let urlPath = `/api/encryption/v1/envelope/{envelope_id}/dek/import`;
		urlPath = urlPath.replace(
			`{${"envelope_id"}}`,
			encodeURIComponent(String(requestParameters.envelopeId)),
		);

		const response = await this.request(
			{
				path: urlPath,
				method: "POST",
				headers: headerParameters,
				query: queryParameters,
				body: ImportDataEncryptionKeyParamsRouteToJSON(
					requestParameters.importDataEncryptionKeyParamsRoute,
				),
			},
			initOverrides,
		);

		return new runtime.JSONApiResponse(response, (jsonValue) =>
			DataEncryptionKeyFromJSON(jsonValue),
		);
	}

	/**
	 * Import an existing pre-encrypted data encryption key into the system
	 * Import data key
	 */
	async importDataEncryptionKey(
		requestParameters: V1ApiImportDataEncryptionKeyRequest,
		initOverrides?: RequestInit | runtime.InitOverrideFunction,
	): Promise<DataEncryptionKey> {
		const response = await this.importDataEncryptionKeyRaw(
			requestParameters,
			initOverrides,
		);
		return await response.value();
	}

	/**
	 * Import an existing pre-encrypted secret into the system
	 * Import secret
	 */
	async importSecretRaw(
		requestParameters: V1ApiImportSecretOperationRequest,
		initOverrides?: RequestInit | runtime.InitOverrideFunction,
	): Promise<runtime.ApiResponse<Secret>> {
		if (requestParameters.importSecretRequest == null) {
			throw new runtime.RequiredError(
				"importSecretRequest",
				'Required parameter "importSecretRequest" was null or undefined when calling importSecret().',
			);
		}

		const queryParameters: any = {};

		const headerParameters: runtime.HTTPHeaders = {};

		headerParameters["Content-Type"] = "application/json";

		if (this.configuration?.accessToken) {
			const token = this.configuration.accessToken;
			const tokenString = await token("bearer_token", []);

			if (tokenString) {
				headerParameters.Authorization = `Bearer ${tokenString}`;
			}
		}
		if (this.configuration?.apiKey) {
			headerParameters["X-API-Key"] =
				await this.configuration.apiKey("X-API-Key"); // api_key authentication
		}

		const urlPath = `/api/environment/v1/secret/import`;

		const response = await this.request(
			{
				path: urlPath,
				method: "POST",
				headers: headerParameters,
				query: queryParameters,
				body: ImportSecretRequestToJSON(requestParameters.importSecretRequest),
			},
			initOverrides,
		);

		return new runtime.JSONApiResponse(response, (jsonValue) =>
			SecretFromJSON(jsonValue),
		);
	}

	/**
	 * Import an existing pre-encrypted secret into the system
	 * Import secret
	 */
	async importSecret(
		requestParameters: V1ApiImportSecretOperationRequest,
		initOverrides?: RequestInit | runtime.InitOverrideFunction,
	): Promise<Secret> {
		const response = await this.importSecretRaw(
			requestParameters,
			initOverrides,
		);
		return await response.value();
	}

	/**
	 * Import an existing environment variable into the system
	 * Import variable
	 */
	async importVariableRaw(
		requestParameters: V1ApiImportVariableOperationRequest,
		initOverrides?: RequestInit | runtime.InitOverrideFunction,
	): Promise<runtime.ApiResponse<Variable>> {
		if (requestParameters.importVariableRequest == null) {
			throw new runtime.RequiredError(
				"importVariableRequest",
				'Required parameter "importVariableRequest" was null or undefined when calling importVariable().',
			);
		}

		const queryParameters: any = {};

		const headerParameters: runtime.HTTPHeaders = {};

		headerParameters["Content-Type"] = "application/json";

		if (this.configuration?.accessToken) {
			const token = this.configuration.accessToken;
			const tokenString = await token("bearer_token", []);

			if (tokenString) {
				headerParameters.Authorization = `Bearer ${tokenString}`;
			}
		}
		if (this.configuration?.apiKey) {
			headerParameters["X-API-Key"] =
				await this.configuration.apiKey("X-API-Key"); // api_key authentication
		}

		const urlPath = `/api/environment/v1/variable/import`;

		const response = await this.request(
			{
				path: urlPath,
				method: "POST",
				headers: headerParameters,
				query: queryParameters,
				body: ImportVariableRequestToJSON(
					requestParameters.importVariableRequest,
				),
			},
			initOverrides,
		);

		return new runtime.JSONApiResponse(response, (jsonValue) =>
			VariableFromJSON(jsonValue),
		);
	}

	/**
	 * Import an existing environment variable into the system
	 * Import variable
	 */
	async importVariable(
		requestParameters: V1ApiImportVariableOperationRequest,
		initOverrides?: RequestInit | runtime.InitOverrideFunction,
	): Promise<Variable> {
		const response = await this.importVariableRaw(
			requestParameters,
			initOverrides,
		);
		return await response.value();
	}

	/**
	 * Invoke a function on a provider instance
	 * Invoke function
	 */
	async invokeFunctionRaw(
		requestParameters: V1ApiInvokeFunctionRequest,
		initOverrides?: RequestInit | runtime.InitOverrideFunction,
	): Promise<runtime.ApiResponse<InvokeResult>> {
		if (requestParameters.providerInstanceId == null) {
			throw new runtime.RequiredError(
				"providerInstanceId",
				'Required parameter "providerInstanceId" was null or undefined when calling invokeFunction().',
			);
		}

		if (requestParameters.functionControllerTypeId == null) {
			throw new runtime.RequiredError(
				"functionControllerTypeId",
				'Required parameter "functionControllerTypeId" was null or undefined when calling invokeFunction().',
			);
		}

		if (requestParameters.invokeFunctionParamsInner == null) {
			throw new runtime.RequiredError(
				"invokeFunctionParamsInner",
				'Required parameter "invokeFunctionParamsInner" was null or undefined when calling invokeFunction().',
			);
		}

		const queryParameters: any = {};

		const headerParameters: runtime.HTTPHeaders = {};

		headerParameters["Content-Type"] = "application/json";

		if (this.configuration?.accessToken) {
			const token = this.configuration.accessToken;
			const tokenString = await token("bearer_token", []);

			if (tokenString) {
				headerParameters.Authorization = `Bearer ${tokenString}`;
			}
		}
		if (this.configuration?.apiKey) {
			headerParameters["X-API-Key"] =
				await this.configuration.apiKey("X-API-Key"); // api_key authentication
		}

		let urlPath = `/api/mcp/v1/provider/{provider_instance_id}/function/{function_controller_type_id}/invoke`;
		urlPath = urlPath.replace(
			`{${"provider_instance_id"}}`,
			encodeURIComponent(String(requestParameters.providerInstanceId)),
		);
		urlPath = urlPath.replace(
			`{${"function_controller_type_id"}}`,
			encodeURIComponent(String(requestParameters.functionControllerTypeId)),
		);

		const response = await this.request(
			{
				path: urlPath,
				method: "POST",
				headers: headerParameters,
				query: queryParameters,
				body: InvokeFunctionParamsInnerToJSON(
					requestParameters.invokeFunctionParamsInner,
				),
			},
			initOverrides,
		);

		return new runtime.JSONApiResponse(response, (jsonValue) =>
			InvokeResultFromJSON(jsonValue),
		);
	}

	/**
	 * Invoke a function on a provider instance
	 * Invoke function
	 */
	async invokeFunction(
		requestParameters: V1ApiInvokeFunctionRequest,
		initOverrides?: RequestInit | runtime.InitOverrideFunction,
	): Promise<InvokeResult> {
		const response = await this.invokeFunctionRaw(
			requestParameters,
			initOverrides,
		);
		return await response.value();
	}

	/**
	 * List all available agents from the agent cache
	 * List available agents
	 */
	async listAgentsRaw(
		initOverrides?: RequestInit | runtime.InitOverrideFunction,
	): Promise<runtime.ApiResponse<ListAgentsResponse>> {
		const queryParameters: any = {};

		const headerParameters: runtime.HTTPHeaders = {};

		if (this.configuration?.accessToken) {
			const token = this.configuration.accessToken;
			const tokenString = await token("bearer_token", []);

			if (tokenString) {
				headerParameters.Authorization = `Bearer ${tokenString}`;
			}
		}
		if (this.configuration?.apiKey) {
			headerParameters["X-API-Key"] =
				await this.configuration.apiKey("X-API-Key"); // api_key authentication
		}

		const urlPath = `/api/agent`;

		const response = await this.request(
			{
				path: urlPath,
				method: "GET",
				headers: headerParameters,
				query: queryParameters,
			},
			initOverrides,
		);

		return new runtime.JSONApiResponse(response, (jsonValue) =>
			ListAgentsResponseFromJSON(jsonValue),
		);
	}

	/**
	 * List all available agents from the agent cache
	 * List available agents
	 */
	async listAgents(
		initOverrides?: RequestInit | runtime.InitOverrideFunction,
	): Promise<ListAgentsResponse> {
		const response = await this.listAgentsRaw(initOverrides);
		return await response.value();
	}

	/**
	 * List all available provider types that can be instantiated
	 * List providers
	 */
	async listAvailableProvidersRaw(
		requestParameters: V1ApiListAvailableProvidersRequest,
		initOverrides?: RequestInit | runtime.InitOverrideFunction,
	): Promise<
		runtime.ApiResponse<ProviderControllerSerializedPaginatedResponse>
	> {
		if (requestParameters.pageSize == null) {
			throw new runtime.RequiredError(
				"pageSize",
				'Required parameter "pageSize" was null or undefined when calling listAvailableProviders().',
			);
		}

		const queryParameters: any = {};

		if (requestParameters.pageSize != null) {
			queryParameters.page_size = requestParameters.pageSize;
		}

		if (requestParameters.nextPageToken != null) {
			queryParameters.next_page_token = requestParameters.nextPageToken;
		}

		const headerParameters: runtime.HTTPHeaders = {};

		if (this.configuration?.accessToken) {
			const token = this.configuration.accessToken;
			const tokenString = await token("bearer_token", []);

			if (tokenString) {
				headerParameters.Authorization = `Bearer ${tokenString}`;
			}
		}
		if (this.configuration?.apiKey) {
			headerParameters["X-API-Key"] =
				await this.configuration.apiKey("X-API-Key"); // api_key authentication
		}

		const urlPath = `/api/mcp/v1/available-providers`;

		const response = await this.request(
			{
				path: urlPath,
				method: "GET",
				headers: headerParameters,
				query: queryParameters,
			},
			initOverrides,
		);

		return new runtime.JSONApiResponse(response, (jsonValue) =>
			ProviderControllerSerializedPaginatedResponseFromJSON(jsonValue),
		);
	}

	/**
	 * List all available provider types that can be instantiated
	 * List providers
	 */
	async listAvailableProviders(
		requestParameters: V1ApiListAvailableProvidersRequest,
		initOverrides?: RequestInit | runtime.InitOverrideFunction,
	): Promise<ProviderControllerSerializedPaginatedResponse> {
		const response = await this.listAvailableProvidersRaw(
			requestParameters,
			initOverrides,
		);
		return await response.value();
	}

	/**
	 * List all unique task contexts with pagination
	 * List contexts
	 */
	async listContextsRaw(
		requestParameters: V1ApiListContextsRequest,
		initOverrides?: RequestInit | runtime.InitOverrideFunction,
	): Promise<runtime.ApiResponse<ContextInfoPaginatedResponse>> {
		if (requestParameters.pageSize == null) {
			throw new runtime.RequiredError(
				"pageSize",
				'Required parameter "pageSize" was null or undefined when calling listContexts().',
			);
		}

		const queryParameters: any = {};

		if (requestParameters.pageSize != null) {
			queryParameters.page_size = requestParameters.pageSize;
		}

		if (requestParameters.nextPageToken != null) {
			queryParameters.next_page_token = requestParameters.nextPageToken;
		}

		const headerParameters: runtime.HTTPHeaders = {};

		if (this.configuration?.accessToken) {
			const token = this.configuration.accessToken;
			const tokenString = await token("bearer_token", []);

			if (tokenString) {
				headerParameters.Authorization = `Bearer ${tokenString}`;
			}
		}
		if (this.configuration?.apiKey) {
			headerParameters["X-API-Key"] =
				await this.configuration.apiKey("X-API-Key"); // api_key authentication
		}

		const urlPath = `/api/task/v1/context`;

		const response = await this.request(
			{
				path: urlPath,
				method: "GET",
				headers: headerParameters,
				query: queryParameters,
			},
			initOverrides,
		);

		return new runtime.JSONApiResponse(response, (jsonValue) =>
			ContextInfoPaginatedResponseFromJSON(jsonValue),
		);
	}

	/**
	 * List all unique task contexts with pagination
	 * List contexts
	 */
	async listContexts(
		requestParameters: V1ApiListContextsRequest,
		initOverrides?: RequestInit | runtime.InitOverrideFunction,
	): Promise<ContextInfoPaginatedResponse> {
		const response = await this.listContextsRaw(
			requestParameters,
			initOverrides,
		);
		return await response.value();
	}

	/**
	 * List all data encryption keys encrypted with the specified envelope encryption key
	 * List data keys
	 */
	async listDataEncryptionKeysByEnvelopeRaw(
		requestParameters: V1ApiListDataEncryptionKeysByEnvelopeRequest,
		initOverrides?: RequestInit | runtime.InitOverrideFunction,
	): Promise<runtime.ApiResponse<DataEncryptionKeyListItemPaginatedResponse>> {
		if (requestParameters.envelopeId == null) {
			throw new runtime.RequiredError(
				"envelopeId",
				'Required parameter "envelopeId" was null or undefined when calling listDataEncryptionKeysByEnvelope().',
			);
		}

		if (requestParameters.pageSize == null) {
			throw new runtime.RequiredError(
				"pageSize",
				'Required parameter "pageSize" was null or undefined when calling listDataEncryptionKeysByEnvelope().',
			);
		}

		const queryParameters: any = {};

		if (requestParameters.pageSize != null) {
			queryParameters.page_size = requestParameters.pageSize;
		}

		if (requestParameters.nextPageToken != null) {
			queryParameters.next_page_token = requestParameters.nextPageToken;
		}

		const headerParameters: runtime.HTTPHeaders = {};

		if (this.configuration?.accessToken) {
			const token = this.configuration.accessToken;
			const tokenString = await token("bearer_token", []);

			if (tokenString) {
				headerParameters.Authorization = `Bearer ${tokenString}`;
			}
		}
		if (this.configuration?.apiKey) {
			headerParameters["X-API-Key"] =
				await this.configuration.apiKey("X-API-Key"); // api_key authentication
		}

		let urlPath = `/api/encryption/v1/envelope/{envelope_id}/dek`;
		urlPath = urlPath.replace(
			`{${"envelope_id"}}`,
			encodeURIComponent(String(requestParameters.envelopeId)),
		);

		const response = await this.request(
			{
				path: urlPath,
				method: "GET",
				headers: headerParameters,
				query: queryParameters,
			},
			initOverrides,
		);

		return new runtime.JSONApiResponse(response, (jsonValue) =>
			DataEncryptionKeyListItemPaginatedResponseFromJSON(jsonValue),
		);
	}

	/**
	 * List all data encryption keys encrypted with the specified envelope encryption key
	 * List data keys
	 */
	async listDataEncryptionKeysByEnvelope(
		requestParameters: V1ApiListDataEncryptionKeysByEnvelopeRequest,
		initOverrides?: RequestInit | runtime.InitOverrideFunction,
	): Promise<DataEncryptionKeyListItemPaginatedResponse> {
		const response = await this.listDataEncryptionKeysByEnvelopeRaw(
			requestParameters,
			initOverrides,
		);
		return await response.value();
	}

	/**
	 * List all secrets with decrypted values (requires decryption access)
	 * List decrypted secrets
	 */
	async listDecryptedSecretsRaw(
		requestParameters: V1ApiListDecryptedSecretsRequest,
		initOverrides?: RequestInit | runtime.InitOverrideFunction,
	): Promise<runtime.ApiResponse<ListDecryptedSecretsResponse>> {
		if (requestParameters.pageSize == null) {
			throw new runtime.RequiredError(
				"pageSize",
				'Required parameter "pageSize" was null or undefined when calling listDecryptedSecrets().',
			);
		}

		const queryParameters: any = {};

		if (requestParameters.pageSize != null) {
			queryParameters.page_size = requestParameters.pageSize;
		}

		if (requestParameters.nextPageToken != null) {
			queryParameters.next_page_token = requestParameters.nextPageToken;
		}

		const headerParameters: runtime.HTTPHeaders = {};

		if (this.configuration?.accessToken) {
			const token = this.configuration.accessToken;
			const tokenString = await token("bearer_token", []);

			if (tokenString) {
				headerParameters.Authorization = `Bearer ${tokenString}`;
			}
		}
		if (this.configuration?.apiKey) {
			headerParameters["X-API-Key"] =
				await this.configuration.apiKey("X-API-Key"); // api_key authentication
		}

		const urlPath = `/api/environment/v1/secret/list-decrypted`;

		const response = await this.request(
			{
				path: urlPath,
				method: "GET",
				headers: headerParameters,
				query: queryParameters,
			},
			initOverrides,
		);

		return new runtime.JSONApiResponse(response, (jsonValue) =>
			ListDecryptedSecretsResponseFromJSON(jsonValue),
		);
	}

	/**
	 * List all secrets with decrypted values (requires decryption access)
	 * List decrypted secrets
	 */
	async listDecryptedSecrets(
		requestParameters: V1ApiListDecryptedSecretsRequest,
		initOverrides?: RequestInit | runtime.InitOverrideFunction,
	): Promise<ListDecryptedSecretsResponse> {
		const response = await this.listDecryptedSecretsRaw(
			requestParameters,
			initOverrides,
		);
		return await response.value();
	}

	/**
	 * List all envelope encryption keys (master keys) with pagination
	 * List envelope keys
	 */
	async listEnvelopeEncryptionKeysRaw(
		requestParameters: V1ApiListEnvelopeEncryptionKeysRequest,
		initOverrides?: RequestInit | runtime.InitOverrideFunction,
	): Promise<runtime.ApiResponse<EnvelopeEncryptionKeyPaginatedResponse>> {
		if (requestParameters.pageSize == null) {
			throw new runtime.RequiredError(
				"pageSize",
				'Required parameter "pageSize" was null or undefined when calling listEnvelopeEncryptionKeys().',
			);
		}

		const queryParameters: any = {};

		if (requestParameters.pageSize != null) {
			queryParameters.page_size = requestParameters.pageSize;
		}

		if (requestParameters.nextPageToken != null) {
			queryParameters.next_page_token = requestParameters.nextPageToken;
		}

		const headerParameters: runtime.HTTPHeaders = {};

		if (this.configuration?.accessToken) {
			const token = this.configuration.accessToken;
			const tokenString = await token("bearer_token", []);

			if (tokenString) {
				headerParameters.Authorization = `Bearer ${tokenString}`;
			}
		}
		if (this.configuration?.apiKey) {
			headerParameters["X-API-Key"] =
				await this.configuration.apiKey("X-API-Key"); // api_key authentication
		}

		const urlPath = `/api/encryption/v1/envelope`;

		const response = await this.request(
			{
				path: urlPath,
				method: "GET",
				headers: headerParameters,
				query: queryParameters,
			},
			initOverrides,
		);

		return new runtime.JSONApiResponse(response, (jsonValue) =>
			EnvelopeEncryptionKeyPaginatedResponseFromJSON(jsonValue),
		);
	}

	/**
	 * List all envelope encryption keys (master keys) with pagination
	 * List envelope keys
	 */
	async listEnvelopeEncryptionKeys(
		requestParameters: V1ApiListEnvelopeEncryptionKeysRequest,
		initOverrides?: RequestInit | runtime.InitOverrideFunction,
	): Promise<EnvelopeEncryptionKeyPaginatedResponse> {
		const response = await this.listEnvelopeEncryptionKeysRaw(
			requestParameters,
			initOverrides,
		);
		return await response.value();
	}

	/**
	 * List all function instances with optional filtering by provider instance
	 * List function instances
	 */
	async listFunctionInstancesRaw(
		requestParameters: V1ApiListFunctionInstancesRequest,
		initOverrides?: RequestInit | runtime.InitOverrideFunction,
	): Promise<runtime.ApiResponse<FunctionInstanceSerializedPaginatedResponse>> {
		if (requestParameters.pageSize == null) {
			throw new runtime.RequiredError(
				"pageSize",
				'Required parameter "pageSize" was null or undefined when calling listFunctionInstances().',
			);
		}

		const queryParameters: any = {};

		if (requestParameters.pageSize != null) {
			queryParameters.page_size = requestParameters.pageSize;
		}

		if (requestParameters.nextPageToken != null) {
			queryParameters.next_page_token = requestParameters.nextPageToken;
		}

		if (requestParameters.providerInstanceId != null) {
			queryParameters.provider_instance_id =
				requestParameters.providerInstanceId;
		}

		const headerParameters: runtime.HTTPHeaders = {};

		if (this.configuration?.accessToken) {
			const token = this.configuration.accessToken;
			const tokenString = await token("bearer_token", []);

			if (tokenString) {
				headerParameters.Authorization = `Bearer ${tokenString}`;
			}
		}
		if (this.configuration?.apiKey) {
			headerParameters["X-API-Key"] =
				await this.configuration.apiKey("X-API-Key"); // api_key authentication
		}

		const urlPath = `/api/mcp/v1/function-instances`;

		const response = await this.request(
			{
				path: urlPath,
				method: "GET",
				headers: headerParameters,
				query: queryParameters,
			},
			initOverrides,
		);

		return new runtime.JSONApiResponse(response, (jsonValue) =>
			FunctionInstanceSerializedPaginatedResponseFromJSON(jsonValue),
		);
	}

	/**
	 * List all function instances with optional filtering by provider instance
	 * List function instances
	 */
	async listFunctionInstances(
		requestParameters: V1ApiListFunctionInstancesRequest,
		initOverrides?: RequestInit | runtime.InitOverrideFunction,
	): Promise<FunctionInstanceSerializedPaginatedResponse> {
		const response = await this.listFunctionInstancesRaw(
			requestParameters,
			initOverrides,
		);
		return await response.value();
	}

	/**
	 * List all members of a group
	 * List group members
	 */
	async listGroupMembersRaw(
		requestParameters: V1ApiListGroupMembersRequest,
		initOverrides?: RequestInit | runtime.InitOverrideFunction,
	): Promise<runtime.ApiResponse<GroupMemberWithUserPaginatedResponse>> {
		if (requestParameters.groupId == null) {
			throw new runtime.RequiredError(
				"groupId",
				'Required parameter "groupId" was null or undefined when calling listGroupMembers().',
			);
		}

		if (requestParameters.pageSize == null) {
			throw new runtime.RequiredError(
				"pageSize",
				'Required parameter "pageSize" was null or undefined when calling listGroupMembers().',
			);
		}

		const queryParameters: any = {};

		if (requestParameters.pageSize != null) {
			queryParameters.page_size = requestParameters.pageSize;
		}

		if (requestParameters.nextPageToken != null) {
			queryParameters.next_page_token = requestParameters.nextPageToken;
		}

		const headerParameters: runtime.HTTPHeaders = {};

		if (this.configuration?.accessToken) {
			const token = this.configuration.accessToken;
			const tokenString = await token("bearer_token", []);

			if (tokenString) {
				headerParameters.Authorization = `Bearer ${tokenString}`;
			}
		}
		if (this.configuration?.apiKey) {
			headerParameters["X-API-Key"] =
				await this.configuration.apiKey("X-API-Key"); // api_key authentication
		}

		let urlPath = `/api/identity/v1/groups/{group_id}/members`;
		urlPath = urlPath.replace(
			`{${"group_id"}}`,
			encodeURIComponent(String(requestParameters.groupId)),
		);

		const response = await this.request(
			{
				path: urlPath,
				method: "GET",
				headers: headerParameters,
				query: queryParameters,
			},
			initOverrides,
		);

		return new runtime.JSONApiResponse(response, (jsonValue) =>
			GroupMemberWithUserPaginatedResponseFromJSON(jsonValue),
		);
	}

	/**
	 * List all members of a group
	 * List group members
	 */
	async listGroupMembers(
		requestParameters: V1ApiListGroupMembersRequest,
		initOverrides?: RequestInit | runtime.InitOverrideFunction,
	): Promise<GroupMemberWithUserPaginatedResponse> {
		const response = await this.listGroupMembersRaw(
			requestParameters,
			initOverrides,
		);
		return await response.value();
	}

	/**
	 * List all groups with pagination
	 * List groups
	 */
	async listGroupsRaw(
		requestParameters: V1ApiListGroupsRequest,
		initOverrides?: RequestInit | runtime.InitOverrideFunction,
	): Promise<runtime.ApiResponse<GroupPaginatedResponse>> {
		if (requestParameters.pageSize == null) {
			throw new runtime.RequiredError(
				"pageSize",
				'Required parameter "pageSize" was null or undefined when calling listGroups().',
			);
		}

		const queryParameters: any = {};

		if (requestParameters.pageSize != null) {
			queryParameters.page_size = requestParameters.pageSize;
		}

		if (requestParameters.nextPageToken != null) {
			queryParameters.next_page_token = requestParameters.nextPageToken;
		}

		const headerParameters: runtime.HTTPHeaders = {};

		if (this.configuration?.accessToken) {
			const token = this.configuration.accessToken;
			const tokenString = await token("bearer_token", []);

			if (tokenString) {
				headerParameters.Authorization = `Bearer ${tokenString}`;
			}
		}
		if (this.configuration?.apiKey) {
			headerParameters["X-API-Key"] =
				await this.configuration.apiKey("X-API-Key"); // api_key authentication
		}

		const urlPath = `/api/identity/v1/groups`;

		const response = await this.request(
			{
				path: urlPath,
				method: "GET",
				headers: headerParameters,
				query: queryParameters,
			},
			initOverrides,
		);

		return new runtime.JSONApiResponse(response, (jsonValue) =>
			GroupPaginatedResponseFromJSON(jsonValue),
		);
	}

	/**
	 * List all groups with pagination
	 * List groups
	 */
	async listGroups(
		requestParameters: V1ApiListGroupsRequest,
		initOverrides?: RequestInit | runtime.InitOverrideFunction,
	): Promise<GroupPaginatedResponse> {
		const response = await this.listGroupsRaw(requestParameters, initOverrides);
		return await response.value();
	}

	/**
	 * List all MCP server instances with pagination
	 * List MCP server instances
	 */
	async listMcpServerInstancesRaw(
		requestParameters: V1ApiListMcpServerInstancesRequest,
		initOverrides?: RequestInit | runtime.InitOverrideFunction,
	): Promise<
		runtime.ApiResponse<McpServerInstanceSerializedWithFunctionsPaginatedResponse>
	> {
		if (requestParameters.pageSize == null) {
			throw new runtime.RequiredError(
				"pageSize",
				'Required parameter "pageSize" was null or undefined when calling listMcpServerInstances().',
			);
		}

		const queryParameters: any = {};

		if (requestParameters.pageSize != null) {
			queryParameters.page_size = requestParameters.pageSize;
		}

		if (requestParameters.nextPageToken != null) {
			queryParameters.next_page_token = requestParameters.nextPageToken;
		}

		const headerParameters: runtime.HTTPHeaders = {};

		if (this.configuration?.accessToken) {
			const token = this.configuration.accessToken;
			const tokenString = await token("bearer_token", []);

			if (tokenString) {
				headerParameters.Authorization = `Bearer ${tokenString}`;
			}
		}
		if (this.configuration?.apiKey) {
			headerParameters["X-API-Key"] =
				await this.configuration.apiKey("X-API-Key"); // api_key authentication
		}

		const urlPath = `/api/mcp/v1/mcp-server`;

		const response = await this.request(
			{
				path: urlPath,
				method: "GET",
				headers: headerParameters,
				query: queryParameters,
			},
			initOverrides,
		);

		return new runtime.JSONApiResponse(response, (jsonValue) =>
			McpServerInstanceSerializedWithFunctionsPaginatedResponseFromJSON(
				jsonValue,
			),
		);
	}

	/**
	 * List all MCP server instances with pagination
	 * List MCP server instances
	 */
	async listMcpServerInstances(
		requestParameters: V1ApiListMcpServerInstancesRequest,
		initOverrides?: RequestInit | runtime.InitOverrideFunction,
	): Promise<McpServerInstanceSerializedWithFunctionsPaginatedResponse> {
		const response = await this.listMcpServerInstancesRaw(
			requestParameters,
			initOverrides,
		);
		return await response.value();
	}

	/**
	 * List all provider instances with optional filtering by status and provider type
	 * List provider instances
	 */
	async listProviderInstancesRaw(
		requestParameters: V1ApiListProviderInstancesRequest,
		initOverrides?: RequestInit | runtime.InitOverrideFunction,
	): Promise<runtime.ApiResponse<ProviderInstanceListItemPaginatedResponse>> {
		if (requestParameters.pageSize == null) {
			throw new runtime.RequiredError(
				"pageSize",
				'Required parameter "pageSize" was null or undefined when calling listProviderInstances().',
			);
		}

		const queryParameters: any = {};

		if (requestParameters.pageSize != null) {
			queryParameters.page_size = requestParameters.pageSize;
		}

		if (requestParameters.nextPageToken != null) {
			queryParameters.next_page_token = requestParameters.nextPageToken;
		}

		if (requestParameters.status != null) {
			queryParameters.status = requestParameters.status;
		}

		if (requestParameters.providerControllerTypeId != null) {
			queryParameters.provider_controller_type_id =
				requestParameters.providerControllerTypeId;
		}

		const headerParameters: runtime.HTTPHeaders = {};

		if (this.configuration?.accessToken) {
			const token = this.configuration.accessToken;
			const tokenString = await token("bearer_token", []);

			if (tokenString) {
				headerParameters.Authorization = `Bearer ${tokenString}`;
			}
		}
		if (this.configuration?.apiKey) {
			headerParameters["X-API-Key"] =
				await this.configuration.apiKey("X-API-Key"); // api_key authentication
		}

		const urlPath = `/api/mcp/v1/provider`;

		const response = await this.request(
			{
				path: urlPath,
				method: "GET",
				headers: headerParameters,
				query: queryParameters,
			},
			initOverrides,
		);

		return new runtime.JSONApiResponse(response, (jsonValue) =>
			ProviderInstanceListItemPaginatedResponseFromJSON(jsonValue),
		);
	}

	/**
	 * List all provider instances with optional filtering by status and provider type
	 * List provider instances
	 */
	async listProviderInstances(
		requestParameters: V1ApiListProviderInstancesRequest,
		initOverrides?: RequestInit | runtime.InitOverrideFunction,
	): Promise<ProviderInstanceListItemPaginatedResponse> {
		const response = await this.listProviderInstancesRaw(
			requestParameters,
			initOverrides,
		);
		return await response.value();
	}

	/**
	 * List provider instances grouped by their associated functions
	 * List providers by function
	 */
	async listProviderInstancesGroupedByFunctionRaw(
		requestParameters: V1ApiListProviderInstancesGroupedByFunctionRequest,
		initOverrides?: RequestInit | runtime.InitOverrideFunction,
	): Promise<runtime.ApiResponse<FunctionInstanceConfigPaginatedResponse>> {
		if (requestParameters.pageSize == null) {
			throw new runtime.RequiredError(
				"pageSize",
				'Required parameter "pageSize" was null or undefined when calling listProviderInstancesGroupedByFunction().',
			);
		}

		const queryParameters: any = {};

		if (requestParameters.nextPageToken != null) {
			queryParameters.next_page_token = requestParameters.nextPageToken;
		}

		if (requestParameters.pageSize != null) {
			queryParameters.page_size = requestParameters.pageSize;
		}

		if (requestParameters.providerControllerTypeId != null) {
			queryParameters.provider_controller_type_id =
				requestParameters.providerControllerTypeId;
		}

		if (requestParameters.functionCategory != null) {
			queryParameters.function_category = requestParameters.functionCategory;
		}

		const headerParameters: runtime.HTTPHeaders = {};

		if (this.configuration?.accessToken) {
			const token = this.configuration.accessToken;
			const tokenString = await token("bearer_token", []);

			if (tokenString) {
				headerParameters.Authorization = `Bearer ${tokenString}`;
			}
		}
		if (this.configuration?.apiKey) {
			headerParameters["X-API-Key"] =
				await this.configuration.apiKey("X-API-Key"); // api_key authentication
		}

		const urlPath = `/api/mcp/v1/provider/grouped-by-function`;

		const response = await this.request(
			{
				path: urlPath,
				method: "GET",
				headers: headerParameters,
				query: queryParameters,
			},
			initOverrides,
		);

		return new runtime.JSONApiResponse(response, (jsonValue) =>
			FunctionInstanceConfigPaginatedResponseFromJSON(jsonValue),
		);
	}

	/**
	 * List provider instances grouped by their associated functions
	 * List providers by function
	 */
	async listProviderInstancesGroupedByFunction(
		requestParameters: V1ApiListProviderInstancesGroupedByFunctionRequest,
		initOverrides?: RequestInit | runtime.InitOverrideFunction,
	): Promise<FunctionInstanceConfigPaginatedResponse> {
		const response = await this.listProviderInstancesGroupedByFunctionRaw(
			requestParameters,
			initOverrides,
		);
		return await response.value();
	}

	/**
	 * List all secrets with pagination (values are encrypted)
	 * List secrets
	 */
	async listSecretsRaw(
		requestParameters: V1ApiListSecretsRequest,
		initOverrides?: RequestInit | runtime.InitOverrideFunction,
	): Promise<runtime.ApiResponse<ListSecretsResponse>> {
		if (requestParameters.pageSize == null) {
			throw new runtime.RequiredError(
				"pageSize",
				'Required parameter "pageSize" was null or undefined when calling listSecrets().',
			);
		}

		const queryParameters: any = {};

		if (requestParameters.pageSize != null) {
			queryParameters.page_size = requestParameters.pageSize;
		}

		if (requestParameters.nextPageToken != null) {
			queryParameters.next_page_token = requestParameters.nextPageToken;
		}

		const headerParameters: runtime.HTTPHeaders = {};

		if (this.configuration?.accessToken) {
			const token = this.configuration.accessToken;
			const tokenString = await token("bearer_token", []);

			if (tokenString) {
				headerParameters.Authorization = `Bearer ${tokenString}`;
			}
		}
		if (this.configuration?.apiKey) {
			headerParameters["X-API-Key"] =
				await this.configuration.apiKey("X-API-Key"); // api_key authentication
		}

		const urlPath = `/api/environment/v1/secret`;

		const response = await this.request(
			{
				path: urlPath,
				method: "GET",
				headers: headerParameters,
				query: queryParameters,
			},
			initOverrides,
		);

		return new runtime.JSONApiResponse(response, (jsonValue) =>
			ListSecretsResponseFromJSON(jsonValue),
		);
	}

	/**
	 * List all secrets with pagination (values are encrypted)
	 * List secrets
	 */
	async listSecrets(
		requestParameters: V1ApiListSecretsRequest,
		initOverrides?: RequestInit | runtime.InitOverrideFunction,
	): Promise<ListSecretsResponse> {
		const response = await this.listSecretsRaw(
			requestParameters,
			initOverrides,
		);
		return await response.value();
	}

	/**
	 * List all tasks with pagination
	 * List tasks
	 */
	async listTasksRaw(
		requestParameters: V1ApiListTasksRequest,
		initOverrides?: RequestInit | runtime.InitOverrideFunction,
	): Promise<runtime.ApiResponse<TaskPaginatedResponse>> {
		if (requestParameters.pageSize == null) {
			throw new runtime.RequiredError(
				"pageSize",
				'Required parameter "pageSize" was null or undefined when calling listTasks().',
			);
		}

		const queryParameters: any = {};

		if (requestParameters.pageSize != null) {
			queryParameters.page_size = requestParameters.pageSize;
		}

		if (requestParameters.nextPageToken != null) {
			queryParameters.next_page_token = requestParameters.nextPageToken;
		}

		const headerParameters: runtime.HTTPHeaders = {};

		if (this.configuration?.accessToken) {
			const token = this.configuration.accessToken;
			const tokenString = await token("bearer_token", []);

			if (tokenString) {
				headerParameters.Authorization = `Bearer ${tokenString}`;
			}
		}
		if (this.configuration?.apiKey) {
			headerParameters["X-API-Key"] =
				await this.configuration.apiKey("X-API-Key"); // api_key authentication
		}

		const urlPath = `/api/task/v1`;

		const response = await this.request(
			{
				path: urlPath,
				method: "GET",
				headers: headerParameters,
				query: queryParameters,
			},
			initOverrides,
		);

		return new runtime.JSONApiResponse(response, (jsonValue) =>
			TaskPaginatedResponseFromJSON(jsonValue),
		);
	}

	/**
	 * List all tasks with pagination
	 * List tasks
	 */
	async listTasks(
		requestParameters: V1ApiListTasksRequest,
		initOverrides?: RequestInit | runtime.InitOverrideFunction,
	): Promise<TaskPaginatedResponse> {
		const response = await this.listTasksRaw(requestParameters, initOverrides);
		return await response.value();
	}

	/**
	 * List all tasks for a specific context ID with pagination
	 * List tasks by context
	 */
	async listTasksByContextIdRaw(
		requestParameters: V1ApiListTasksByContextIdRequest,
		initOverrides?: RequestInit | runtime.InitOverrideFunction,
	): Promise<runtime.ApiResponse<TaskPaginatedResponse>> {
		if (requestParameters.pageSize == null) {
			throw new runtime.RequiredError(
				"pageSize",
				'Required parameter "pageSize" was null or undefined when calling listTasksByContextId().',
			);
		}

		if (requestParameters.contextId == null) {
			throw new runtime.RequiredError(
				"contextId",
				'Required parameter "contextId" was null or undefined when calling listTasksByContextId().',
			);
		}

		const queryParameters: any = {};

		if (requestParameters.pageSize != null) {
			queryParameters.page_size = requestParameters.pageSize;
		}

		if (requestParameters.nextPageToken != null) {
			queryParameters.next_page_token = requestParameters.nextPageToken;
		}

		const headerParameters: runtime.HTTPHeaders = {};

		if (this.configuration?.accessToken) {
			const token = this.configuration.accessToken;
			const tokenString = await token("bearer_token", []);

			if (tokenString) {
				headerParameters.Authorization = `Bearer ${tokenString}`;
			}
		}
		if (this.configuration?.apiKey) {
			headerParameters["X-API-Key"] =
				await this.configuration.apiKey("X-API-Key"); // api_key authentication
		}

		let urlPath = `/api/task/v1/context/{context_id}/task`;
		urlPath = urlPath.replace(
			`{${"context_id"}}`,
			encodeURIComponent(String(requestParameters.contextId)),
		);

		const response = await this.request(
			{
				path: urlPath,
				method: "GET",
				headers: headerParameters,
				query: queryParameters,
			},
			initOverrides,
		);

		return new runtime.JSONApiResponse(response, (jsonValue) =>
			TaskPaginatedResponseFromJSON(jsonValue),
		);
	}

	/**
	 * List all tasks for a specific context ID with pagination
	 * List tasks by context
	 */
	async listTasksByContextId(
		requestParameters: V1ApiListTasksByContextIdRequest,
		initOverrides?: RequestInit | runtime.InitOverrideFunction,
	): Promise<TaskPaginatedResponse> {
		const response = await this.listTasksByContextIdRaw(
			requestParameters,
			initOverrides,
		);
		return await response.value();
	}

	/**
	 * List all groups that a user belongs to
	 * List user groups
	 */
	async listUserGroupsRaw(
		requestParameters: V1ApiListUserGroupsRequest,
		initOverrides?: RequestInit | runtime.InitOverrideFunction,
	): Promise<runtime.ApiResponse<UserGroupWithGroupPaginatedResponse>> {
		if (requestParameters.userId == null) {
			throw new runtime.RequiredError(
				"userId",
				'Required parameter "userId" was null or undefined when calling listUserGroups().',
			);
		}

		if (requestParameters.pageSize == null) {
			throw new runtime.RequiredError(
				"pageSize",
				'Required parameter "pageSize" was null or undefined when calling listUserGroups().',
			);
		}

		const queryParameters: any = {};

		if (requestParameters.pageSize != null) {
			queryParameters.page_size = requestParameters.pageSize;
		}

		if (requestParameters.nextPageToken != null) {
			queryParameters.next_page_token = requestParameters.nextPageToken;
		}

		const headerParameters: runtime.HTTPHeaders = {};

		if (this.configuration?.accessToken) {
			const token = this.configuration.accessToken;
			const tokenString = await token("bearer_token", []);

			if (tokenString) {
				headerParameters.Authorization = `Bearer ${tokenString}`;
			}
		}
		if (this.configuration?.apiKey) {
			headerParameters["X-API-Key"] =
				await this.configuration.apiKey("X-API-Key"); // api_key authentication
		}

		let urlPath = `/api/identity/v1/users/{user_id}/groups`;
		urlPath = urlPath.replace(
			`{${"user_id"}}`,
			encodeURIComponent(String(requestParameters.userId)),
		);

		const response = await this.request(
			{
				path: urlPath,
				method: "GET",
				headers: headerParameters,
				query: queryParameters,
			},
			initOverrides,
		);

		return new runtime.JSONApiResponse(response, (jsonValue) =>
			UserGroupWithGroupPaginatedResponseFromJSON(jsonValue),
		);
	}

	/**
	 * List all groups that a user belongs to
	 * List user groups
	 */
	async listUserGroups(
		requestParameters: V1ApiListUserGroupsRequest,
		initOverrides?: RequestInit | runtime.InitOverrideFunction,
	): Promise<UserGroupWithGroupPaginatedResponse> {
		const response = await this.listUserGroupsRaw(
			requestParameters,
			initOverrides,
		);
		return await response.value();
	}

	/**
	 * List all users with pagination and optional filtering
	 * List users
	 */
	async listUsersRaw(
		requestParameters: V1ApiListUsersRequest,
		initOverrides?: RequestInit | runtime.InitOverrideFunction,
	): Promise<runtime.ApiResponse<UserPaginatedResponse>> {
		if (requestParameters.pageSize == null) {
			throw new runtime.RequiredError(
				"pageSize",
				'Required parameter "pageSize" was null or undefined when calling listUsers().',
			);
		}

		const queryParameters: any = {};

		if (requestParameters.pageSize != null) {
			queryParameters.page_size = requestParameters.pageSize;
		}

		if (requestParameters.nextPageToken != null) {
			queryParameters.next_page_token = requestParameters.nextPageToken;
		}

		if (requestParameters.userType != null) {
			queryParameters.user_type = requestParameters.userType;
		}

		if (requestParameters.role != null) {
			queryParameters.role = requestParameters.role;
		}

		const headerParameters: runtime.HTTPHeaders = {};

		if (this.configuration?.accessToken) {
			const token = this.configuration.accessToken;
			const tokenString = await token("bearer_token", []);

			if (tokenString) {
				headerParameters.Authorization = `Bearer ${tokenString}`;
			}
		}
		if (this.configuration?.apiKey) {
			headerParameters["X-API-Key"] =
				await this.configuration.apiKey("X-API-Key"); // api_key authentication
		}

		const urlPath = `/api/identity/v1/users`;

		const response = await this.request(
			{
				path: urlPath,
				method: "GET",
				headers: headerParameters,
				query: queryParameters,
			},
			initOverrides,
		);

		return new runtime.JSONApiResponse(response, (jsonValue) =>
			UserPaginatedResponseFromJSON(jsonValue),
		);
	}

	/**
	 * List all users with pagination and optional filtering
	 * List users
	 */
	async listUsers(
		requestParameters: V1ApiListUsersRequest,
		initOverrides?: RequestInit | runtime.InitOverrideFunction,
	): Promise<UserPaginatedResponse> {
		const response = await this.listUsersRaw(requestParameters, initOverrides);
		return await response.value();
	}

	/**
	 * List all environment variables with pagination
	 * List variables
	 */
	async listVariablesRaw(
		requestParameters: V1ApiListVariablesRequest,
		initOverrides?: RequestInit | runtime.InitOverrideFunction,
	): Promise<runtime.ApiResponse<ListVariablesResponse>> {
		if (requestParameters.pageSize == null) {
			throw new runtime.RequiredError(
				"pageSize",
				'Required parameter "pageSize" was null or undefined when calling listVariables().',
			);
		}

		const queryParameters: any = {};

		if (requestParameters.pageSize != null) {
			queryParameters.page_size = requestParameters.pageSize;
		}

		if (requestParameters.nextPageToken != null) {
			queryParameters.next_page_token = requestParameters.nextPageToken;
		}

		const headerParameters: runtime.HTTPHeaders = {};

		if (this.configuration?.accessToken) {
			const token = this.configuration.accessToken;
			const tokenString = await token("bearer_token", []);

			if (tokenString) {
				headerParameters.Authorization = `Bearer ${tokenString}`;
			}
		}
		if (this.configuration?.apiKey) {
			headerParameters["X-API-Key"] =
				await this.configuration.apiKey("X-API-Key"); // api_key authentication
		}

		const urlPath = `/api/environment/v1/variable`;

		const response = await this.request(
			{
				path: urlPath,
				method: "GET",
				headers: headerParameters,
				query: queryParameters,
			},
			initOverrides,
		);

		return new runtime.JSONApiResponse(response, (jsonValue) =>
			ListVariablesResponseFromJSON(jsonValue),
		);
	}

	/**
	 * List all environment variables with pagination
	 * List variables
	 */
	async listVariables(
		requestParameters: V1ApiListVariablesRequest,
		initOverrides?: RequestInit | runtime.InitOverrideFunction,
	): Promise<ListVariablesResponse> {
		const response = await this.listVariablesRaw(
			requestParameters,
			initOverrides,
		);
		return await response.value();
	}

	/**
	 * Migrate all data encryption keys encrypted with the specified envelope key to a new envelope key
	 * Migrate all data keys
	 */
	async migrateAllDataEncryptionKeysRaw(
		requestParameters: V1ApiMigrateAllDataEncryptionKeysRequest,
		initOverrides?: RequestInit | runtime.InitOverrideFunction,
	): Promise<runtime.ApiResponse<void>> {
		if (requestParameters.envelopeId == null) {
			throw new runtime.RequiredError(
				"envelopeId",
				'Required parameter "envelopeId" was null or undefined when calling migrateAllDataEncryptionKeys().',
			);
		}

		if (requestParameters.migrateAllDataEncryptionKeysParamsRoute == null) {
			throw new runtime.RequiredError(
				"migrateAllDataEncryptionKeysParamsRoute",
				'Required parameter "migrateAllDataEncryptionKeysParamsRoute" was null or undefined when calling migrateAllDataEncryptionKeys().',
			);
		}

		const queryParameters: any = {};

		const headerParameters: runtime.HTTPHeaders = {};

		headerParameters["Content-Type"] = "application/json";

		if (this.configuration?.accessToken) {
			const token = this.configuration.accessToken;
			const tokenString = await token("bearer_token", []);

			if (tokenString) {
				headerParameters.Authorization = `Bearer ${tokenString}`;
			}
		}
		if (this.configuration?.apiKey) {
			headerParameters["X-API-Key"] =
				await this.configuration.apiKey("X-API-Key"); // api_key authentication
		}

		let urlPath = `/api/encryption/v1/envelope/{envelope_id}/migrate`;
		urlPath = urlPath.replace(
			`{${"envelope_id"}}`,
			encodeURIComponent(String(requestParameters.envelopeId)),
		);

		const response = await this.request(
			{
				path: urlPath,
				method: "POST",
				headers: headerParameters,
				query: queryParameters,
				body: MigrateAllDataEncryptionKeysParamsRouteToJSON(
					requestParameters.migrateAllDataEncryptionKeysParamsRoute,
				),
			},
			initOverrides,
		);

		return new runtime.VoidApiResponse(response);
	}

	/**
	 * Migrate all data encryption keys encrypted with the specified envelope key to a new envelope key
	 * Migrate all data keys
	 */
	async migrateAllDataEncryptionKeys(
		requestParameters: V1ApiMigrateAllDataEncryptionKeysRequest,
		initOverrides?: RequestInit | runtime.InitOverrideFunction,
	): Promise<void> {
		await this.migrateAllDataEncryptionKeysRaw(
			requestParameters,
			initOverrides,
		);
	}

	/**
	 * Migrate a data encryption key to be encrypted with a different envelope encryption key
	 * Migrate data key
	 */
	async migrateDataEncryptionKeyRaw(
		requestParameters: V1ApiMigrateDataEncryptionKeyRequest,
		initOverrides?: RequestInit | runtime.InitOverrideFunction,
	): Promise<runtime.ApiResponse<void>> {
		if (requestParameters.envelopeId == null) {
			throw new runtime.RequiredError(
				"envelopeId",
				'Required parameter "envelopeId" was null or undefined when calling migrateDataEncryptionKey().',
			);
		}

		if (requestParameters.dekId == null) {
			throw new runtime.RequiredError(
				"dekId",
				'Required parameter "dekId" was null or undefined when calling migrateDataEncryptionKey().',
			);
		}

		if (requestParameters.migrateDataEncryptionKeyParamsRoute == null) {
			throw new runtime.RequiredError(
				"migrateDataEncryptionKeyParamsRoute",
				'Required parameter "migrateDataEncryptionKeyParamsRoute" was null or undefined when calling migrateDataEncryptionKey().',
			);
		}

		const queryParameters: any = {};

		const headerParameters: runtime.HTTPHeaders = {};

		headerParameters["Content-Type"] = "application/json";

		if (this.configuration?.accessToken) {
			const token = this.configuration.accessToken;
			const tokenString = await token("bearer_token", []);

			if (tokenString) {
				headerParameters.Authorization = `Bearer ${tokenString}`;
			}
		}
		if (this.configuration?.apiKey) {
			headerParameters["X-API-Key"] =
				await this.configuration.apiKey("X-API-Key"); // api_key authentication
		}

		let urlPath = `/api/encryption/v1/envelope/{envelope_id}/dek/{dek_id}/migrate`;
		urlPath = urlPath.replace(
			`{${"envelope_id"}}`,
			encodeURIComponent(String(requestParameters.envelopeId)),
		);
		urlPath = urlPath.replace(
			`{${"dek_id"}}`,
			encodeURIComponent(String(requestParameters.dekId)),
		);

		const response = await this.request(
			{
				path: urlPath,
				method: "POST",
				headers: headerParameters,
				query: queryParameters,
				body: MigrateDataEncryptionKeyParamsRouteToJSON(
					requestParameters.migrateDataEncryptionKeyParamsRoute,
				),
			},
			initOverrides,
		);

		return new runtime.VoidApiResponse(response);
	}

	/**
	 * Migrate a data encryption key to be encrypted with a different envelope encryption key
	 * Migrate data key
	 */
	async migrateDataEncryptionKey(
		requestParameters: V1ApiMigrateDataEncryptionKeyRequest,
		initOverrides?: RequestInit | runtime.InitOverrideFunction,
	): Promise<void> {
		await this.migrateDataEncryptionKeyRaw(requestParameters, initOverrides);
	}

	/**
	 * Remove a user from a group
	 * Remove group member
	 */
	async removeGroupMemberRaw(
		requestParameters: V1ApiRemoveGroupMemberRequest,
		initOverrides?: RequestInit | runtime.InitOverrideFunction,
	): Promise<runtime.ApiResponse<void>> {
		if (requestParameters.groupId == null) {
			throw new runtime.RequiredError(
				"groupId",
				'Required parameter "groupId" was null or undefined when calling removeGroupMember().',
			);
		}

		if (requestParameters.userId == null) {
			throw new runtime.RequiredError(
				"userId",
				'Required parameter "userId" was null or undefined when calling removeGroupMember().',
			);
		}

		const queryParameters: any = {};

		const headerParameters: runtime.HTTPHeaders = {};

		if (this.configuration?.accessToken) {
			const token = this.configuration.accessToken;
			const tokenString = await token("bearer_token", []);

			if (tokenString) {
				headerParameters.Authorization = `Bearer ${tokenString}`;
			}
		}
		if (this.configuration?.apiKey) {
			headerParameters["X-API-Key"] =
				await this.configuration.apiKey("X-API-Key"); // api_key authentication
		}

		let urlPath = `/api/identity/v1/groups/{group_id}/members/{user_id}`;
		urlPath = urlPath.replace(
			`{${"group_id"}}`,
			encodeURIComponent(String(requestParameters.groupId)),
		);
		urlPath = urlPath.replace(
			`{${"user_id"}}`,
			encodeURIComponent(String(requestParameters.userId)),
		);

		const response = await this.request(
			{
				path: urlPath,
				method: "DELETE",
				headers: headerParameters,
				query: queryParameters,
			},
			initOverrides,
		);

		return new runtime.VoidApiResponse(response);
	}

	/**
	 * Remove a user from a group
	 * Remove group member
	 */
	async removeGroupMember(
		requestParameters: V1ApiRemoveGroupMemberRequest,
		initOverrides?: RequestInit | runtime.InitOverrideFunction,
	): Promise<void> {
		await this.removeGroupMemberRaw(requestParameters, initOverrides);
	}

	/**
	 * Remove a function mapping from an MCP server instance
	 * Remove function from MCP server instance
	 */
	async removeMcpServerInstanceFunctionRaw(
		requestParameters: V1ApiRemoveMcpServerInstanceFunctionRequest,
		initOverrides?: RequestInit | runtime.InitOverrideFunction,
	): Promise<runtime.ApiResponse<McpServerInstanceSerializedWithFunctions>> {
		if (requestParameters.mcpServerInstanceId == null) {
			throw new runtime.RequiredError(
				"mcpServerInstanceId",
				'Required parameter "mcpServerInstanceId" was null or undefined when calling removeMcpServerInstanceFunction().',
			);
		}

		if (requestParameters.functionControllerTypeId == null) {
			throw new runtime.RequiredError(
				"functionControllerTypeId",
				'Required parameter "functionControllerTypeId" was null or undefined when calling removeMcpServerInstanceFunction().',
			);
		}

		if (requestParameters.providerControllerTypeId == null) {
			throw new runtime.RequiredError(
				"providerControllerTypeId",
				'Required parameter "providerControllerTypeId" was null or undefined when calling removeMcpServerInstanceFunction().',
			);
		}

		if (requestParameters.providerInstanceId == null) {
			throw new runtime.RequiredError(
				"providerInstanceId",
				'Required parameter "providerInstanceId" was null or undefined when calling removeMcpServerInstanceFunction().',
			);
		}

		const queryParameters: any = {};

		const headerParameters: runtime.HTTPHeaders = {};

		if (this.configuration?.accessToken) {
			const token = this.configuration.accessToken;
			const tokenString = await token("bearer_token", []);

			if (tokenString) {
				headerParameters.Authorization = `Bearer ${tokenString}`;
			}
		}
		if (this.configuration?.apiKey) {
			headerParameters["X-API-Key"] =
				await this.configuration.apiKey("X-API-Key"); // api_key authentication
		}

		let urlPath = `/api/mcp/v1/mcp-server/{mcp_server_instance_id}/function/{function_controller_type_id}/{provider_controller_type_id}/{provider_instance_id}`;
		urlPath = urlPath.replace(
			`{${"mcp_server_instance_id"}}`,
			encodeURIComponent(String(requestParameters.mcpServerInstanceId)),
		);
		urlPath = urlPath.replace(
			`{${"function_controller_type_id"}}`,
			encodeURIComponent(String(requestParameters.functionControllerTypeId)),
		);
		urlPath = urlPath.replace(
			`{${"provider_controller_type_id"}}`,
			encodeURIComponent(String(requestParameters.providerControllerTypeId)),
		);
		urlPath = urlPath.replace(
			`{${"provider_instance_id"}}`,
			encodeURIComponent(String(requestParameters.providerInstanceId)),
		);

		const response = await this.request(
			{
				path: urlPath,
				method: "DELETE",
				headers: headerParameters,
				query: queryParameters,
			},
			initOverrides,
		);

		return new runtime.JSONApiResponse(response, (jsonValue) =>
			McpServerInstanceSerializedWithFunctionsFromJSON(jsonValue),
		);
	}

	/**
	 * Remove a function mapping from an MCP server instance
	 * Remove function from MCP server instance
	 */
	async removeMcpServerInstanceFunction(
		requestParameters: V1ApiRemoveMcpServerInstanceFunctionRequest,
		initOverrides?: RequestInit | runtime.InitOverrideFunction,
	): Promise<McpServerInstanceSerializedWithFunctions> {
		const response = await this.removeMcpServerInstanceFunctionRaw(
			requestParameters,
			initOverrides,
		);
		return await response.value();
	}

	/**
	 * Handle OAuth callback to complete user credential brokering flow
	 * OAuth callback
	 */
	async resumeUserCredentialBrokeringRaw(
		requestParameters: V1ApiResumeUserCredentialBrokeringRequest,
		initOverrides?: RequestInit | runtime.InitOverrideFunction,
	): Promise<runtime.ApiResponse<UserCredentialBrokeringResponse>> {
		const queryParameters: any = {};

		if (requestParameters.state != null) {
			queryParameters.state = requestParameters.state;
		}

		if (requestParameters.code != null) {
			queryParameters.code = requestParameters.code;
		}

		if (requestParameters.error != null) {
			queryParameters.error = requestParameters.error;
		}

		if (requestParameters.errorDescription != null) {
			queryParameters.error_description = requestParameters.errorDescription;
		}

		const headerParameters: runtime.HTTPHeaders = {};

		if (this.configuration?.accessToken) {
			const token = this.configuration.accessToken;
			const tokenString = await token("bearer_token", []);

			if (tokenString) {
				headerParameters.Authorization = `Bearer ${tokenString}`;
			}
		}
		if (this.configuration?.apiKey) {
			headerParameters["X-API-Key"] =
				await this.configuration.apiKey("X-API-Key"); // api_key authentication
		}

		const urlPath = `/api/mcp/v1/generic-oauth-callback`;

		const response = await this.request(
			{
				path: urlPath,
				method: "GET",
				headers: headerParameters,
				query: queryParameters,
			},
			initOverrides,
		);

		return new runtime.JSONApiResponse(response, (jsonValue) =>
			UserCredentialBrokeringResponseFromJSON(jsonValue),
		);
	}

	/**
	 * Handle OAuth callback to complete user credential brokering flow
	 * OAuth callback
	 */
	async resumeUserCredentialBrokering(
		requestParameters: V1ApiResumeUserCredentialBrokeringRequest = {},
		initOverrides?: RequestInit | runtime.InitOverrideFunction,
	): Promise<UserCredentialBrokeringResponse> {
		const response = await this.resumeUserCredentialBrokeringRaw(
			requestParameters,
			initOverrides,
		);
		return await response.value();
	}

	/**
	 * Resync providers, agents, secrets, and environment variables between API server and SDK
	 * Resync SDK
	 */
	async resyncSdkRaw(
		initOverrides?: RequestInit | runtime.InitOverrideFunction,
	): Promise<runtime.ApiResponse<object>> {
		const queryParameters: any = {};

		const headerParameters: runtime.HTTPHeaders = {};

		if (this.configuration?.accessToken) {
			const token = this.configuration.accessToken;
			const tokenString = await token("bearer_token", []);

			if (tokenString) {
				headerParameters.Authorization = `Bearer ${tokenString}`;
			}
		}
		if (this.configuration?.apiKey) {
			headerParameters["X-API-Key"] =
				await this.configuration.apiKey("X-API-Key"); // api_key authentication
		}

		const urlPath = `/_internal/v1/resync_sdk`;

		const response = await this.request(
			{
				path: urlPath,
				method: "POST",
				headers: headerParameters,
				query: queryParameters,
			},
			initOverrides,
		);

		return new runtime.JSONApiResponse<any>(response);
	}

	/**
	 * Resync providers, agents, secrets, and environment variables between API server and SDK
	 * Resync SDK
	 */
	async resyncSdk(
		initOverrides?: RequestInit | runtime.InitOverrideFunction,
	): Promise<object> {
		const response = await this.resyncSdkRaw(initOverrides);
		return await response.value();
	}

	/**
	 * Handles the OAuth/OIDC callback from the external IdP, exchanges the authorization code for tokens
	 * Authorization callback
	 */
	async routeAuthCallbackRaw(
		requestParameters: V1ApiRouteAuthCallbackRequest,
		initOverrides?: RequestInit | runtime.InitOverrideFunction,
	): Promise<runtime.ApiResponse<void>> {
		const queryParameters: any = {};

		if (requestParameters.code != null) {
			queryParameters.code = requestParameters.code;
		}

		if (requestParameters.state != null) {
			queryParameters.state = requestParameters.state;
		}

		if (requestParameters.error != null) {
			queryParameters.error = requestParameters.error;
		}

		if (requestParameters.errorDescription != null) {
			queryParameters.error_description = requestParameters.errorDescription;
		}

		const headerParameters: runtime.HTTPHeaders = {};

		if (this.configuration?.accessToken) {
			const token = this.configuration.accessToken;
			const tokenString = await token("bearer_token", []);

			if (tokenString) {
				headerParameters.Authorization = `Bearer ${tokenString}`;
			}
		}
		if (this.configuration?.apiKey) {
			headerParameters["X-API-Key"] =
				await this.configuration.apiKey("X-API-Key"); // api_key authentication
		}

		const urlPath = `/api/identity/v1/auth/callback`;

		const response = await this.request(
			{
				path: urlPath,
				method: "GET",
				headers: headerParameters,
				query: queryParameters,
			},
			initOverrides,
		);

		return new runtime.VoidApiResponse(response);
	}

	/**
	 * Handles the OAuth/OIDC callback from the external IdP, exchanges the authorization code for tokens
	 * Authorization callback
	 */
	async routeAuthCallback(
		requestParameters: V1ApiRouteAuthCallbackRequest = {},
		initOverrides?: RequestInit | runtime.InitOverrideFunction,
	): Promise<void> {
		await this.routeAuthCallbackRaw(requestParameters, initOverrides);
	}

	/**
	 */
	async routeCreateApiKeyRaw(
		requestParameters: V1ApiRouteCreateApiKeyRequest,
		initOverrides?: RequestInit | runtime.InitOverrideFunction,
	): Promise<runtime.ApiResponse<CreateApiKeyResponse>> {
		if (requestParameters.createApiKeyParams == null) {
			throw new runtime.RequiredError(
				"createApiKeyParams",
				'Required parameter "createApiKeyParams" was null or undefined when calling routeCreateApiKey().',
			);
		}

		const queryParameters: any = {};

		const headerParameters: runtime.HTTPHeaders = {};

		headerParameters["Content-Type"] = "application/json";

		if (this.configuration?.accessToken) {
			const token = this.configuration.accessToken;
			const tokenString = await token("bearer_token", []);

			if (tokenString) {
				headerParameters.Authorization = `Bearer ${tokenString}`;
			}
		}
		if (this.configuration?.apiKey) {
			headerParameters["X-API-Key"] =
				await this.configuration.apiKey("X-API-Key"); // api_key authentication
		}

		const urlPath = `/api/identity/v1/api-key`;

		const response = await this.request(
			{
				path: urlPath,
				method: "POST",
				headers: headerParameters,
				query: queryParameters,
				body: CreateApiKeyParamsToJSON(requestParameters.createApiKeyParams),
			},
			initOverrides,
		);

		return new runtime.JSONApiResponse(response, (jsonValue) =>
			CreateApiKeyResponseFromJSON(jsonValue),
		);
	}

	/**
	 */
	async routeCreateApiKey(
		requestParameters: V1ApiRouteCreateApiKeyRequest,
		initOverrides?: RequestInit | runtime.InitOverrideFunction,
	): Promise<CreateApiKeyResponse> {
		const response = await this.routeCreateApiKeyRaw(
			requestParameters,
			initOverrides,
		);
		return await response.value();
	}

	/**
	 * Create a new STS configuration (e.g., JWT template or dev settings)
	 * Create STS configuration
	 */
	async routeCreateStsConfigRaw(
		requestParameters: V1ApiRouteCreateStsConfigRequest,
		initOverrides?: RequestInit | runtime.InitOverrideFunction,
	): Promise<runtime.ApiResponse<StsTokenConfig>> {
		if (requestParameters.stsTokenConfig == null) {
			throw new runtime.RequiredError(
				"stsTokenConfig",
				'Required parameter "stsTokenConfig" was null or undefined when calling routeCreateStsConfig().',
			);
		}

		const queryParameters: any = {};

		const headerParameters: runtime.HTTPHeaders = {};

		headerParameters["Content-Type"] = "application/json";

		if (this.configuration?.accessToken) {
			const token = this.configuration.accessToken;
			const tokenString = await token("bearer_token", []);

			if (tokenString) {
				headerParameters.Authorization = `Bearer ${tokenString}`;
			}
		}
		if (this.configuration?.apiKey) {
			headerParameters["X-API-Key"] =
				await this.configuration.apiKey("X-API-Key"); // api_key authentication
		}

		const urlPath = `/api/identity/v1/sts-configuration`;

		const response = await this.request(
			{
				path: urlPath,
				method: "POST",
				headers: headerParameters,
				query: queryParameters,
				body: StsTokenConfigToJSON(requestParameters.stsTokenConfig),
			},
			initOverrides,
		);

		return new runtime.JSONApiResponse(response, (jsonValue) =>
			StsTokenConfigFromJSON(jsonValue),
		);
	}

	/**
	 * Create a new STS configuration (e.g., JWT template or dev settings)
	 * Create STS configuration
	 */
	async routeCreateStsConfig(
		requestParameters: V1ApiRouteCreateStsConfigRequest,
		initOverrides?: RequestInit | runtime.InitOverrideFunction,
	): Promise<StsTokenConfig> {
		const response = await this.routeCreateStsConfigRaw(
			requestParameters,
			initOverrides,
		);
		return await response.value();
	}

	/**
	 * Create a new user auth flow configuration for OAuth/OIDC authorization flows. The configuration will be encrypted before storage.
	 * Create user auth flow configuration
	 */
	async routeCreateUserAuthFlowConfigRaw(
		requestParameters: V1ApiRouteCreateUserAuthFlowConfigRequest,
		initOverrides?: RequestInit | runtime.InitOverrideFunction,
	): Promise<runtime.ApiResponse<CreateUserAuthFlowConfigResponse>> {
		if (requestParameters.createUserAuthFlowConfigParams == null) {
			throw new runtime.RequiredError(
				"createUserAuthFlowConfigParams",
				'Required parameter "createUserAuthFlowConfigParams" was null or undefined when calling routeCreateUserAuthFlowConfig().',
			);
		}

		const queryParameters: any = {};

		const headerParameters: runtime.HTTPHeaders = {};

		headerParameters["Content-Type"] = "application/json";

		if (this.configuration?.accessToken) {
			const token = this.configuration.accessToken;
			const tokenString = await token("bearer_token", []);

			if (tokenString) {
				headerParameters.Authorization = `Bearer ${tokenString}`;
			}
		}
		if (this.configuration?.apiKey) {
			headerParameters["X-API-Key"] =
				await this.configuration.apiKey("X-API-Key"); // api_key authentication
		}

		const urlPath = `/api/identity/v1/user-auth-flow-config`;

		const response = await this.request(
			{
				path: urlPath,
				method: "POST",
				headers: headerParameters,
				query: queryParameters,
				body: CreateUserAuthFlowConfigParamsToJSON(
					requestParameters.createUserAuthFlowConfigParams,
				),
			},
			initOverrides,
		);

		return new runtime.JSONApiResponse(response, (jsonValue) =>
			CreateUserAuthFlowConfigResponseFromJSON(jsonValue),
		);
	}

	/**
	 * Create a new user auth flow configuration for OAuth/OIDC authorization flows. The configuration will be encrypted before storage.
	 * Create user auth flow configuration
	 */
	async routeCreateUserAuthFlowConfig(
		requestParameters: V1ApiRouteCreateUserAuthFlowConfigRequest,
		initOverrides?: RequestInit | runtime.InitOverrideFunction,
	): Promise<CreateUserAuthFlowConfigResponse> {
		const response = await this.routeCreateUserAuthFlowConfigRaw(
			requestParameters,
			initOverrides,
		);
		return await response.value();
	}

	/**
	 */
	async routeDeleteApiKeyRaw(
		requestParameters: V1ApiRouteDeleteApiKeyRequest,
		initOverrides?: RequestInit | runtime.InitOverrideFunction,
	): Promise<runtime.ApiResponse<any>> {
		if (requestParameters.id == null) {
			throw new runtime.RequiredError(
				"id",
				'Required parameter "id" was null or undefined when calling routeDeleteApiKey().',
			);
		}

		const queryParameters: any = {};

		const headerParameters: runtime.HTTPHeaders = {};

		if (this.configuration?.accessToken) {
			const token = this.configuration.accessToken;
			const tokenString = await token("bearer_token", []);

			if (tokenString) {
				headerParameters.Authorization = `Bearer ${tokenString}`;
			}
		}
		if (this.configuration?.apiKey) {
			headerParameters["X-API-Key"] =
				await this.configuration.apiKey("X-API-Key"); // api_key authentication
		}

		let urlPath = `/api/identity/v1/api-key/{id}`;
		urlPath = urlPath.replace(
			`{${"id"}}`,
			encodeURIComponent(String(requestParameters.id)),
		);

		const response = await this.request(
			{
				path: urlPath,
				method: "DELETE",
				headers: headerParameters,
				query: queryParameters,
			},
			initOverrides,
		);

		if (this.isJsonMime(response.headers.get("content-type"))) {
			return new runtime.JSONApiResponse<any>(response);
		} else {
			return new runtime.TextApiResponse(response) as any;
		}
	}

	/**
	 */
	async routeDeleteApiKey(
		requestParameters: V1ApiRouteDeleteApiKeyRequest,
		initOverrides?: RequestInit | runtime.InitOverrideFunction,
	): Promise<any> {
		const response = await this.routeDeleteApiKeyRaw(
			requestParameters,
			initOverrides,
		);
		return await response.value();
	}

	/**
	 * Delete an STS configuration by ID
	 * Delete STS configuration
	 */
	async routeDeleteStsConfigRaw(
		requestParameters: V1ApiRouteDeleteStsConfigRequest,
		initOverrides?: RequestInit | runtime.InitOverrideFunction,
	): Promise<runtime.ApiResponse<any>> {
		if (requestParameters.id == null) {
			throw new runtime.RequiredError(
				"id",
				'Required parameter "id" was null or undefined when calling routeDeleteStsConfig().',
			);
		}

		const queryParameters: any = {};

		const headerParameters: runtime.HTTPHeaders = {};

		if (this.configuration?.accessToken) {
			const token = this.configuration.accessToken;
			const tokenString = await token("bearer_token", []);

			if (tokenString) {
				headerParameters.Authorization = `Bearer ${tokenString}`;
			}
		}
		if (this.configuration?.apiKey) {
			headerParameters["X-API-Key"] =
				await this.configuration.apiKey("X-API-Key"); // api_key authentication
		}

		let urlPath = `/api/identity/v1/sts-configuration/{id}`;
		urlPath = urlPath.replace(
			`{${"id"}}`,
			encodeURIComponent(String(requestParameters.id)),
		);

		const response = await this.request(
			{
				path: urlPath,
				method: "DELETE",
				headers: headerParameters,
				query: queryParameters,
			},
			initOverrides,
		);

		if (this.isJsonMime(response.headers.get("content-type"))) {
			return new runtime.JSONApiResponse<any>(response);
		} else {
			return new runtime.TextApiResponse(response) as any;
		}
	}

	/**
	 * Delete an STS configuration by ID
	 * Delete STS configuration
	 */
	async routeDeleteStsConfig(
		requestParameters: V1ApiRouteDeleteStsConfigRequest,
		initOverrides?: RequestInit | runtime.InitOverrideFunction,
	): Promise<any> {
		const response = await this.routeDeleteStsConfigRaw(
			requestParameters,
			initOverrides,
		);
		return await response.value();
	}

	/**
	 * Delete a user auth flow configuration by ID
	 * Delete user auth flow configuration
	 */
	async routeDeleteUserAuthFlowConfigRaw(
		requestParameters: V1ApiRouteDeleteUserAuthFlowConfigRequest,
		initOverrides?: RequestInit | runtime.InitOverrideFunction,
	): Promise<runtime.ApiResponse<any>> {
		if (requestParameters.id == null) {
			throw new runtime.RequiredError(
				"id",
				'Required parameter "id" was null or undefined when calling routeDeleteUserAuthFlowConfig().',
			);
		}

		const queryParameters: any = {};

		const headerParameters: runtime.HTTPHeaders = {};

		if (this.configuration?.accessToken) {
			const token = this.configuration.accessToken;
			const tokenString = await token("bearer_token", []);

			if (tokenString) {
				headerParameters.Authorization = `Bearer ${tokenString}`;
			}
		}
		if (this.configuration?.apiKey) {
			headerParameters["X-API-Key"] =
				await this.configuration.apiKey("X-API-Key"); // api_key authentication
		}

		let urlPath = `/api/identity/v1/user-auth-flow-config/{id}`;
		urlPath = urlPath.replace(
			`{${"id"}}`,
			encodeURIComponent(String(requestParameters.id)),
		);

		const response = await this.request(
			{
				path: urlPath,
				method: "DELETE",
				headers: headerParameters,
				query: queryParameters,
			},
			initOverrides,
		);

		if (this.isJsonMime(response.headers.get("content-type"))) {
			return new runtime.JSONApiResponse<any>(response);
		} else {
			return new runtime.TextApiResponse(response) as any;
		}
	}

	/**
	 * Delete a user auth flow configuration by ID
	 * Delete user auth flow configuration
	 */
	async routeDeleteUserAuthFlowConfig(
		requestParameters: V1ApiRouteDeleteUserAuthFlowConfigRequest,
		initOverrides?: RequestInit | runtime.InitOverrideFunction,
	): Promise<any> {
		const response = await this.routeDeleteUserAuthFlowConfigRaw(
			requestParameters,
			initOverrides,
		);
		return await response.value();
	}

	/**
	 * Exchange an external token for internal access and refresh tokens using an STS configuration
	 * Exchange STS token
	 */
	async routeExchangeStsTokenRaw(
		requestParameters: V1ApiRouteExchangeStsTokenRequest,
		initOverrides?: RequestInit | runtime.InitOverrideFunction,
	): Promise<runtime.ApiResponse<NormalizedTokenIssuanceResult>> {
		if (requestParameters.stsConfigId == null) {
			throw new runtime.RequiredError(
				"stsConfigId",
				'Required parameter "stsConfigId" was null or undefined when calling routeExchangeStsToken().',
			);
		}

		const queryParameters: any = {};

		const headerParameters: runtime.HTTPHeaders = {};

		if (this.configuration?.accessToken) {
			const token = this.configuration.accessToken;
			const tokenString = await token("bearer_token", []);

			if (tokenString) {
				headerParameters.Authorization = `Bearer ${tokenString}`;
			}
		}
		if (this.configuration?.apiKey) {
			headerParameters["X-API-Key"] =
				await this.configuration.apiKey("X-API-Key"); // api_key authentication
		}

		let urlPath = `/api/identity/v1/sts/{sts_config_id}`;
		urlPath = urlPath.replace(
			`{${"sts_config_id"}}`,
			encodeURIComponent(String(requestParameters.stsConfigId)),
		);

		const response = await this.request(
			{
				path: urlPath,
				method: "POST",
				headers: headerParameters,
				query: queryParameters,
			},
			initOverrides,
		);

		return new runtime.JSONApiResponse(response, (jsonValue) =>
			NormalizedTokenIssuanceResultFromJSON(jsonValue),
		);
	}

	/**
	 * Exchange an external token for internal access and refresh tokens using an STS configuration
	 * Exchange STS token
	 */
	async routeExchangeStsToken(
		requestParameters: V1ApiRouteExchangeStsTokenRequest,
		initOverrides?: RequestInit | runtime.InitOverrideFunction,
	): Promise<NormalizedTokenIssuanceResult> {
		const response = await this.routeExchangeStsTokenRaw(
			requestParameters,
			initOverrides,
		);
		return await response.value();
	}

	/**
	 */
	async routeGetJwksRaw(
		initOverrides?: RequestInit | runtime.InitOverrideFunction,
	): Promise<runtime.ApiResponse<JwksResponse>> {
		const queryParameters: any = {};

		const headerParameters: runtime.HTTPHeaders = {};

		if (this.configuration?.accessToken) {
			const token = this.configuration.accessToken;
			const tokenString = await token("bearer_token", []);

			if (tokenString) {
				headerParameters.Authorization = `Bearer ${tokenString}`;
			}
		}
		if (this.configuration?.apiKey) {
			headerParameters["X-API-Key"] =
				await this.configuration.apiKey("X-API-Key"); // api_key authentication
		}

		const urlPath = `/api/identity/v1/.well-known/jwks.json`;

		const response = await this.request(
			{
				path: urlPath,
				method: "GET",
				headers: headerParameters,
				query: queryParameters,
			},
			initOverrides,
		);

		return new runtime.JSONApiResponse(response, (jsonValue) =>
			JwksResponseFromJSON(jsonValue),
		);
	}

	/**
	 */
	async routeGetJwks(
		initOverrides?: RequestInit | runtime.InitOverrideFunction,
	): Promise<JwksResponse> {
		const response = await this.routeGetJwksRaw(initOverrides);
		return await response.value();
	}

	/**
	 * Get an STS configuration by ID
	 * Get STS configuration
	 */
	async routeGetStsConfigRaw(
		requestParameters: V1ApiRouteGetStsConfigRequest,
		initOverrides?: RequestInit | runtime.InitOverrideFunction,
	): Promise<runtime.ApiResponse<StsTokenConfig>> {
		if (requestParameters.id == null) {
			throw new runtime.RequiredError(
				"id",
				'Required parameter "id" was null or undefined when calling routeGetStsConfig().',
			);
		}

		const queryParameters: any = {};

		const headerParameters: runtime.HTTPHeaders = {};

		if (this.configuration?.accessToken) {
			const token = this.configuration.accessToken;
			const tokenString = await token("bearer_token", []);

			if (tokenString) {
				headerParameters.Authorization = `Bearer ${tokenString}`;
			}
		}
		if (this.configuration?.apiKey) {
			headerParameters["X-API-Key"] =
				await this.configuration.apiKey("X-API-Key"); // api_key authentication
		}

		let urlPath = `/api/identity/v1/sts-configuration/{id}`;
		urlPath = urlPath.replace(
			`{${"id"}}`,
			encodeURIComponent(String(requestParameters.id)),
		);

		const response = await this.request(
			{
				path: urlPath,
				method: "GET",
				headers: headerParameters,
				query: queryParameters,
			},
			initOverrides,
		);

		return new runtime.JSONApiResponse(response, (jsonValue) =>
			StsTokenConfigFromJSON(jsonValue),
		);
	}

	/**
	 * Get an STS configuration by ID
	 * Get STS configuration
	 */
	async routeGetStsConfig(
		requestParameters: V1ApiRouteGetStsConfigRequest,
		initOverrides?: RequestInit | runtime.InitOverrideFunction,
	): Promise<StsTokenConfig> {
		const response = await this.routeGetStsConfigRaw(
			requestParameters,
			initOverrides,
		);
		return await response.value();
	}

	/**
	 * Get a user auth flow configuration by ID. Returns the encrypted configuration.
	 * Get user auth flow configuration
	 */
	async routeGetUserAuthFlowConfigRaw(
		requestParameters: V1ApiRouteGetUserAuthFlowConfigRequest,
		initOverrides?: RequestInit | runtime.InitOverrideFunction,
	): Promise<runtime.ApiResponse<GetUserAuthFlowConfigResponse>> {
		if (requestParameters.id == null) {
			throw new runtime.RequiredError(
				"id",
				'Required parameter "id" was null or undefined when calling routeGetUserAuthFlowConfig().',
			);
		}

		const queryParameters: any = {};

		const headerParameters: runtime.HTTPHeaders = {};

		if (this.configuration?.accessToken) {
			const token = this.configuration.accessToken;
			const tokenString = await token("bearer_token", []);

			if (tokenString) {
				headerParameters.Authorization = `Bearer ${tokenString}`;
			}
		}
		if (this.configuration?.apiKey) {
			headerParameters["X-API-Key"] =
				await this.configuration.apiKey("X-API-Key"); // api_key authentication
		}

		let urlPath = `/api/identity/v1/user-auth-flow-config/{id}`;
		urlPath = urlPath.replace(
			`{${"id"}}`,
			encodeURIComponent(String(requestParameters.id)),
		);

		const response = await this.request(
			{
				path: urlPath,
				method: "GET",
				headers: headerParameters,
				query: queryParameters,
			},
			initOverrides,
		);

		return new runtime.JSONApiResponse(response, (jsonValue) =>
			GetUserAuthFlowConfigResponseFromJSON(jsonValue),
		);
	}

	/**
	 * Get a user auth flow configuration by ID. Returns the encrypted configuration.
	 * Get user auth flow configuration
	 */
	async routeGetUserAuthFlowConfig(
		requestParameters: V1ApiRouteGetUserAuthFlowConfigRequest,
		initOverrides?: RequestInit | runtime.InitOverrideFunction,
	): Promise<GetUserAuthFlowConfigResponse> {
		const response = await this.routeGetUserAuthFlowConfigRaw(
			requestParameters,
			initOverrides,
		);
		return await response.value();
	}

	/**
	 */
	async routeImportApiKeyRaw(
		requestParameters: V1ApiRouteImportApiKeyRequest,
		initOverrides?: RequestInit | runtime.InitOverrideFunction,
	): Promise<runtime.ApiResponse<any>> {
		if (requestParameters.encryptedApiKeyConfig == null) {
			throw new runtime.RequiredError(
				"encryptedApiKeyConfig",
				'Required parameter "encryptedApiKeyConfig" was null or undefined when calling routeImportApiKey().',
			);
		}

		const queryParameters: any = {};

		const headerParameters: runtime.HTTPHeaders = {};

		headerParameters["Content-Type"] = "application/json";

		if (this.configuration?.accessToken) {
			const token = this.configuration.accessToken;
			const tokenString = await token("bearer_token", []);

			if (tokenString) {
				headerParameters.Authorization = `Bearer ${tokenString}`;
			}
		}
		if (this.configuration?.apiKey) {
			headerParameters["X-API-Key"] =
				await this.configuration.apiKey("X-API-Key"); // api_key authentication
		}

		const urlPath = `/api/identity/v1/api-key/import`;

		const response = await this.request(
			{
				path: urlPath,
				method: "POST",
				headers: headerParameters,
				query: queryParameters,
				body: EncryptedApiKeyConfigToJSON(
					requestParameters.encryptedApiKeyConfig,
				),
			},
			initOverrides,
		);

		if (this.isJsonMime(response.headers.get("content-type"))) {
			return new runtime.JSONApiResponse<any>(response);
		} else {
			return new runtime.TextApiResponse(response) as any;
		}
	}

	/**
	 */
	async routeImportApiKey(
		requestParameters: V1ApiRouteImportApiKeyRequest,
		initOverrides?: RequestInit | runtime.InitOverrideFunction,
	): Promise<any> {
		const response = await this.routeImportApiKeyRaw(
			requestParameters,
			initOverrides,
		);
		return await response.value();
	}

	/**
	 * Import an already encrypted user auth flow configuration (idempotent, used for syncing from soma.yaml)
	 * Import user auth flow configuration
	 */
	async routeImportUserAuthFlowConfigRaw(
		requestParameters: V1ApiRouteImportUserAuthFlowConfigRequest,
		initOverrides?: RequestInit | runtime.InitOverrideFunction,
	): Promise<runtime.ApiResponse<any>> {
		if (requestParameters.importUserAuthFlowConfigParams == null) {
			throw new runtime.RequiredError(
				"importUserAuthFlowConfigParams",
				'Required parameter "importUserAuthFlowConfigParams" was null or undefined when calling routeImportUserAuthFlowConfig().',
			);
		}

		const queryParameters: any = {};

		const headerParameters: runtime.HTTPHeaders = {};

		headerParameters["Content-Type"] = "application/json";

		if (this.configuration?.accessToken) {
			const token = this.configuration.accessToken;
			const tokenString = await token("bearer_token", []);

			if (tokenString) {
				headerParameters.Authorization = `Bearer ${tokenString}`;
			}
		}
		if (this.configuration?.apiKey) {
			headerParameters["X-API-Key"] =
				await this.configuration.apiKey("X-API-Key"); // api_key authentication
		}

		const urlPath = `/api/identity/v1/user-auth-flow-config/import`;

		const response = await this.request(
			{
				path: urlPath,
				method: "POST",
				headers: headerParameters,
				query: queryParameters,
				body: ImportUserAuthFlowConfigParamsToJSON(
					requestParameters.importUserAuthFlowConfigParams,
				),
			},
			initOverrides,
		);

		if (this.isJsonMime(response.headers.get("content-type"))) {
			return new runtime.JSONApiResponse<any>(response);
		} else {
			return new runtime.TextApiResponse(response) as any;
		}
	}

	/**
	 * Import an already encrypted user auth flow configuration (idempotent, used for syncing from soma.yaml)
	 * Import user auth flow configuration
	 */
	async routeImportUserAuthFlowConfig(
		requestParameters: V1ApiRouteImportUserAuthFlowConfigRequest,
		initOverrides?: RequestInit | runtime.InitOverrideFunction,
	): Promise<any> {
		const response = await this.routeImportUserAuthFlowConfigRaw(
			requestParameters,
			initOverrides,
		);
		return await response.value();
	}

	/**
	 */
	async routeInvalidateJwkRaw(
		requestParameters: V1ApiRouteInvalidateJwkRequest,
		initOverrides?: RequestInit | runtime.InitOverrideFunction,
	): Promise<runtime.ApiResponse<void>> {
		if (requestParameters.kid == null) {
			throw new runtime.RequiredError(
				"kid",
				'Required parameter "kid" was null or undefined when calling routeInvalidateJwk().',
			);
		}

		const queryParameters: any = {};

		const headerParameters: runtime.HTTPHeaders = {};

		if (this.configuration?.accessToken) {
			const token = this.configuration.accessToken;
			const tokenString = await token("bearer_token", []);

			if (tokenString) {
				headerParameters.Authorization = `Bearer ${tokenString}`;
			}
		}
		if (this.configuration?.apiKey) {
			headerParameters["X-API-Key"] =
				await this.configuration.apiKey("X-API-Key"); // api_key authentication
		}

		let urlPath = `/api/identity/v1/jwk/{kid}/invalidate`;
		urlPath = urlPath.replace(
			`{${"kid"}}`,
			encodeURIComponent(String(requestParameters.kid)),
		);

		const response = await this.request(
			{
				path: urlPath,
				method: "POST",
				headers: headerParameters,
				query: queryParameters,
			},
			initOverrides,
		);

		return new runtime.VoidApiResponse(response);
	}

	/**
	 */
	async routeInvalidateJwk(
		requestParameters: V1ApiRouteInvalidateJwkRequest,
		initOverrides?: RequestInit | runtime.InitOverrideFunction,
	): Promise<void> {
		await this.routeInvalidateJwkRaw(requestParameters, initOverrides);
	}

	/**
	 */
	async routeListApiKeysRaw(
		requestParameters: V1ApiRouteListApiKeysRequest,
		initOverrides?: RequestInit | runtime.InitOverrideFunction,
	): Promise<runtime.ApiResponse<ListApiKeysResponse>> {
		if (requestParameters.pageSize == null) {
			throw new runtime.RequiredError(
				"pageSize",
				'Required parameter "pageSize" was null or undefined when calling routeListApiKeys().',
			);
		}

		const queryParameters: any = {};

		if (requestParameters.pageSize != null) {
			queryParameters.page_size = requestParameters.pageSize;
		}

		if (requestParameters.nextPageToken != null) {
			queryParameters.next_page_token = requestParameters.nextPageToken;
		}

		const headerParameters: runtime.HTTPHeaders = {};

		if (this.configuration?.accessToken) {
			const token = this.configuration.accessToken;
			const tokenString = await token("bearer_token", []);

			if (tokenString) {
				headerParameters.Authorization = `Bearer ${tokenString}`;
			}
		}
		if (this.configuration?.apiKey) {
			headerParameters["X-API-Key"] =
				await this.configuration.apiKey("X-API-Key"); // api_key authentication
		}

		const urlPath = `/api/identity/v1/api-key`;

		const response = await this.request(
			{
				path: urlPath,
				method: "GET",
				headers: headerParameters,
				query: queryParameters,
			},
			initOverrides,
		);

		return new runtime.JSONApiResponse(response, (jsonValue) =>
			ListApiKeysResponseFromJSON(jsonValue),
		);
	}

	/**
	 */
	async routeListApiKeys(
		requestParameters: V1ApiRouteListApiKeysRequest,
		initOverrides?: RequestInit | runtime.InitOverrideFunction,
	): Promise<ListApiKeysResponse> {
		const response = await this.routeListApiKeysRaw(
			requestParameters,
			initOverrides,
		);
		return await response.value();
	}

	/**
	 */
	async routeListJwksRaw(
		requestParameters: V1ApiRouteListJwksRequest,
		initOverrides?: RequestInit | runtime.InitOverrideFunction,
	): Promise<runtime.ApiResponse<JwkResponsePaginatedResponse>> {
		if (requestParameters.pageSize == null) {
			throw new runtime.RequiredError(
				"pageSize",
				'Required parameter "pageSize" was null or undefined when calling routeListJwks().',
			);
		}

		const queryParameters: any = {};

		if (requestParameters.pageSize != null) {
			queryParameters.page_size = requestParameters.pageSize;
		}

		if (requestParameters.nextPageToken != null) {
			queryParameters.next_page_token = requestParameters.nextPageToken;
		}

		const headerParameters: runtime.HTTPHeaders = {};

		if (this.configuration?.accessToken) {
			const token = this.configuration.accessToken;
			const tokenString = await token("bearer_token", []);

			if (tokenString) {
				headerParameters.Authorization = `Bearer ${tokenString}`;
			}
		}
		if (this.configuration?.apiKey) {
			headerParameters["X-API-Key"] =
				await this.configuration.apiKey("X-API-Key"); // api_key authentication
		}

		const urlPath = `/api/identity/v1/jwk`;

		const response = await this.request(
			{
				path: urlPath,
				method: "GET",
				headers: headerParameters,
				query: queryParameters,
			},
			initOverrides,
		);

		return new runtime.JSONApiResponse(response, (jsonValue) =>
			JwkResponsePaginatedResponseFromJSON(jsonValue),
		);
	}

	/**
	 */
	async routeListJwks(
		requestParameters: V1ApiRouteListJwksRequest,
		initOverrides?: RequestInit | runtime.InitOverrideFunction,
	): Promise<JwkResponsePaginatedResponse> {
		const response = await this.routeListJwksRaw(
			requestParameters,
			initOverrides,
		);
		return await response.value();
	}

	/**
	 * List all STS configurations with optional filtering by type
	 * List STS configurations
	 */
	async routeListStsConfigsRaw(
		requestParameters: V1ApiRouteListStsConfigsRequest,
		initOverrides?: RequestInit | runtime.InitOverrideFunction,
	): Promise<runtime.ApiResponse<StsTokenConfigPaginatedResponse>> {
		if (requestParameters.pageSize == null) {
			throw new runtime.RequiredError(
				"pageSize",
				'Required parameter "pageSize" was null or undefined when calling routeListStsConfigs().',
			);
		}

		const queryParameters: any = {};

		if (requestParameters.pageSize != null) {
			queryParameters.page_size = requestParameters.pageSize;
		}

		if (requestParameters.nextPageToken != null) {
			queryParameters.next_page_token = requestParameters.nextPageToken;
		}

		const headerParameters: runtime.HTTPHeaders = {};

		if (this.configuration?.accessToken) {
			const token = this.configuration.accessToken;
			const tokenString = await token("bearer_token", []);

			if (tokenString) {
				headerParameters.Authorization = `Bearer ${tokenString}`;
			}
		}
		if (this.configuration?.apiKey) {
			headerParameters["X-API-Key"] =
				await this.configuration.apiKey("X-API-Key"); // api_key authentication
		}

		const urlPath = `/api/identity/v1/sts-configuration`;

		const response = await this.request(
			{
				path: urlPath,
				method: "GET",
				headers: headerParameters,
				query: queryParameters,
			},
			initOverrides,
		);

		return new runtime.JSONApiResponse(response, (jsonValue) =>
			StsTokenConfigPaginatedResponseFromJSON(jsonValue),
		);
	}

	/**
	 * List all STS configurations with optional filtering by type
	 * List STS configurations
	 */
	async routeListStsConfigs(
		requestParameters: V1ApiRouteListStsConfigsRequest,
		initOverrides?: RequestInit | runtime.InitOverrideFunction,
	): Promise<StsTokenConfigPaginatedResponse> {
		const response = await this.routeListStsConfigsRaw(
			requestParameters,
			initOverrides,
		);
		return await response.value();
	}

	/**
	 * List all user auth flow configurations with optional filtering by type
	 * List user auth flow configurations
	 */
	async routeListUserAuthFlowConfigsRaw(
		requestParameters: V1ApiRouteListUserAuthFlowConfigsRequest,
		initOverrides?: RequestInit | runtime.InitOverrideFunction,
	): Promise<runtime.ApiResponse<ListUserAuthFlowConfigResponse>> {
		const queryParameters: any = {};

		if (requestParameters.pageSize != null) {
			queryParameters.page_size = requestParameters.pageSize;
		}

		if (requestParameters.nextPageToken != null) {
			queryParameters.next_page_token = requestParameters.nextPageToken;
		}

		if (requestParameters.type != null) {
			queryParameters.type = requestParameters.type;
		}

		const headerParameters: runtime.HTTPHeaders = {};

		if (this.configuration?.accessToken) {
			const token = this.configuration.accessToken;
			const tokenString = await token("bearer_token", []);

			if (tokenString) {
				headerParameters.Authorization = `Bearer ${tokenString}`;
			}
		}
		if (this.configuration?.apiKey) {
			headerParameters["X-API-Key"] =
				await this.configuration.apiKey("X-API-Key"); // api_key authentication
		}

		const urlPath = `/api/identity/v1/user-auth-flow-config`;

		const response = await this.request(
			{
				path: urlPath,
				method: "GET",
				headers: headerParameters,
				query: queryParameters,
			},
			initOverrides,
		);

		return new runtime.JSONApiResponse(response, (jsonValue) =>
			ListUserAuthFlowConfigResponseFromJSON(jsonValue),
		);
	}

	/**
	 * List all user auth flow configurations with optional filtering by type
	 * List user auth flow configurations
	 */
	async routeListUserAuthFlowConfigs(
		requestParameters: V1ApiRouteListUserAuthFlowConfigsRequest = {},
		initOverrides?: RequestInit | runtime.InitOverrideFunction,
	): Promise<ListUserAuthFlowConfigResponse> {
		const response = await this.routeListUserAuthFlowConfigsRaw(
			requestParameters,
			initOverrides,
		);
		return await response.value();
	}

	/**
	 * Refreshes an access token using a refresh token from the request body or cookie
	 * Refresh access token
	 */
	async routeRefreshTokenRaw(
		requestParameters: V1ApiRouteRefreshTokenRequest,
		initOverrides?: RequestInit | runtime.InitOverrideFunction,
	): Promise<runtime.ApiResponse<TokenResponse>> {
		const queryParameters: any = {};

		const headerParameters: runtime.HTTPHeaders = {};

		headerParameters["Content-Type"] = "application/json";

		if (this.configuration?.accessToken) {
			const token = this.configuration.accessToken;
			const tokenString = await token("bearer_token", []);

			if (tokenString) {
				headerParameters.Authorization = `Bearer ${tokenString}`;
			}
		}
		if (this.configuration?.apiKey) {
			headerParameters["X-API-Key"] =
				await this.configuration.apiKey("X-API-Key"); // api_key authentication
		}

		const urlPath = `/api/identity/v1/auth/refresh`;

		const response = await this.request(
			{
				path: urlPath,
				method: "POST",
				headers: headerParameters,
				query: queryParameters,
				body: RefreshTokenRequestToJSON(requestParameters.refreshTokenRequest),
			},
			initOverrides,
		);

		return new runtime.JSONApiResponse(response, (jsonValue) =>
			TokenResponseFromJSON(jsonValue),
		);
	}

	/**
	 * Refreshes an access token using a refresh token from the request body or cookie
	 * Refresh access token
	 */
	async routeRefreshToken(
		requestParameters: V1ApiRouteRefreshTokenRequest = {},
		initOverrides?: RequestInit | runtime.InitOverrideFunction,
	): Promise<TokenResponse> {
		const response = await this.routeRefreshTokenRaw(
			requestParameters,
			initOverrides,
		);
		return await response.value();
	}

	/**
	 * Initiates the OAuth/OIDC authorization flow by redirecting to the external IdP
	 * Start authorization
	 */
	async routeStartAuthorizationRaw(
		requestParameters: V1ApiRouteStartAuthorizationRequest,
		initOverrides?: RequestInit | runtime.InitOverrideFunction,
	): Promise<runtime.ApiResponse<void>> {
		if (requestParameters.configId == null) {
			throw new runtime.RequiredError(
				"configId",
				'Required parameter "configId" was null or undefined when calling routeStartAuthorization().',
			);
		}

		const queryParameters: any = {};

		if (requestParameters.redirectAfterLogin != null) {
			queryParameters.redirect_after_login =
				requestParameters.redirectAfterLogin;
		}

		const headerParameters: runtime.HTTPHeaders = {};

		if (this.configuration?.accessToken) {
			const token = this.configuration.accessToken;
			const tokenString = await token("bearer_token", []);

			if (tokenString) {
				headerParameters.Authorization = `Bearer ${tokenString}`;
			}
		}
		if (this.configuration?.apiKey) {
			headerParameters["X-API-Key"] =
				await this.configuration.apiKey("X-API-Key"); // api_key authentication
		}

		let urlPath = `/api/identity/v1/auth/authorize/{config_id}`;
		urlPath = urlPath.replace(
			`{${"config_id"}}`,
			encodeURIComponent(String(requestParameters.configId)),
		);

		const response = await this.request(
			{
				path: urlPath,
				method: "GET",
				headers: headerParameters,
				query: queryParameters,
			},
			initOverrides,
		);

		return new runtime.VoidApiResponse(response);
	}

	/**
	 * Initiates the OAuth/OIDC authorization flow by redirecting to the external IdP
	 * Start authorization
	 */
	async routeStartAuthorization(
		requestParameters: V1ApiRouteStartAuthorizationRequest,
		initOverrides?: RequestInit | runtime.InitOverrideFunction,
	): Promise<void> {
		await this.routeStartAuthorizationRaw(requestParameters, initOverrides);
	}

	/**
	 * Returns the current authenticated identity based on the request headers (Authorization header, cookies, or API key)
	 * Get current identity
	 */
	async routeWhoamiRaw(
		initOverrides?: RequestInit | runtime.InitOverrideFunction,
	): Promise<runtime.ApiResponse<Identity>> {
		const queryParameters: any = {};

		const headerParameters: runtime.HTTPHeaders = {};

		if (this.configuration?.accessToken) {
			const token = this.configuration.accessToken;
			const tokenString = await token("bearer_token", []);

			if (tokenString) {
				headerParameters.Authorization = `Bearer ${tokenString}`;
			}
		}
		if (this.configuration?.apiKey) {
			headerParameters["X-API-Key"] =
				await this.configuration.apiKey("X-API-Key"); // api_key authentication
		}

		const urlPath = `/api/identity/v1/auth/whoami`;

		const response = await this.request(
			{
				path: urlPath,
				method: "GET",
				headers: headerParameters,
				query: queryParameters,
			},
			initOverrides,
		);

		return new runtime.JSONApiResponse(response, (jsonValue) =>
			IdentityFromJSON(jsonValue),
		);
	}

	/**
	 * Returns the current authenticated identity based on the request headers (Authorization header, cookies, or API key)
	 * Get current identity
	 */
	async routeWhoami(
		initOverrides?: RequestInit | runtime.InitOverrideFunction,
	): Promise<Identity> {
		const response = await this.routeWhoamiRaw(initOverrides);
		return await response.value();
	}

	/**
	 * Create a new group from a SCIM Group payload. Members can be specified during creation.
	 * Create SCIM Group
	 */
	async scimCreateGroupRaw(
		requestParameters: V1ApiScimCreateGroupRequest,
		initOverrides?: RequestInit | runtime.InitOverrideFunction,
	): Promise<runtime.ApiResponse<ScimGroup>> {
		if (requestParameters.scimGroup == null) {
			throw new runtime.RequiredError(
				"scimGroup",
				'Required parameter "scimGroup" was null or undefined when calling scimCreateGroup().',
			);
		}

		const queryParameters: any = {};

		const headerParameters: runtime.HTTPHeaders = {};

		headerParameters["Content-Type"] = "application/json";

		if (this.configuration?.accessToken) {
			const token = this.configuration.accessToken;
			const tokenString = await token("bearer_token", []);

			if (tokenString) {
				headerParameters.Authorization = `Bearer ${tokenString}`;
			}
		}
		if (this.configuration?.apiKey) {
			headerParameters["X-API-Key"] =
				await this.configuration.apiKey("X-API-Key"); // api_key authentication
		}

		const urlPath = `/api/identity/scim/v2/Groups`;

		const response = await this.request(
			{
				path: urlPath,
				method: "POST",
				headers: headerParameters,
				query: queryParameters,
				body: ScimGroupToJSON(requestParameters.scimGroup),
			},
			initOverrides,
		);

		return new runtime.JSONApiResponse(response, (jsonValue) =>
			ScimGroupFromJSON(jsonValue),
		);
	}

	/**
	 * Create a new group from a SCIM Group payload. Members can be specified during creation.
	 * Create SCIM Group
	 */
	async scimCreateGroup(
		requestParameters: V1ApiScimCreateGroupRequest,
		initOverrides?: RequestInit | runtime.InitOverrideFunction,
	): Promise<ScimGroup> {
		const response = await this.scimCreateGroupRaw(
			requestParameters,
			initOverrides,
		);
		return await response.value();
	}

	/**
	 * Create a new user from a SCIM User payload. The user will be created as a federated_user type.
	 * Create SCIM User
	 */
	async scimCreateUserRaw(
		requestParameters: V1ApiScimCreateUserRequest,
		initOverrides?: RequestInit | runtime.InitOverrideFunction,
	): Promise<runtime.ApiResponse<ScimUser>> {
		if (requestParameters.scimUser == null) {
			throw new runtime.RequiredError(
				"scimUser",
				'Required parameter "scimUser" was null or undefined when calling scimCreateUser().',
			);
		}

		const queryParameters: any = {};

		const headerParameters: runtime.HTTPHeaders = {};

		headerParameters["Content-Type"] = "application/json";

		if (this.configuration?.accessToken) {
			const token = this.configuration.accessToken;
			const tokenString = await token("bearer_token", []);

			if (tokenString) {
				headerParameters.Authorization = `Bearer ${tokenString}`;
			}
		}
		if (this.configuration?.apiKey) {
			headerParameters["X-API-Key"] =
				await this.configuration.apiKey("X-API-Key"); // api_key authentication
		}

		const urlPath = `/api/identity/scim/v2/Users`;

		const response = await this.request(
			{
				path: urlPath,
				method: "POST",
				headers: headerParameters,
				query: queryParameters,
				body: ScimUserToJSON(requestParameters.scimUser),
			},
			initOverrides,
		);

		return new runtime.JSONApiResponse(response, (jsonValue) =>
			ScimUserFromJSON(jsonValue),
		);
	}

	/**
	 * Create a new user from a SCIM User payload. The user will be created as a federated_user type.
	 * Create SCIM User
	 */
	async scimCreateUser(
		requestParameters: V1ApiScimCreateUserRequest,
		initOverrides?: RequestInit | runtime.InitOverrideFunction,
	): Promise<ScimUser> {
		const response = await this.scimCreateUserRaw(
			requestParameters,
			initOverrides,
		);
		return await response.value();
	}

	/**
	 * Delete a group by its unique identifier. This also removes all group memberships.
	 * Delete SCIM Group
	 */
	async scimDeleteGroupRaw(
		requestParameters: V1ApiScimDeleteGroupRequest,
		initOverrides?: RequestInit | runtime.InitOverrideFunction,
	): Promise<runtime.ApiResponse<void>> {
		if (requestParameters.groupId == null) {
			throw new runtime.RequiredError(
				"groupId",
				'Required parameter "groupId" was null or undefined when calling scimDeleteGroup().',
			);
		}

		const queryParameters: any = {};

		const headerParameters: runtime.HTTPHeaders = {};

		if (this.configuration?.accessToken) {
			const token = this.configuration.accessToken;
			const tokenString = await token("bearer_token", []);

			if (tokenString) {
				headerParameters.Authorization = `Bearer ${tokenString}`;
			}
		}
		if (this.configuration?.apiKey) {
			headerParameters["X-API-Key"] =
				await this.configuration.apiKey("X-API-Key"); // api_key authentication
		}

		let urlPath = `/api/identity/scim/v2/Groups/{group_id}`;
		urlPath = urlPath.replace(
			`{${"group_id"}}`,
			encodeURIComponent(String(requestParameters.groupId)),
		);

		const response = await this.request(
			{
				path: urlPath,
				method: "DELETE",
				headers: headerParameters,
				query: queryParameters,
			},
			initOverrides,
		);

		return new runtime.VoidApiResponse(response);
	}

	/**
	 * Delete a group by its unique identifier. This also removes all group memberships.
	 * Delete SCIM Group
	 */
	async scimDeleteGroup(
		requestParameters: V1ApiScimDeleteGroupRequest,
		initOverrides?: RequestInit | runtime.InitOverrideFunction,
	): Promise<void> {
		await this.scimDeleteGroupRaw(requestParameters, initOverrides);
	}

	/**
	 * Delete a user by their unique identifier. This also removes the user from all groups.
	 * Delete SCIM User
	 */
	async scimDeleteUserRaw(
		requestParameters: V1ApiScimDeleteUserRequest,
		initOverrides?: RequestInit | runtime.InitOverrideFunction,
	): Promise<runtime.ApiResponse<void>> {
		if (requestParameters.userId == null) {
			throw new runtime.RequiredError(
				"userId",
				'Required parameter "userId" was null or undefined when calling scimDeleteUser().',
			);
		}

		const queryParameters: any = {};

		const headerParameters: runtime.HTTPHeaders = {};

		if (this.configuration?.accessToken) {
			const token = this.configuration.accessToken;
			const tokenString = await token("bearer_token", []);

			if (tokenString) {
				headerParameters.Authorization = `Bearer ${tokenString}`;
			}
		}
		if (this.configuration?.apiKey) {
			headerParameters["X-API-Key"] =
				await this.configuration.apiKey("X-API-Key"); // api_key authentication
		}

		let urlPath = `/api/identity/scim/v2/Users/{user_id}`;
		urlPath = urlPath.replace(
			`{${"user_id"}}`,
			encodeURIComponent(String(requestParameters.userId)),
		);

		const response = await this.request(
			{
				path: urlPath,
				method: "DELETE",
				headers: headerParameters,
				query: queryParameters,
			},
			initOverrides,
		);

		return new runtime.VoidApiResponse(response);
	}

	/**
	 * Delete a user by their unique identifier. This also removes the user from all groups.
	 * Delete SCIM User
	 */
	async scimDeleteUser(
		requestParameters: V1ApiScimDeleteUserRequest,
		initOverrides?: RequestInit | runtime.InitOverrideFunction,
	): Promise<void> {
		await this.scimDeleteUserRaw(requestParameters, initOverrides);
	}

	/**
	 * Retrieve a group by its unique identifier in SCIM format, including its members.
	 * Get SCIM Group
	 */
	async scimGetGroupRaw(
		requestParameters: V1ApiScimGetGroupRequest,
		initOverrides?: RequestInit | runtime.InitOverrideFunction,
	): Promise<runtime.ApiResponse<ScimGroup>> {
		if (requestParameters.groupId == null) {
			throw new runtime.RequiredError(
				"groupId",
				'Required parameter "groupId" was null or undefined when calling scimGetGroup().',
			);
		}

		const queryParameters: any = {};

		const headerParameters: runtime.HTTPHeaders = {};

		if (this.configuration?.accessToken) {
			const token = this.configuration.accessToken;
			const tokenString = await token("bearer_token", []);

			if (tokenString) {
				headerParameters.Authorization = `Bearer ${tokenString}`;
			}
		}
		if (this.configuration?.apiKey) {
			headerParameters["X-API-Key"] =
				await this.configuration.apiKey("X-API-Key"); // api_key authentication
		}

		let urlPath = `/api/identity/scim/v2/Groups/{group_id}`;
		urlPath = urlPath.replace(
			`{${"group_id"}}`,
			encodeURIComponent(String(requestParameters.groupId)),
		);

		const response = await this.request(
			{
				path: urlPath,
				method: "GET",
				headers: headerParameters,
				query: queryParameters,
			},
			initOverrides,
		);

		return new runtime.JSONApiResponse(response, (jsonValue) =>
			ScimGroupFromJSON(jsonValue),
		);
	}

	/**
	 * Retrieve a group by its unique identifier in SCIM format, including its members.
	 * Get SCIM Group
	 */
	async scimGetGroup(
		requestParameters: V1ApiScimGetGroupRequest,
		initOverrides?: RequestInit | runtime.InitOverrideFunction,
	): Promise<ScimGroup> {
		const response = await this.scimGetGroupRaw(
			requestParameters,
			initOverrides,
		);
		return await response.value();
	}

	/**
	 * Retrieve a user by their unique identifier in SCIM format.
	 * Get SCIM User
	 */
	async scimGetUserRaw(
		requestParameters: V1ApiScimGetUserRequest,
		initOverrides?: RequestInit | runtime.InitOverrideFunction,
	): Promise<runtime.ApiResponse<ScimUser>> {
		if (requestParameters.userId == null) {
			throw new runtime.RequiredError(
				"userId",
				'Required parameter "userId" was null or undefined when calling scimGetUser().',
			);
		}

		const queryParameters: any = {};

		const headerParameters: runtime.HTTPHeaders = {};

		if (this.configuration?.accessToken) {
			const token = this.configuration.accessToken;
			const tokenString = await token("bearer_token", []);

			if (tokenString) {
				headerParameters.Authorization = `Bearer ${tokenString}`;
			}
		}
		if (this.configuration?.apiKey) {
			headerParameters["X-API-Key"] =
				await this.configuration.apiKey("X-API-Key"); // api_key authentication
		}

		let urlPath = `/api/identity/scim/v2/Users/{user_id}`;
		urlPath = urlPath.replace(
			`{${"user_id"}}`,
			encodeURIComponent(String(requestParameters.userId)),
		);

		const response = await this.request(
			{
				path: urlPath,
				method: "GET",
				headers: headerParameters,
				query: queryParameters,
			},
			initOverrides,
		);

		return new runtime.JSONApiResponse(response, (jsonValue) =>
			ScimUserFromJSON(jsonValue),
		);
	}

	/**
	 * Retrieve a user by their unique identifier in SCIM format.
	 * Get SCIM User
	 */
	async scimGetUser(
		requestParameters: V1ApiScimGetUserRequest,
		initOverrides?: RequestInit | runtime.InitOverrideFunction,
	): Promise<ScimUser> {
		const response = await this.scimGetUserRaw(
			requestParameters,
			initOverrides,
		);
		return await response.value();
	}

	/**
	 * List all groups with SCIM pagination. Supports filtering by various attributes.
	 * List SCIM Groups
	 */
	async scimListGroupsRaw(
		requestParameters: V1ApiScimListGroupsRequest,
		initOverrides?: RequestInit | runtime.InitOverrideFunction,
	): Promise<runtime.ApiResponse<ScimListResponse>> {
		const queryParameters: any = {};

		if (requestParameters.filter != null) {
			queryParameters.filter = requestParameters.filter;
		}

		if (requestParameters.sortBy != null) {
			queryParameters.sortBy = requestParameters.sortBy;
		}

		if (requestParameters.sortOrder != null) {
			queryParameters.sortOrder = requestParameters.sortOrder;
		}

		if (requestParameters.startIndex != null) {
			queryParameters.startIndex = requestParameters.startIndex;
		}

		if (requestParameters.count != null) {
			queryParameters.count = requestParameters.count;
		}

		const headerParameters: runtime.HTTPHeaders = {};

		if (this.configuration?.accessToken) {
			const token = this.configuration.accessToken;
			const tokenString = await token("bearer_token", []);

			if (tokenString) {
				headerParameters.Authorization = `Bearer ${tokenString}`;
			}
		}
		if (this.configuration?.apiKey) {
			headerParameters["X-API-Key"] =
				await this.configuration.apiKey("X-API-Key"); // api_key authentication
		}

		const urlPath = `/api/identity/scim/v2/Groups`;

		const response = await this.request(
			{
				path: urlPath,
				method: "GET",
				headers: headerParameters,
				query: queryParameters,
			},
			initOverrides,
		);

		return new runtime.JSONApiResponse(response, (jsonValue) =>
			ScimListResponseFromJSON(jsonValue),
		);
	}

	/**
	 * List all groups with SCIM pagination. Supports filtering by various attributes.
	 * List SCIM Groups
	 */
	async scimListGroups(
		requestParameters: V1ApiScimListGroupsRequest = {},
		initOverrides?: RequestInit | runtime.InitOverrideFunction,
	): Promise<ScimListResponse> {
		const response = await this.scimListGroupsRaw(
			requestParameters,
			initOverrides,
		);
		return await response.value();
	}

	/**
	 * List all users with SCIM pagination. Supports filtering by various attributes.
	 * List SCIM Users
	 */
	async scimListUsersRaw(
		requestParameters: V1ApiScimListUsersRequest,
		initOverrides?: RequestInit | runtime.InitOverrideFunction,
	): Promise<runtime.ApiResponse<ScimListResponse>> {
		const queryParameters: any = {};

		if (requestParameters.filter != null) {
			queryParameters.filter = requestParameters.filter;
		}

		if (requestParameters.sortBy != null) {
			queryParameters.sortBy = requestParameters.sortBy;
		}

		if (requestParameters.sortOrder != null) {
			queryParameters.sortOrder = requestParameters.sortOrder;
		}

		if (requestParameters.startIndex != null) {
			queryParameters.startIndex = requestParameters.startIndex;
		}

		if (requestParameters.count != null) {
			queryParameters.count = requestParameters.count;
		}

		const headerParameters: runtime.HTTPHeaders = {};

		if (this.configuration?.accessToken) {
			const token = this.configuration.accessToken;
			const tokenString = await token("bearer_token", []);

			if (tokenString) {
				headerParameters.Authorization = `Bearer ${tokenString}`;
			}
		}
		if (this.configuration?.apiKey) {
			headerParameters["X-API-Key"] =
				await this.configuration.apiKey("X-API-Key"); // api_key authentication
		}

		const urlPath = `/api/identity/scim/v2/Users`;

		const response = await this.request(
			{
				path: urlPath,
				method: "GET",
				headers: headerParameters,
				query: queryParameters,
			},
			initOverrides,
		);

		return new runtime.JSONApiResponse(response, (jsonValue) =>
			ScimListResponseFromJSON(jsonValue),
		);
	}

	/**
	 * List all users with SCIM pagination. Supports filtering by various attributes.
	 * List SCIM Users
	 */
	async scimListUsers(
		requestParameters: V1ApiScimListUsersRequest = {},
		initOverrides?: RequestInit | runtime.InitOverrideFunction,
	): Promise<ScimListResponse> {
		const response = await this.scimListUsersRaw(
			requestParameters,
			initOverrides,
		);
		return await response.value();
	}

	/**
	 * Partially update a group\'s attributes or members using SCIM PATCH operations (add, remove, replace).
	 * Patch SCIM Group
	 */
	async scimPatchGroupRaw(
		requestParameters: V1ApiScimPatchGroupRequest,
		initOverrides?: RequestInit | runtime.InitOverrideFunction,
	): Promise<runtime.ApiResponse<ScimGroup>> {
		if (requestParameters.groupId == null) {
			throw new runtime.RequiredError(
				"groupId",
				'Required parameter "groupId" was null or undefined when calling scimPatchGroup().',
			);
		}

		if (requestParameters.scimPatchRequest == null) {
			throw new runtime.RequiredError(
				"scimPatchRequest",
				'Required parameter "scimPatchRequest" was null or undefined when calling scimPatchGroup().',
			);
		}

		const queryParameters: any = {};

		const headerParameters: runtime.HTTPHeaders = {};

		headerParameters["Content-Type"] = "application/json";

		if (this.configuration?.accessToken) {
			const token = this.configuration.accessToken;
			const tokenString = await token("bearer_token", []);

			if (tokenString) {
				headerParameters.Authorization = `Bearer ${tokenString}`;
			}
		}
		if (this.configuration?.apiKey) {
			headerParameters["X-API-Key"] =
				await this.configuration.apiKey("X-API-Key"); // api_key authentication
		}

		let urlPath = `/api/identity/scim/v2/Groups/{group_id}`;
		urlPath = urlPath.replace(
			`{${"group_id"}}`,
			encodeURIComponent(String(requestParameters.groupId)),
		);

		const response = await this.request(
			{
				path: urlPath,
				method: "PATCH",
				headers: headerParameters,
				query: queryParameters,
				body: ScimPatchRequestToJSON(requestParameters.scimPatchRequest),
			},
			initOverrides,
		);

		return new runtime.JSONApiResponse(response, (jsonValue) =>
			ScimGroupFromJSON(jsonValue),
		);
	}

	/**
	 * Partially update a group\'s attributes or members using SCIM PATCH operations (add, remove, replace).
	 * Patch SCIM Group
	 */
	async scimPatchGroup(
		requestParameters: V1ApiScimPatchGroupRequest,
		initOverrides?: RequestInit | runtime.InitOverrideFunction,
	): Promise<ScimGroup> {
		const response = await this.scimPatchGroupRaw(
			requestParameters,
			initOverrides,
		);
		return await response.value();
	}

	/**
	 * Partially update a user\'s attributes using SCIM PATCH operations (add, remove, replace).
	 * Patch SCIM User
	 */
	async scimPatchUserRaw(
		requestParameters: V1ApiScimPatchUserRequest,
		initOverrides?: RequestInit | runtime.InitOverrideFunction,
	): Promise<runtime.ApiResponse<ScimUser>> {
		if (requestParameters.userId == null) {
			throw new runtime.RequiredError(
				"userId",
				'Required parameter "userId" was null or undefined when calling scimPatchUser().',
			);
		}

		if (requestParameters.scimPatchRequest == null) {
			throw new runtime.RequiredError(
				"scimPatchRequest",
				'Required parameter "scimPatchRequest" was null or undefined when calling scimPatchUser().',
			);
		}

		const queryParameters: any = {};

		const headerParameters: runtime.HTTPHeaders = {};

		headerParameters["Content-Type"] = "application/json";

		if (this.configuration?.accessToken) {
			const token = this.configuration.accessToken;
			const tokenString = await token("bearer_token", []);

			if (tokenString) {
				headerParameters.Authorization = `Bearer ${tokenString}`;
			}
		}
		if (this.configuration?.apiKey) {
			headerParameters["X-API-Key"] =
				await this.configuration.apiKey("X-API-Key"); // api_key authentication
		}

		let urlPath = `/api/identity/scim/v2/Users/{user_id}`;
		urlPath = urlPath.replace(
			`{${"user_id"}}`,
			encodeURIComponent(String(requestParameters.userId)),
		);

		const response = await this.request(
			{
				path: urlPath,
				method: "PATCH",
				headers: headerParameters,
				query: queryParameters,
				body: ScimPatchRequestToJSON(requestParameters.scimPatchRequest),
			},
			initOverrides,
		);

		return new runtime.JSONApiResponse(response, (jsonValue) =>
			ScimUserFromJSON(jsonValue),
		);
	}

	/**
	 * Partially update a user\'s attributes using SCIM PATCH operations (add, remove, replace).
	 * Patch SCIM User
	 */
	async scimPatchUser(
		requestParameters: V1ApiScimPatchUserRequest,
		initOverrides?: RequestInit | runtime.InitOverrideFunction,
	): Promise<ScimUser> {
		const response = await this.scimPatchUserRaw(
			requestParameters,
			initOverrides,
		);
		return await response.value();
	}

	/**
	 * Replace a group\'s attributes and members with the provided SCIM Group payload (PUT operation).
	 * Replace SCIM Group
	 */
	async scimReplaceGroupRaw(
		requestParameters: V1ApiScimReplaceGroupRequest,
		initOverrides?: RequestInit | runtime.InitOverrideFunction,
	): Promise<runtime.ApiResponse<ScimGroup>> {
		if (requestParameters.groupId == null) {
			throw new runtime.RequiredError(
				"groupId",
				'Required parameter "groupId" was null or undefined when calling scimReplaceGroup().',
			);
		}

		if (requestParameters.scimGroup == null) {
			throw new runtime.RequiredError(
				"scimGroup",
				'Required parameter "scimGroup" was null or undefined when calling scimReplaceGroup().',
			);
		}

		const queryParameters: any = {};

		const headerParameters: runtime.HTTPHeaders = {};

		headerParameters["Content-Type"] = "application/json";

		if (this.configuration?.accessToken) {
			const token = this.configuration.accessToken;
			const tokenString = await token("bearer_token", []);

			if (tokenString) {
				headerParameters.Authorization = `Bearer ${tokenString}`;
			}
		}
		if (this.configuration?.apiKey) {
			headerParameters["X-API-Key"] =
				await this.configuration.apiKey("X-API-Key"); // api_key authentication
		}

		let urlPath = `/api/identity/scim/v2/Groups/{group_id}`;
		urlPath = urlPath.replace(
			`{${"group_id"}}`,
			encodeURIComponent(String(requestParameters.groupId)),
		);

		const response = await this.request(
			{
				path: urlPath,
				method: "PUT",
				headers: headerParameters,
				query: queryParameters,
				body: ScimGroupToJSON(requestParameters.scimGroup),
			},
			initOverrides,
		);

		return new runtime.JSONApiResponse(response, (jsonValue) =>
			ScimGroupFromJSON(jsonValue),
		);
	}

	/**
	 * Replace a group\'s attributes and members with the provided SCIM Group payload (PUT operation).
	 * Replace SCIM Group
	 */
	async scimReplaceGroup(
		requestParameters: V1ApiScimReplaceGroupRequest,
		initOverrides?: RequestInit | runtime.InitOverrideFunction,
	): Promise<ScimGroup> {
		const response = await this.scimReplaceGroupRaw(
			requestParameters,
			initOverrides,
		);
		return await response.value();
	}

	/**
	 * Replace a user\'s attributes with the provided SCIM User payload (PUT operation).
	 * Replace SCIM User
	 */
	async scimReplaceUserRaw(
		requestParameters: V1ApiScimReplaceUserRequest,
		initOverrides?: RequestInit | runtime.InitOverrideFunction,
	): Promise<runtime.ApiResponse<ScimUser>> {
		if (requestParameters.userId == null) {
			throw new runtime.RequiredError(
				"userId",
				'Required parameter "userId" was null or undefined when calling scimReplaceUser().',
			);
		}

		if (requestParameters.scimUser == null) {
			throw new runtime.RequiredError(
				"scimUser",
				'Required parameter "scimUser" was null or undefined when calling scimReplaceUser().',
			);
		}

		const queryParameters: any = {};

		const headerParameters: runtime.HTTPHeaders = {};

		headerParameters["Content-Type"] = "application/json";

		if (this.configuration?.accessToken) {
			const token = this.configuration.accessToken;
			const tokenString = await token("bearer_token", []);

			if (tokenString) {
				headerParameters.Authorization = `Bearer ${tokenString}`;
			}
		}
		if (this.configuration?.apiKey) {
			headerParameters["X-API-Key"] =
				await this.configuration.apiKey("X-API-Key"); // api_key authentication
		}

		let urlPath = `/api/identity/scim/v2/Users/{user_id}`;
		urlPath = urlPath.replace(
			`{${"user_id"}}`,
			encodeURIComponent(String(requestParameters.userId)),
		);

		const response = await this.request(
			{
				path: urlPath,
				method: "PUT",
				headers: headerParameters,
				query: queryParameters,
				body: ScimUserToJSON(requestParameters.scimUser),
			},
			initOverrides,
		);

		return new runtime.JSONApiResponse(response, (jsonValue) =>
			ScimUserFromJSON(jsonValue),
		);
	}

	/**
	 * Replace a user\'s attributes with the provided SCIM User payload (PUT operation).
	 * Replace SCIM User
	 */
	async scimReplaceUser(
		requestParameters: V1ApiScimReplaceUserRequest,
		initOverrides?: RequestInit | runtime.InitOverrideFunction,
	): Promise<ScimUser> {
		const response = await this.scimReplaceUserRaw(
			requestParameters,
			initOverrides,
		);
		return await response.value();
	}

	/**
	 * Send a message to a task
	 * Send message
	 */
	async sendMessageRaw(
		requestParameters: V1ApiSendMessageRequest,
		initOverrides?: RequestInit | runtime.InitOverrideFunction,
	): Promise<runtime.ApiResponse<CreateMessageResponse>> {
		if (requestParameters.taskId == null) {
			throw new runtime.RequiredError(
				"taskId",
				'Required parameter "taskId" was null or undefined when calling sendMessage().',
			);
		}

		if (requestParameters.createMessageRequest == null) {
			throw new runtime.RequiredError(
				"createMessageRequest",
				'Required parameter "createMessageRequest" was null or undefined when calling sendMessage().',
			);
		}

		const queryParameters: any = {};

		const headerParameters: runtime.HTTPHeaders = {};

		headerParameters["Content-Type"] = "application/json";

		if (this.configuration?.accessToken) {
			const token = this.configuration.accessToken;
			const tokenString = await token("bearer_token", []);

			if (tokenString) {
				headerParameters.Authorization = `Bearer ${tokenString}`;
			}
		}
		if (this.configuration?.apiKey) {
			headerParameters["X-API-Key"] =
				await this.configuration.apiKey("X-API-Key"); // api_key authentication
		}

		let urlPath = `/api/task/v1/{task_id}/message`;
		urlPath = urlPath.replace(
			`{${"task_id"}}`,
			encodeURIComponent(String(requestParameters.taskId)),
		);

		const response = await this.request(
			{
				path: urlPath,
				method: "POST",
				headers: headerParameters,
				query: queryParameters,
				body: CreateMessageRequestToJSON(
					requestParameters.createMessageRequest,
				),
			},
			initOverrides,
		);

		return new runtime.JSONApiResponse(response, (jsonValue) =>
			CreateMessageResponseFromJSON(jsonValue),
		);
	}

	/**
	 * Send a message to a task
	 * Send message
	 */
	async sendMessage(
		requestParameters: V1ApiSendMessageRequest,
		initOverrides?: RequestInit | runtime.InitOverrideFunction,
	): Promise<CreateMessageResponse> {
		const response = await this.sendMessageRaw(
			requestParameters,
			initOverrides,
		);
		return await response.value();
	}

	/**
	 * Start the OAuth flow for user credential brokering
	 * Start credential brokering
	 */
	async startUserCredentialBrokeringRaw(
		requestParameters: V1ApiStartUserCredentialBrokeringRequest,
		initOverrides?: RequestInit | runtime.InitOverrideFunction,
	): Promise<runtime.ApiResponse<UserCredentialBrokeringResponse>> {
		if (requestParameters.providerControllerTypeId == null) {
			throw new runtime.RequiredError(
				"providerControllerTypeId",
				'Required parameter "providerControllerTypeId" was null or undefined when calling startUserCredentialBrokering().',
			);
		}

		if (requestParameters.credentialControllerTypeId == null) {
			throw new runtime.RequiredError(
				"credentialControllerTypeId",
				'Required parameter "credentialControllerTypeId" was null or undefined when calling startUserCredentialBrokering().',
			);
		}

		if (requestParameters.startUserCredentialBrokeringParamsInner == null) {
			throw new runtime.RequiredError(
				"startUserCredentialBrokeringParamsInner",
				'Required parameter "startUserCredentialBrokeringParamsInner" was null or undefined when calling startUserCredentialBrokering().',
			);
		}

		const queryParameters: any = {};

		const headerParameters: runtime.HTTPHeaders = {};

		headerParameters["Content-Type"] = "application/json";

		if (this.configuration?.accessToken) {
			const token = this.configuration.accessToken;
			const tokenString = await token("bearer_token", []);

			if (tokenString) {
				headerParameters.Authorization = `Bearer ${tokenString}`;
			}
		}
		if (this.configuration?.apiKey) {
			headerParameters["X-API-Key"] =
				await this.configuration.apiKey("X-API-Key"); // api_key authentication
		}

		let urlPath = `/api/mcp/v1/available-providers/{provider_controller_type_id}/available-credentials/{credential_controller_type_id}/credential/user-credential/broker`;
		urlPath = urlPath.replace(
			`{${"provider_controller_type_id"}}`,
			encodeURIComponent(String(requestParameters.providerControllerTypeId)),
		);
		urlPath = urlPath.replace(
			`{${"credential_controller_type_id"}}`,
			encodeURIComponent(String(requestParameters.credentialControllerTypeId)),
		);

		const response = await this.request(
			{
				path: urlPath,
				method: "POST",
				headers: headerParameters,
				query: queryParameters,
				body: StartUserCredentialBrokeringParamsInnerToJSON(
					requestParameters.startUserCredentialBrokeringParamsInner,
				),
			},
			initOverrides,
		);

		return new runtime.JSONApiResponse(response, (jsonValue) =>
			UserCredentialBrokeringResponseFromJSON(jsonValue),
		);
	}

	/**
	 * Start the OAuth flow for user credential brokering
	 * Start credential brokering
	 */
	async startUserCredentialBrokering(
		requestParameters: V1ApiStartUserCredentialBrokeringRequest,
		initOverrides?: RequestInit | runtime.InitOverrideFunction,
	): Promise<UserCredentialBrokeringResponse> {
		const response = await this.startUserCredentialBrokeringRaw(
			requestParameters,
			initOverrides,
		);
		return await response.value();
	}

	/**
	 * Get the timeline history of a task with pagination
	 * Get task timeline
	 */
	async taskHistoryRaw(
		requestParameters: V1ApiTaskHistoryRequest,
		initOverrides?: RequestInit | runtime.InitOverrideFunction,
	): Promise<runtime.ApiResponse<TaskTimelineItemPaginatedResponse>> {
		if (requestParameters.pageSize == null) {
			throw new runtime.RequiredError(
				"pageSize",
				'Required parameter "pageSize" was null or undefined when calling taskHistory().',
			);
		}

		if (requestParameters.taskId == null) {
			throw new runtime.RequiredError(
				"taskId",
				'Required parameter "taskId" was null or undefined when calling taskHistory().',
			);
		}

		const queryParameters: any = {};

		if (requestParameters.pageSize != null) {
			queryParameters.page_size = requestParameters.pageSize;
		}

		if (requestParameters.nextPageToken != null) {
			queryParameters.next_page_token = requestParameters.nextPageToken;
		}

		const headerParameters: runtime.HTTPHeaders = {};

		if (this.configuration?.accessToken) {
			const token = this.configuration.accessToken;
			const tokenString = await token("bearer_token", []);

			if (tokenString) {
				headerParameters.Authorization = `Bearer ${tokenString}`;
			}
		}
		if (this.configuration?.apiKey) {
			headerParameters["X-API-Key"] =
				await this.configuration.apiKey("X-API-Key"); // api_key authentication
		}

		let urlPath = `/api/task/v1/{task_id}/timeline`;
		urlPath = urlPath.replace(
			`{${"task_id"}}`,
			encodeURIComponent(String(requestParameters.taskId)),
		);

		const response = await this.request(
			{
				path: urlPath,
				method: "GET",
				headers: headerParameters,
				query: queryParameters,
			},
			initOverrides,
		);

		return new runtime.JSONApiResponse(response, (jsonValue) =>
			TaskTimelineItemPaginatedResponseFromJSON(jsonValue),
		);
	}

	/**
	 * Get the timeline history of a task with pagination
	 * Get task timeline
	 */
	async taskHistory(
		requestParameters: V1ApiTaskHistoryRequest,
		initOverrides?: RequestInit | runtime.InitOverrideFunction,
	): Promise<TaskTimelineItemPaginatedResponse> {
		const response = await this.taskHistoryRaw(
			requestParameters,
			initOverrides,
		);
		return await response.value();
	}

	/**
	 * Trigger code generation for the SDK
	 * Trigger codegen
	 */
	async triggerCodegenRaw(
		initOverrides?: RequestInit | runtime.InitOverrideFunction,
	): Promise<runtime.ApiResponse<object>> {
		const queryParameters: any = {};

		const headerParameters: runtime.HTTPHeaders = {};

		if (this.configuration?.accessToken) {
			const token = this.configuration.accessToken;
			const tokenString = await token("bearer_token", []);

			if (tokenString) {
				headerParameters.Authorization = `Bearer ${tokenString}`;
			}
		}
		if (this.configuration?.apiKey) {
			headerParameters["X-API-Key"] =
				await this.configuration.apiKey("X-API-Key"); // api_key authentication
		}

		const urlPath = `/_internal/v1/trigger_codegen`;

		const response = await this.request(
			{
				path: urlPath,
				method: "POST",
				headers: headerParameters,
				query: queryParameters,
			},
			initOverrides,
		);

		return new runtime.JSONApiResponse<any>(response);
	}

	/**
	 * Trigger code generation for the SDK
	 * Trigger codegen
	 */
	async triggerCodegen(
		initOverrides?: RequestInit | runtime.InitOverrideFunction,
	): Promise<object> {
		const response = await this.triggerCodegenRaw(initOverrides);
		return await response.value();
	}

	/**
	 * Update the alias for a data encryption key
	 * Update DEK alias
	 */
	async updateDekAliasRaw(
		requestParameters: V1ApiUpdateDekAliasRequest,
		initOverrides?: RequestInit | runtime.InitOverrideFunction,
	): Promise<runtime.ApiResponse<DataEncryptionKeyAlias>> {
		if (requestParameters.alias == null) {
			throw new runtime.RequiredError(
				"alias",
				'Required parameter "alias" was null or undefined when calling updateDekAlias().',
			);
		}

		if (requestParameters.updateAliasParams == null) {
			throw new runtime.RequiredError(
				"updateAliasParams",
				'Required parameter "updateAliasParams" was null or undefined when calling updateDekAlias().',
			);
		}

		const queryParameters: any = {};

		const headerParameters: runtime.HTTPHeaders = {};

		headerParameters["Content-Type"] = "application/json";

		if (this.configuration?.accessToken) {
			const token = this.configuration.accessToken;
			const tokenString = await token("bearer_token", []);

			if (tokenString) {
				headerParameters.Authorization = `Bearer ${tokenString}`;
			}
		}
		if (this.configuration?.apiKey) {
			headerParameters["X-API-Key"] =
				await this.configuration.apiKey("X-API-Key"); // api_key authentication
		}

		let urlPath = `/api/encryption/v1/dek/alias/{alias}`;
		urlPath = urlPath.replace(
			`{${"alias"}}`,
			encodeURIComponent(String(requestParameters.alias)),
		);

		const response = await this.request(
			{
				path: urlPath,
				method: "PUT",
				headers: headerParameters,
				query: queryParameters,
				body: UpdateAliasParamsToJSON(requestParameters.updateAliasParams),
			},
			initOverrides,
		);

		return new runtime.JSONApiResponse(response, (jsonValue) =>
			DataEncryptionKeyAliasFromJSON(jsonValue),
		);
	}

	/**
	 * Update the alias for a data encryption key
	 * Update DEK alias
	 */
	async updateDekAlias(
		requestParameters: V1ApiUpdateDekAliasRequest,
		initOverrides?: RequestInit | runtime.InitOverrideFunction,
	): Promise<DataEncryptionKeyAlias> {
		const response = await this.updateDekAliasRaw(
			requestParameters,
			initOverrides,
		);
		return await response.value();
	}

	/**
	 * Update a group\'s name
	 * Update group
	 */
	async updateGroupRaw(
		requestParameters: V1ApiUpdateGroupOperationRequest,
		initOverrides?: RequestInit | runtime.InitOverrideFunction,
	): Promise<runtime.ApiResponse<Group>> {
		if (requestParameters.groupId == null) {
			throw new runtime.RequiredError(
				"groupId",
				'Required parameter "groupId" was null or undefined when calling updateGroup().',
			);
		}

		if (requestParameters.updateGroupRequest == null) {
			throw new runtime.RequiredError(
				"updateGroupRequest",
				'Required parameter "updateGroupRequest" was null or undefined when calling updateGroup().',
			);
		}

		const queryParameters: any = {};

		const headerParameters: runtime.HTTPHeaders = {};

		headerParameters["Content-Type"] = "application/json";

		if (this.configuration?.accessToken) {
			const token = this.configuration.accessToken;
			const tokenString = await token("bearer_token", []);

			if (tokenString) {
				headerParameters.Authorization = `Bearer ${tokenString}`;
			}
		}
		if (this.configuration?.apiKey) {
			headerParameters["X-API-Key"] =
				await this.configuration.apiKey("X-API-Key"); // api_key authentication
		}

		let urlPath = `/api/identity/v1/groups/{group_id}`;
		urlPath = urlPath.replace(
			`{${"group_id"}}`,
			encodeURIComponent(String(requestParameters.groupId)),
		);

		const response = await this.request(
			{
				path: urlPath,
				method: "PATCH",
				headers: headerParameters,
				query: queryParameters,
				body: UpdateGroupRequestToJSON(requestParameters.updateGroupRequest),
			},
			initOverrides,
		);

		return new runtime.JSONApiResponse(response, (jsonValue) =>
			GroupFromJSON(jsonValue),
		);
	}

	/**
	 * Update a group\'s name
	 * Update group
	 */
	async updateGroup(
		requestParameters: V1ApiUpdateGroupOperationRequest,
		initOverrides?: RequestInit | runtime.InitOverrideFunction,
	): Promise<Group> {
		const response = await this.updateGroupRaw(
			requestParameters,
			initOverrides,
		);
		return await response.value();
	}

	/**
	 * Update an MCP server instance name
	 * Update MCP server instance
	 */
	async updateMcpServerInstanceRaw(
		requestParameters: V1ApiUpdateMcpServerInstanceOperationRequest,
		initOverrides?: RequestInit | runtime.InitOverrideFunction,
	): Promise<runtime.ApiResponse<McpServerInstanceSerializedWithFunctions>> {
		if (requestParameters.mcpServerInstanceId == null) {
			throw new runtime.RequiredError(
				"mcpServerInstanceId",
				'Required parameter "mcpServerInstanceId" was null or undefined when calling updateMcpServerInstance().',
			);
		}

		if (requestParameters.updateMcpServerInstanceRequest == null) {
			throw new runtime.RequiredError(
				"updateMcpServerInstanceRequest",
				'Required parameter "updateMcpServerInstanceRequest" was null or undefined when calling updateMcpServerInstance().',
			);
		}

		const queryParameters: any = {};

		const headerParameters: runtime.HTTPHeaders = {};

		headerParameters["Content-Type"] = "application/json";

		if (this.configuration?.accessToken) {
			const token = this.configuration.accessToken;
			const tokenString = await token("bearer_token", []);

			if (tokenString) {
				headerParameters.Authorization = `Bearer ${tokenString}`;
			}
		}
		if (this.configuration?.apiKey) {
			headerParameters["X-API-Key"] =
				await this.configuration.apiKey("X-API-Key"); // api_key authentication
		}

		let urlPath = `/api/mcp/v1/mcp-server/{mcp_server_instance_id}`;
		urlPath = urlPath.replace(
			`{${"mcp_server_instance_id"}}`,
			encodeURIComponent(String(requestParameters.mcpServerInstanceId)),
		);

		const response = await this.request(
			{
				path: urlPath,
				method: "PATCH",
				headers: headerParameters,
				query: queryParameters,
				body: UpdateMcpServerInstanceRequestToJSON(
					requestParameters.updateMcpServerInstanceRequest,
				),
			},
			initOverrides,
		);

		return new runtime.JSONApiResponse(response, (jsonValue) =>
			McpServerInstanceSerializedWithFunctionsFromJSON(jsonValue),
		);
	}

	/**
	 * Update an MCP server instance name
	 * Update MCP server instance
	 */
	async updateMcpServerInstance(
		requestParameters: V1ApiUpdateMcpServerInstanceOperationRequest,
		initOverrides?: RequestInit | runtime.InitOverrideFunction,
	): Promise<McpServerInstanceSerializedWithFunctions> {
		const response = await this.updateMcpServerInstanceRaw(
			requestParameters,
			initOverrides,
		);
		return await response.value();
	}

	/**
	 * Update the function name and description for a function mapping
	 * Update function in MCP server instance
	 */
	async updateMcpServerInstanceFunctionRaw(
		requestParameters: V1ApiUpdateMcpServerInstanceFunctionOperationRequest,
		initOverrides?: RequestInit | runtime.InitOverrideFunction,
	): Promise<runtime.ApiResponse<McpServerInstanceSerializedWithFunctions>> {
		if (requestParameters.mcpServerInstanceId == null) {
			throw new runtime.RequiredError(
				"mcpServerInstanceId",
				'Required parameter "mcpServerInstanceId" was null or undefined when calling updateMcpServerInstanceFunction().',
			);
		}

		if (requestParameters.functionControllerTypeId == null) {
			throw new runtime.RequiredError(
				"functionControllerTypeId",
				'Required parameter "functionControllerTypeId" was null or undefined when calling updateMcpServerInstanceFunction().',
			);
		}

		if (requestParameters.providerControllerTypeId == null) {
			throw new runtime.RequiredError(
				"providerControllerTypeId",
				'Required parameter "providerControllerTypeId" was null or undefined when calling updateMcpServerInstanceFunction().',
			);
		}

		if (requestParameters.providerInstanceId == null) {
			throw new runtime.RequiredError(
				"providerInstanceId",
				'Required parameter "providerInstanceId" was null or undefined when calling updateMcpServerInstanceFunction().',
			);
		}

		if (requestParameters.updateMcpServerInstanceFunctionRequest == null) {
			throw new runtime.RequiredError(
				"updateMcpServerInstanceFunctionRequest",
				'Required parameter "updateMcpServerInstanceFunctionRequest" was null or undefined when calling updateMcpServerInstanceFunction().',
			);
		}

		const queryParameters: any = {};

		const headerParameters: runtime.HTTPHeaders = {};

		headerParameters["Content-Type"] = "application/json";

		if (this.configuration?.accessToken) {
			const token = this.configuration.accessToken;
			const tokenString = await token("bearer_token", []);

			if (tokenString) {
				headerParameters.Authorization = `Bearer ${tokenString}`;
			}
		}
		if (this.configuration?.apiKey) {
			headerParameters["X-API-Key"] =
				await this.configuration.apiKey("X-API-Key"); // api_key authentication
		}

		let urlPath = `/api/mcp/v1/mcp-server/{mcp_server_instance_id}/function/{function_controller_type_id}/{provider_controller_type_id}/{provider_instance_id}`;
		urlPath = urlPath.replace(
			`{${"mcp_server_instance_id"}}`,
			encodeURIComponent(String(requestParameters.mcpServerInstanceId)),
		);
		urlPath = urlPath.replace(
			`{${"function_controller_type_id"}}`,
			encodeURIComponent(String(requestParameters.functionControllerTypeId)),
		);
		urlPath = urlPath.replace(
			`{${"provider_controller_type_id"}}`,
			encodeURIComponent(String(requestParameters.providerControllerTypeId)),
		);
		urlPath = urlPath.replace(
			`{${"provider_instance_id"}}`,
			encodeURIComponent(String(requestParameters.providerInstanceId)),
		);

		const response = await this.request(
			{
				path: urlPath,
				method: "PATCH",
				headers: headerParameters,
				query: queryParameters,
				body: UpdateMcpServerInstanceFunctionRequestToJSON(
					requestParameters.updateMcpServerInstanceFunctionRequest,
				),
			},
			initOverrides,
		);

		return new runtime.JSONApiResponse(response, (jsonValue) =>
			McpServerInstanceSerializedWithFunctionsFromJSON(jsonValue),
		);
	}

	/**
	 * Update the function name and description for a function mapping
	 * Update function in MCP server instance
	 */
	async updateMcpServerInstanceFunction(
		requestParameters: V1ApiUpdateMcpServerInstanceFunctionOperationRequest,
		initOverrides?: RequestInit | runtime.InitOverrideFunction,
	): Promise<McpServerInstanceSerializedWithFunctions> {
		const response = await this.updateMcpServerInstanceFunctionRaw(
			requestParameters,
			initOverrides,
		);
		return await response.value();
	}

	/**
	 * Update an existing provider instance configuration
	 * Update provider
	 */
	async updateProviderInstanceRaw(
		requestParameters: V1ApiUpdateProviderInstanceRequest,
		initOverrides?: RequestInit | runtime.InitOverrideFunction,
	): Promise<runtime.ApiResponse<any>> {
		if (requestParameters.providerInstanceId == null) {
			throw new runtime.RequiredError(
				"providerInstanceId",
				'Required parameter "providerInstanceId" was null or undefined when calling updateProviderInstance().',
			);
		}

		if (requestParameters.updateProviderInstanceParamsInner == null) {
			throw new runtime.RequiredError(
				"updateProviderInstanceParamsInner",
				'Required parameter "updateProviderInstanceParamsInner" was null or undefined when calling updateProviderInstance().',
			);
		}

		const queryParameters: any = {};

		const headerParameters: runtime.HTTPHeaders = {};

		headerParameters["Content-Type"] = "application/json";

		if (this.configuration?.accessToken) {
			const token = this.configuration.accessToken;
			const tokenString = await token("bearer_token", []);

			if (tokenString) {
				headerParameters.Authorization = `Bearer ${tokenString}`;
			}
		}
		if (this.configuration?.apiKey) {
			headerParameters["X-API-Key"] =
				await this.configuration.apiKey("X-API-Key"); // api_key authentication
		}

		let urlPath = `/api/mcp/v1/provider/{provider_instance_id}`;
		urlPath = urlPath.replace(
			`{${"provider_instance_id"}}`,
			encodeURIComponent(String(requestParameters.providerInstanceId)),
		);

		const response = await this.request(
			{
				path: urlPath,
				method: "PATCH",
				headers: headerParameters,
				query: queryParameters,
				body: UpdateProviderInstanceParamsInnerToJSON(
					requestParameters.updateProviderInstanceParamsInner,
				),
			},
			initOverrides,
		);

		if (this.isJsonMime(response.headers.get("content-type"))) {
			return new runtime.JSONApiResponse<any>(response);
		} else {
			return new runtime.TextApiResponse(response) as any;
		}
	}

	/**
	 * Update an existing provider instance configuration
	 * Update provider
	 */
	async updateProviderInstance(
		requestParameters: V1ApiUpdateProviderInstanceRequest,
		initOverrides?: RequestInit | runtime.InitOverrideFunction,
	): Promise<any> {
		const response = await this.updateProviderInstanceRaw(
			requestParameters,
			initOverrides,
		);
		return await response.value();
	}

	/**
	 * Update an existing secret\'s value or metadata
	 * Update secret
	 */
	async updateSecretRaw(
		requestParameters: V1ApiUpdateSecretOperationRequest,
		initOverrides?: RequestInit | runtime.InitOverrideFunction,
	): Promise<runtime.ApiResponse<Secret>> {
		if (requestParameters.secretId == null) {
			throw new runtime.RequiredError(
				"secretId",
				'Required parameter "secretId" was null or undefined when calling updateSecret().',
			);
		}

		if (requestParameters.updateSecretRequest == null) {
			throw new runtime.RequiredError(
				"updateSecretRequest",
				'Required parameter "updateSecretRequest" was null or undefined when calling updateSecret().',
			);
		}

		const queryParameters: any = {};

		const headerParameters: runtime.HTTPHeaders = {};

		headerParameters["Content-Type"] = "application/json";

		if (this.configuration?.accessToken) {
			const token = this.configuration.accessToken;
			const tokenString = await token("bearer_token", []);

			if (tokenString) {
				headerParameters.Authorization = `Bearer ${tokenString}`;
			}
		}
		if (this.configuration?.apiKey) {
			headerParameters["X-API-Key"] =
				await this.configuration.apiKey("X-API-Key"); // api_key authentication
		}

		let urlPath = `/api/environment/v1/secret/{secret_id}`;
		urlPath = urlPath.replace(
			`{${"secret_id"}}`,
			encodeURIComponent(String(requestParameters.secretId)),
		);

		const response = await this.request(
			{
				path: urlPath,
				method: "PUT",
				headers: headerParameters,
				query: queryParameters,
				body: UpdateSecretRequestToJSON(requestParameters.updateSecretRequest),
			},
			initOverrides,
		);

		return new runtime.JSONApiResponse(response, (jsonValue) =>
			SecretFromJSON(jsonValue),
		);
	}

	/**
	 * Update an existing secret\'s value or metadata
	 * Update secret
	 */
	async updateSecret(
		requestParameters: V1ApiUpdateSecretOperationRequest,
		initOverrides?: RequestInit | runtime.InitOverrideFunction,
	): Promise<Secret> {
		const response = await this.updateSecretRaw(
			requestParameters,
			initOverrides,
		);
		return await response.value();
	}

	/**
	 * Update the status of a task
	 * Update task status
	 */
	async updateTaskStatusRaw(
		requestParameters: V1ApiUpdateTaskStatusOperationRequest,
		initOverrides?: RequestInit | runtime.InitOverrideFunction,
	): Promise<runtime.ApiResponse<any>> {
		if (requestParameters.taskId == null) {
			throw new runtime.RequiredError(
				"taskId",
				'Required parameter "taskId" was null or undefined when calling updateTaskStatus().',
			);
		}

		if (requestParameters.updateTaskStatusRequest == null) {
			throw new runtime.RequiredError(
				"updateTaskStatusRequest",
				'Required parameter "updateTaskStatusRequest" was null or undefined when calling updateTaskStatus().',
			);
		}

		const queryParameters: any = {};

		const headerParameters: runtime.HTTPHeaders = {};

		headerParameters["Content-Type"] = "application/json";

		if (this.configuration?.accessToken) {
			const token = this.configuration.accessToken;
			const tokenString = await token("bearer_token", []);

			if (tokenString) {
				headerParameters.Authorization = `Bearer ${tokenString}`;
			}
		}
		if (this.configuration?.apiKey) {
			headerParameters["X-API-Key"] =
				await this.configuration.apiKey("X-API-Key"); // api_key authentication
		}

		let urlPath = `/api/task/v1/{task_id}`;
		urlPath = urlPath.replace(
			`{${"task_id"}}`,
			encodeURIComponent(String(requestParameters.taskId)),
		);

		const response = await this.request(
			{
				path: urlPath,
				method: "PUT",
				headers: headerParameters,
				query: queryParameters,
				body: UpdateTaskStatusRequestToJSON(
					requestParameters.updateTaskStatusRequest,
				),
			},
			initOverrides,
		);

		if (this.isJsonMime(response.headers.get("content-type"))) {
			return new runtime.JSONApiResponse<any>(response);
		} else {
			return new runtime.TextApiResponse(response) as any;
		}
	}

	/**
	 * Update the status of a task
	 * Update task status
	 */
	async updateTaskStatus(
		requestParameters: V1ApiUpdateTaskStatusOperationRequest,
		initOverrides?: RequestInit | runtime.InitOverrideFunction,
	): Promise<any> {
		const response = await this.updateTaskStatusRaw(
			requestParameters,
			initOverrides,
		);
		return await response.value();
	}

	/**
	 * Update a user\'s attributes
	 * Update user
	 */
	async updateUserRaw(
		requestParameters: V1ApiUpdateUserOperationRequest,
		initOverrides?: RequestInit | runtime.InitOverrideFunction,
	): Promise<runtime.ApiResponse<User>> {
		if (requestParameters.userId == null) {
			throw new runtime.RequiredError(
				"userId",
				'Required parameter "userId" was null or undefined when calling updateUser().',
			);
		}

		if (requestParameters.updateUserRequest == null) {
			throw new runtime.RequiredError(
				"updateUserRequest",
				'Required parameter "updateUserRequest" was null or undefined when calling updateUser().',
			);
		}

		const queryParameters: any = {};

		const headerParameters: runtime.HTTPHeaders = {};

		headerParameters["Content-Type"] = "application/json";

		if (this.configuration?.accessToken) {
			const token = this.configuration.accessToken;
			const tokenString = await token("bearer_token", []);

			if (tokenString) {
				headerParameters.Authorization = `Bearer ${tokenString}`;
			}
		}
		if (this.configuration?.apiKey) {
			headerParameters["X-API-Key"] =
				await this.configuration.apiKey("X-API-Key"); // api_key authentication
		}

		let urlPath = `/api/identity/v1/users/{user_id}`;
		urlPath = urlPath.replace(
			`{${"user_id"}}`,
			encodeURIComponent(String(requestParameters.userId)),
		);

		const response = await this.request(
			{
				path: urlPath,
				method: "PATCH",
				headers: headerParameters,
				query: queryParameters,
				body: UpdateUserRequestToJSON(requestParameters.updateUserRequest),
			},
			initOverrides,
		);

		return new runtime.JSONApiResponse(response, (jsonValue) =>
			UserFromJSON(jsonValue),
		);
	}

	/**
	 * Update a user\'s attributes
	 * Update user
	 */
	async updateUser(
		requestParameters: V1ApiUpdateUserOperationRequest,
		initOverrides?: RequestInit | runtime.InitOverrideFunction,
	): Promise<User> {
		const response = await this.updateUserRaw(requestParameters, initOverrides);
		return await response.value();
	}

	/**
	 * Update an existing environment variable\'s value
	 * Update variable
	 */
	async updateVariableRaw(
		requestParameters: V1ApiUpdateVariableOperationRequest,
		initOverrides?: RequestInit | runtime.InitOverrideFunction,
	): Promise<runtime.ApiResponse<Variable>> {
		if (requestParameters.variableId == null) {
			throw new runtime.RequiredError(
				"variableId",
				'Required parameter "variableId" was null or undefined when calling updateVariable().',
			);
		}

		if (requestParameters.updateVariableRequest == null) {
			throw new runtime.RequiredError(
				"updateVariableRequest",
				'Required parameter "updateVariableRequest" was null or undefined when calling updateVariable().',
			);
		}

		const queryParameters: any = {};

		const headerParameters: runtime.HTTPHeaders = {};

		headerParameters["Content-Type"] = "application/json";

		if (this.configuration?.accessToken) {
			const token = this.configuration.accessToken;
			const tokenString = await token("bearer_token", []);

			if (tokenString) {
				headerParameters.Authorization = `Bearer ${tokenString}`;
			}
		}
		if (this.configuration?.apiKey) {
			headerParameters["X-API-Key"] =
				await this.configuration.apiKey("X-API-Key"); // api_key authentication
		}

		let urlPath = `/api/environment/v1/variable/{variable_id}`;
		urlPath = urlPath.replace(
			`{${"variable_id"}}`,
			encodeURIComponent(String(requestParameters.variableId)),
		);

		const response = await this.request(
			{
				path: urlPath,
				method: "PUT",
				headers: headerParameters,
				query: queryParameters,
				body: UpdateVariableRequestToJSON(
					requestParameters.updateVariableRequest,
				),
			},
			initOverrides,
		);

		return new runtime.JSONApiResponse(response, (jsonValue) =>
			VariableFromJSON(jsonValue),
		);
	}

	/**
	 * Update an existing environment variable\'s value
	 * Update variable
	 */
	async updateVariable(
		requestParameters: V1ApiUpdateVariableOperationRequest,
		initOverrides?: RequestInit | runtime.InitOverrideFunction,
	): Promise<Variable> {
		const response = await this.updateVariableRaw(
			requestParameters,
			initOverrides,
		);
		return await response.value();
	}
}
