/* tslint:disable */
/* eslint-disable */
/**
 * soma
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: v1
 *
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

import type {
	ContextInfoPaginatedResponse,
	CreateDataEncryptionKeyParamsRoute,
	CreateDekAliasRequest,
	CreateMessageRequest,
	CreateMessageResponse,
	CreateProviderInstanceParamsInner,
	CreateResourceServerCredentialParamsInner,
	CreateSecretRequest,
	CreateUserCredentialParamsInner,
	DataEncryptionKey,
	DataEncryptionKeyAlias,
	DataEncryptionKeyListItemPaginatedResponse,
	DeleteSecretResponse,
	EncryptCredentialConfigurationParamsInner,
	EnvelopeEncryptionKey,
	EnvelopeEncryptionKeyPaginatedResponse,
	FunctionInstanceConfigPaginatedResponse,
	FunctionInstanceSerialized,
	FunctionInstanceSerializedPaginatedResponse,
	ImportDataEncryptionKeyParamsRoute,
	ImportSecretRequest,
	InvokeFunctionParamsInner,
	InvokeResult,
	ListDecryptedSecretsResponse,
	ListSecretsResponse,
	MigrateAllDataEncryptionKeysParamsRoute,
	MigrateDataEncryptionKeyParamsRoute,
	ProviderControllerSerializedPaginatedResponse,
	ProviderInstanceListItemPaginatedResponse,
	ProviderInstanceSerialized,
	ProviderInstanceSerializedWithEverything,
	ResourceServerCredentialSerialized,
	Secret,
	SomaAgentDefinition,
	StartUserCredentialBrokeringParamsInner,
	TaskPaginatedResponse,
	TaskTimelineItemPaginatedResponse,
	TaskWithDetails,
	TriggerCodegenResponse,
	UpdateAliasParams,
	UpdateProviderInstanceParamsInner,
	UpdateSecretRequest,
	UpdateTaskStatusRequest,
	UserCredentialBrokeringResponse,
	UserCredentialSerialized,
} from "../models/index";
import {
	ContextInfoPaginatedResponseFromJSON,
	CreateDataEncryptionKeyParamsRouteToJSON,
	CreateDekAliasRequestToJSON,
	CreateMessageRequestToJSON,
	CreateMessageResponseFromJSON,
	CreateProviderInstanceParamsInnerToJSON,
	CreateResourceServerCredentialParamsInnerToJSON,
	CreateSecretRequestToJSON,
	CreateUserCredentialParamsInnerToJSON,
	DataEncryptionKeyAliasFromJSON,
	DataEncryptionKeyFromJSON,
	DataEncryptionKeyListItemPaginatedResponseFromJSON,
	DeleteSecretResponseFromJSON,
	EncryptCredentialConfigurationParamsInnerToJSON,
	EnvelopeEncryptionKeyFromJSON,
	EnvelopeEncryptionKeyPaginatedResponseFromJSON,
	EnvelopeEncryptionKeyToJSON,
	FunctionInstanceConfigPaginatedResponseFromJSON,
	FunctionInstanceSerializedFromJSON,
	FunctionInstanceSerializedPaginatedResponseFromJSON,
	ImportDataEncryptionKeyParamsRouteToJSON,
	ImportSecretRequestToJSON,
	InvokeFunctionParamsInnerToJSON,
	InvokeResultFromJSON,
	ListDecryptedSecretsResponseFromJSON,
	ListSecretsResponseFromJSON,
	MigrateAllDataEncryptionKeysParamsRouteToJSON,
	MigrateDataEncryptionKeyParamsRouteToJSON,
	ProviderControllerSerializedPaginatedResponseFromJSON,
	ProviderInstanceListItemPaginatedResponseFromJSON,
	ProviderInstanceSerializedFromJSON,
	ProviderInstanceSerializedWithEverythingFromJSON,
	ResourceServerCredentialSerializedFromJSON,
	SecretFromJSON,
	SomaAgentDefinitionFromJSON,
	StartUserCredentialBrokeringParamsInnerToJSON,
	TaskPaginatedResponseFromJSON,
	TaskTimelineItemPaginatedResponseFromJSON,
	TaskWithDetailsFromJSON,
	TriggerCodegenResponseFromJSON,
	UpdateAliasParamsToJSON,
	UpdateProviderInstanceParamsInnerToJSON,
	UpdateSecretRequestToJSON,
	UpdateTaskStatusRequestToJSON,
	UserCredentialBrokeringResponseFromJSON,
	UserCredentialSerializedFromJSON,
} from "../models/index";
import * as runtime from "../runtime";

export interface V1ApiCreateDataEncryptionKeyRequest {
	envelopeId: string;
	createDataEncryptionKeyParamsRoute: CreateDataEncryptionKeyParamsRoute;
}

export interface V1ApiCreateDekAliasOperationRequest {
	createDekAliasRequest: CreateDekAliasRequest;
}

export interface V1ApiCreateEnvelopeEncryptionKeyRequest {
	envelopeEncryptionKey: EnvelopeEncryptionKey;
}

export interface V1ApiCreateProviderInstanceRequest {
	providerControllerTypeId: string;
	credentialControllerTypeId: string;
	createProviderInstanceParamsInner: CreateProviderInstanceParamsInner;
}

export interface V1ApiCreateResourceServerCredentialRequest {
	providerControllerTypeId: string;
	credentialControllerTypeId: string;
	createResourceServerCredentialParamsInner: CreateResourceServerCredentialParamsInner;
}

export interface V1ApiCreateSecretOperationRequest {
	createSecretRequest: CreateSecretRequest;
}

export interface V1ApiCreateUserCredentialRequest {
	providerControllerTypeId: string;
	credentialControllerTypeId: string;
	createUserCredentialParamsInner: CreateUserCredentialParamsInner;
}

export interface V1ApiDeleteDekAliasRequest {
	alias: string;
}

export interface V1ApiDeleteProviderInstanceRequest {
	providerInstanceId: string;
}

export interface V1ApiDeleteSecretRequest {
	secretId: string;
}

export interface V1ApiDisableFunctionRequest {
	providerInstanceId: string;
	functionControllerTypeId: string;
}

export interface V1ApiEnableFunctionRequest {
	providerInstanceId: string;
	functionControllerTypeId: string;
	body: object;
}

export interface V1ApiEncryptResourceServerConfigurationRequest {
	providerControllerTypeId: string;
	credentialControllerTypeId: string;
	encryptCredentialConfigurationParamsInner: EncryptCredentialConfigurationParamsInner;
}

export interface V1ApiEncryptUserCredentialConfigurationRequest {
	providerControllerTypeId: string;
	credentialControllerTypeId: string;
	encryptCredentialConfigurationParamsInner: EncryptCredentialConfigurationParamsInner;
}

export interface V1ApiGetDekByAliasOrIdRequest {
	alias: string;
}

export interface V1ApiGetProviderInstanceRequest {
	providerInstanceId: string;
}

export interface V1ApiGetSecretByIdRequest {
	secretId: string;
}

export interface V1ApiGetSecretByKeyRequest {
	key: string;
}

export interface V1ApiGetTaskByIdRequest {
	taskId: string;
}

export interface V1ApiHandleJsonrpcRequestRequest {
	body: object;
}

export interface V1ApiImportDataEncryptionKeyRequest {
	envelopeId: string;
	importDataEncryptionKeyParamsRoute: ImportDataEncryptionKeyParamsRoute;
}

export interface V1ApiImportSecretOperationRequest {
	importSecretRequest: ImportSecretRequest;
}

export interface V1ApiInvokeFunctionRequest {
	providerInstanceId: string;
	functionControllerTypeId: string;
	invokeFunctionParamsInner: InvokeFunctionParamsInner;
}

export interface V1ApiListAvailableProvidersRequest {
	pageSize: number;
	nextPageToken?: string;
}

export interface V1ApiListContextsRequest {
	pageSize: number;
	nextPageToken?: string;
}

export interface V1ApiListDataEncryptionKeysByEnvelopeRequest {
	envelopeId: string;
	pageSize: number;
	nextPageToken?: string;
}

export interface V1ApiListDecryptedSecretsRequest {
	pageSize: number;
	nextPageToken?: string;
}

export interface V1ApiListEnvelopeEncryptionKeysRequest {
	pageSize: number;
	nextPageToken?: string;
}

export interface V1ApiListFunctionInstancesRequest {
	pageSize: number;
	nextPageToken?: string;
	providerInstanceId?: string;
}

export interface V1ApiListProviderInstancesRequest {
	pageSize: number;
	nextPageToken?: string;
	status?: string;
	providerControllerTypeId?: string;
}

export interface V1ApiListProviderInstancesGroupedByFunctionRequest {
	pageSize: number;
	nextPageToken?: string | null;
	providerControllerTypeId?: string | null;
	functionCategory?: string | null;
}

export interface V1ApiListSecretsRequest {
	pageSize: number;
	nextPageToken?: string;
}

export interface V1ApiListTasksRequest {
	pageSize: number;
	nextPageToken?: string;
}

export interface V1ApiListTasksByContextIdRequest {
	pageSize: number;
	contextId: string;
	nextPageToken?: string;
}

export interface V1ApiMigrateAllDataEncryptionKeysRequest {
	envelopeId: string;
	migrateAllDataEncryptionKeysParamsRoute: MigrateAllDataEncryptionKeysParamsRoute;
}

export interface V1ApiMigrateDataEncryptionKeyRequest {
	envelopeId: string;
	dekId: string;
	migrateDataEncryptionKeyParamsRoute: MigrateDataEncryptionKeyParamsRoute;
}

export interface V1ApiResumeUserCredentialBrokeringRequest {
	state?: string;
	code?: string;
	error?: string;
	errorDescription?: string;
}

export interface V1ApiSendMessageRequest {
	taskId: string;
	createMessageRequest: CreateMessageRequest;
}

export interface V1ApiStartUserCredentialBrokeringRequest {
	providerControllerTypeId: string;
	credentialControllerTypeId: string;
	startUserCredentialBrokeringParamsInner: StartUserCredentialBrokeringParamsInner;
}

export interface V1ApiTaskHistoryRequest {
	pageSize: number;
	taskId: string;
	nextPageToken?: string;
}

export interface V1ApiTriggerMcpMessageRequest {
	body: object;
}

export interface V1ApiUpdateDekAliasRequest {
	alias: string;
	updateAliasParams: UpdateAliasParams;
}

export interface V1ApiUpdateProviderInstanceRequest {
	providerInstanceId: string;
	updateProviderInstanceParamsInner: UpdateProviderInstanceParamsInner;
}

export interface V1ApiUpdateSecretOperationRequest {
	secretId: string;
	updateSecretRequest: UpdateSecretRequest;
}

export interface V1ApiUpdateTaskStatusOperationRequest {
	taskId: string;
	updateTaskStatusRequest: UpdateTaskStatusRequest;
}

/**
 *
 */
export class V1Api extends runtime.BaseAPI {
	/**
	 * Create a new data encryption key (DEK) encrypted with the specified envelope encryption key
	 * Create data key
	 */
	async createDataEncryptionKeyRaw(
		requestParameters: V1ApiCreateDataEncryptionKeyRequest,
		initOverrides?: RequestInit | runtime.InitOverrideFunction,
	): Promise<runtime.ApiResponse<DataEncryptionKey>> {
		if (requestParameters.envelopeId == null) {
			throw new runtime.RequiredError(
				"envelopeId",
				'Required parameter "envelopeId" was null or undefined when calling createDataEncryptionKey().',
			);
		}

		if (requestParameters.createDataEncryptionKeyParamsRoute == null) {
			throw new runtime.RequiredError(
				"createDataEncryptionKeyParamsRoute",
				'Required parameter "createDataEncryptionKeyParamsRoute" was null or undefined when calling createDataEncryptionKey().',
			);
		}

		const queryParameters: any = {};

		const headerParameters: runtime.HTTPHeaders = {};

		headerParameters["Content-Type"] = "application/json";

		let urlPath = `/api/encryption/v1/envelope/{envelope_id}/dek`;
		urlPath = urlPath.replace(
			`{${"envelope_id"}}`,
			encodeURIComponent(String(requestParameters.envelopeId)),
		);

		const response = await this.request(
			{
				path: urlPath,
				method: "POST",
				headers: headerParameters,
				query: queryParameters,
				body: CreateDataEncryptionKeyParamsRouteToJSON(
					requestParameters.createDataEncryptionKeyParamsRoute,
				),
			},
			initOverrides,
		);

		return new runtime.JSONApiResponse(response, (jsonValue) =>
			DataEncryptionKeyFromJSON(jsonValue),
		);
	}

	/**
	 * Create a new data encryption key (DEK) encrypted with the specified envelope encryption key
	 * Create data key
	 */
	async createDataEncryptionKey(
		requestParameters: V1ApiCreateDataEncryptionKeyRequest,
		initOverrides?: RequestInit | runtime.InitOverrideFunction,
	): Promise<DataEncryptionKey> {
		const response = await this.createDataEncryptionKeyRaw(
			requestParameters,
			initOverrides,
		);
		return await response.value();
	}

	/**
	 * Create an alias for a data encryption key to enable lookup by friendly name
	 * Create DEK alias
	 */
	async createDekAliasRaw(
		requestParameters: V1ApiCreateDekAliasOperationRequest,
		initOverrides?: RequestInit | runtime.InitOverrideFunction,
	): Promise<runtime.ApiResponse<DataEncryptionKeyAlias>> {
		if (requestParameters.createDekAliasRequest == null) {
			throw new runtime.RequiredError(
				"createDekAliasRequest",
				'Required parameter "createDekAliasRequest" was null or undefined when calling createDekAlias().',
			);
		}

		const queryParameters: any = {};

		const headerParameters: runtime.HTTPHeaders = {};

		headerParameters["Content-Type"] = "application/json";

		const urlPath = `/api/encryption/v1/dek/alias`;

		const response = await this.request(
			{
				path: urlPath,
				method: "POST",
				headers: headerParameters,
				query: queryParameters,
				body: CreateDekAliasRequestToJSON(
					requestParameters.createDekAliasRequest,
				),
			},
			initOverrides,
		);

		return new runtime.JSONApiResponse(response, (jsonValue) =>
			DataEncryptionKeyAliasFromJSON(jsonValue),
		);
	}

	/**
	 * Create an alias for a data encryption key to enable lookup by friendly name
	 * Create DEK alias
	 */
	async createDekAlias(
		requestParameters: V1ApiCreateDekAliasOperationRequest,
		initOverrides?: RequestInit | runtime.InitOverrideFunction,
	): Promise<DataEncryptionKeyAlias> {
		const response = await this.createDekAliasRaw(
			requestParameters,
			initOverrides,
		);
		return await response.value();
	}

	/**
	 * Create a new envelope encryption key (master key) for encrypting data encryption keys
	 * Create envelope key
	 */
	async createEnvelopeEncryptionKeyRaw(
		requestParameters: V1ApiCreateEnvelopeEncryptionKeyRequest,
		initOverrides?: RequestInit | runtime.InitOverrideFunction,
	): Promise<runtime.ApiResponse<EnvelopeEncryptionKey>> {
		if (requestParameters.envelopeEncryptionKey == null) {
			throw new runtime.RequiredError(
				"envelopeEncryptionKey",
				'Required parameter "envelopeEncryptionKey" was null or undefined when calling createEnvelopeEncryptionKey().',
			);
		}

		const queryParameters: any = {};

		const headerParameters: runtime.HTTPHeaders = {};

		headerParameters["Content-Type"] = "application/json";

		const urlPath = `/api/encryption/v1/envelope`;

		const response = await this.request(
			{
				path: urlPath,
				method: "POST",
				headers: headerParameters,
				query: queryParameters,
				body: EnvelopeEncryptionKeyToJSON(
					requestParameters.envelopeEncryptionKey,
				),
			},
			initOverrides,
		);

		return new runtime.JSONApiResponse(response, (jsonValue) =>
			EnvelopeEncryptionKeyFromJSON(jsonValue),
		);
	}

	/**
	 * Create a new envelope encryption key (master key) for encrypting data encryption keys
	 * Create envelope key
	 */
	async createEnvelopeEncryptionKey(
		requestParameters: V1ApiCreateEnvelopeEncryptionKeyRequest,
		initOverrides?: RequestInit | runtime.InitOverrideFunction,
	): Promise<EnvelopeEncryptionKey> {
		const response = await this.createEnvelopeEncryptionKeyRaw(
			requestParameters,
			initOverrides,
		);
		return await response.value();
	}

	/**
	 * Create a new provider instance with the specified configuration
	 * Create provider
	 */
	async createProviderInstanceRaw(
		requestParameters: V1ApiCreateProviderInstanceRequest,
		initOverrides?: RequestInit | runtime.InitOverrideFunction,
	): Promise<runtime.ApiResponse<ProviderInstanceSerialized>> {
		if (requestParameters.providerControllerTypeId == null) {
			throw new runtime.RequiredError(
				"providerControllerTypeId",
				'Required parameter "providerControllerTypeId" was null or undefined when calling createProviderInstance().',
			);
		}

		if (requestParameters.credentialControllerTypeId == null) {
			throw new runtime.RequiredError(
				"credentialControllerTypeId",
				'Required parameter "credentialControllerTypeId" was null or undefined when calling createProviderInstance().',
			);
		}

		if (requestParameters.createProviderInstanceParamsInner == null) {
			throw new runtime.RequiredError(
				"createProviderInstanceParamsInner",
				'Required parameter "createProviderInstanceParamsInner" was null or undefined when calling createProviderInstance().',
			);
		}

		const queryParameters: any = {};

		const headerParameters: runtime.HTTPHeaders = {};

		headerParameters["Content-Type"] = "application/json";

		let urlPath = `/api/bridge/v1/available-providers/{provider_controller_type_id}/available-credentials/{credential_controller_type_id}`;
		urlPath = urlPath.replace(
			`{${"provider_controller_type_id"}}`,
			encodeURIComponent(String(requestParameters.providerControllerTypeId)),
		);
		urlPath = urlPath.replace(
			`{${"credential_controller_type_id"}}`,
			encodeURIComponent(String(requestParameters.credentialControllerTypeId)),
		);

		const response = await this.request(
			{
				path: urlPath,
				method: "POST",
				headers: headerParameters,
				query: queryParameters,
				body: CreateProviderInstanceParamsInnerToJSON(
					requestParameters.createProviderInstanceParamsInner,
				),
			},
			initOverrides,
		);

		return new runtime.JSONApiResponse(response, (jsonValue) =>
			ProviderInstanceSerializedFromJSON(jsonValue),
		);
	}

	/**
	 * Create a new provider instance with the specified configuration
	 * Create provider
	 */
	async createProviderInstance(
		requestParameters: V1ApiCreateProviderInstanceRequest,
		initOverrides?: RequestInit | runtime.InitOverrideFunction,
	): Promise<ProviderInstanceSerialized> {
		const response = await this.createProviderInstanceRaw(
			requestParameters,
			initOverrides,
		);
		return await response.value();
	}

	/**
	 * Create a new resource server credential
	 * Create resource server credential
	 */
	async createResourceServerCredentialRaw(
		requestParameters: V1ApiCreateResourceServerCredentialRequest,
		initOverrides?: RequestInit | runtime.InitOverrideFunction,
	): Promise<runtime.ApiResponse<ResourceServerCredentialSerialized>> {
		if (requestParameters.providerControllerTypeId == null) {
			throw new runtime.RequiredError(
				"providerControllerTypeId",
				'Required parameter "providerControllerTypeId" was null or undefined when calling createResourceServerCredential().',
			);
		}

		if (requestParameters.credentialControllerTypeId == null) {
			throw new runtime.RequiredError(
				"credentialControllerTypeId",
				'Required parameter "credentialControllerTypeId" was null or undefined when calling createResourceServerCredential().',
			);
		}

		if (requestParameters.createResourceServerCredentialParamsInner == null) {
			throw new runtime.RequiredError(
				"createResourceServerCredentialParamsInner",
				'Required parameter "createResourceServerCredentialParamsInner" was null or undefined when calling createResourceServerCredential().',
			);
		}

		const queryParameters: any = {};

		const headerParameters: runtime.HTTPHeaders = {};

		headerParameters["Content-Type"] = "application/json";

		let urlPath = `/api/bridge/v1/available-providers/{provider_controller_type_id}/available-credentials/{credential_controller_type_id}/credential/resource-server`;
		urlPath = urlPath.replace(
			`{${"provider_controller_type_id"}}`,
			encodeURIComponent(String(requestParameters.providerControllerTypeId)),
		);
		urlPath = urlPath.replace(
			`{${"credential_controller_type_id"}}`,
			encodeURIComponent(String(requestParameters.credentialControllerTypeId)),
		);

		const response = await this.request(
			{
				path: urlPath,
				method: "POST",
				headers: headerParameters,
				query: queryParameters,
				body: CreateResourceServerCredentialParamsInnerToJSON(
					requestParameters.createResourceServerCredentialParamsInner,
				),
			},
			initOverrides,
		);

		return new runtime.JSONApiResponse(response, (jsonValue) =>
			ResourceServerCredentialSerializedFromJSON(jsonValue),
		);
	}

	/**
	 * Create a new resource server credential
	 * Create resource server credential
	 */
	async createResourceServerCredential(
		requestParameters: V1ApiCreateResourceServerCredentialRequest,
		initOverrides?: RequestInit | runtime.InitOverrideFunction,
	): Promise<ResourceServerCredentialSerialized> {
		const response = await this.createResourceServerCredentialRaw(
			requestParameters,
			initOverrides,
		);
		return await response.value();
	}

	/**
	 * Create a new encrypted secret with the specified key and value
	 * Create secret
	 */
	async createSecretRaw(
		requestParameters: V1ApiCreateSecretOperationRequest,
		initOverrides?: RequestInit | runtime.InitOverrideFunction,
	): Promise<runtime.ApiResponse<Secret>> {
		if (requestParameters.createSecretRequest == null) {
			throw new runtime.RequiredError(
				"createSecretRequest",
				'Required parameter "createSecretRequest" was null or undefined when calling createSecret().',
			);
		}

		const queryParameters: any = {};

		const headerParameters: runtime.HTTPHeaders = {};

		headerParameters["Content-Type"] = "application/json";

		const urlPath = `/api/secret/v1`;

		const response = await this.request(
			{
				path: urlPath,
				method: "POST",
				headers: headerParameters,
				query: queryParameters,
				body: CreateSecretRequestToJSON(requestParameters.createSecretRequest),
			},
			initOverrides,
		);

		return new runtime.JSONApiResponse(response, (jsonValue) =>
			SecretFromJSON(jsonValue),
		);
	}

	/**
	 * Create a new encrypted secret with the specified key and value
	 * Create secret
	 */
	async createSecret(
		requestParameters: V1ApiCreateSecretOperationRequest,
		initOverrides?: RequestInit | runtime.InitOverrideFunction,
	): Promise<Secret> {
		const response = await this.createSecretRaw(
			requestParameters,
			initOverrides,
		);
		return await response.value();
	}

	/**
	 * Create a new user credential
	 * Create user credential
	 */
	async createUserCredentialRaw(
		requestParameters: V1ApiCreateUserCredentialRequest,
		initOverrides?: RequestInit | runtime.InitOverrideFunction,
	): Promise<runtime.ApiResponse<UserCredentialSerialized>> {
		if (requestParameters.providerControllerTypeId == null) {
			throw new runtime.RequiredError(
				"providerControllerTypeId",
				'Required parameter "providerControllerTypeId" was null or undefined when calling createUserCredential().',
			);
		}

		if (requestParameters.credentialControllerTypeId == null) {
			throw new runtime.RequiredError(
				"credentialControllerTypeId",
				'Required parameter "credentialControllerTypeId" was null or undefined when calling createUserCredential().',
			);
		}

		if (requestParameters.createUserCredentialParamsInner == null) {
			throw new runtime.RequiredError(
				"createUserCredentialParamsInner",
				'Required parameter "createUserCredentialParamsInner" was null or undefined when calling createUserCredential().',
			);
		}

		const queryParameters: any = {};

		const headerParameters: runtime.HTTPHeaders = {};

		headerParameters["Content-Type"] = "application/json";

		let urlPath = `/api/bridge/v1/available-providers/{provider_controller_type_id}/available-credentials/{credential_controller_type_id}/credential/user-credential`;
		urlPath = urlPath.replace(
			`{${"provider_controller_type_id"}}`,
			encodeURIComponent(String(requestParameters.providerControllerTypeId)),
		);
		urlPath = urlPath.replace(
			`{${"credential_controller_type_id"}}`,
			encodeURIComponent(String(requestParameters.credentialControllerTypeId)),
		);

		const response = await this.request(
			{
				path: urlPath,
				method: "POST",
				headers: headerParameters,
				query: queryParameters,
				body: CreateUserCredentialParamsInnerToJSON(
					requestParameters.createUserCredentialParamsInner,
				),
			},
			initOverrides,
		);

		return new runtime.JSONApiResponse(response, (jsonValue) =>
			UserCredentialSerializedFromJSON(jsonValue),
		);
	}

	/**
	 * Create a new user credential
	 * Create user credential
	 */
	async createUserCredential(
		requestParameters: V1ApiCreateUserCredentialRequest,
		initOverrides?: RequestInit | runtime.InitOverrideFunction,
	): Promise<UserCredentialSerialized> {
		const response = await this.createUserCredentialRaw(
			requestParameters,
			initOverrides,
		);
		return await response.value();
	}

	/**
	 * Delete an alias for a data encryption key
	 * Delete DEK alias
	 */
	async deleteDekAliasRaw(
		requestParameters: V1ApiDeleteDekAliasRequest,
		initOverrides?: RequestInit | runtime.InitOverrideFunction,
	): Promise<runtime.ApiResponse<void>> {
		if (requestParameters.alias == null) {
			throw new runtime.RequiredError(
				"alias",
				'Required parameter "alias" was null or undefined when calling deleteDekAlias().',
			);
		}

		const queryParameters: any = {};

		const headerParameters: runtime.HTTPHeaders = {};

		let urlPath = `/api/encryption/v1/dek/alias/{alias}`;
		urlPath = urlPath.replace(
			`{${"alias"}}`,
			encodeURIComponent(String(requestParameters.alias)),
		);

		const response = await this.request(
			{
				path: urlPath,
				method: "DELETE",
				headers: headerParameters,
				query: queryParameters,
			},
			initOverrides,
		);

		return new runtime.VoidApiResponse(response);
	}

	/**
	 * Delete an alias for a data encryption key
	 * Delete DEK alias
	 */
	async deleteDekAlias(
		requestParameters: V1ApiDeleteDekAliasRequest,
		initOverrides?: RequestInit | runtime.InitOverrideFunction,
	): Promise<void> {
		await this.deleteDekAliasRaw(requestParameters, initOverrides);
	}

	/**
	 * Delete a provider instance by its unique identifier
	 * Delete provider
	 */
	async deleteProviderInstanceRaw(
		requestParameters: V1ApiDeleteProviderInstanceRequest,
		initOverrides?: RequestInit | runtime.InitOverrideFunction,
	): Promise<runtime.ApiResponse<any>> {
		if (requestParameters.providerInstanceId == null) {
			throw new runtime.RequiredError(
				"providerInstanceId",
				'Required parameter "providerInstanceId" was null or undefined when calling deleteProviderInstance().',
			);
		}

		const queryParameters: any = {};

		const headerParameters: runtime.HTTPHeaders = {};

		let urlPath = `/api/bridge/v1/provider/{provider_instance_id}`;
		urlPath = urlPath.replace(
			`{${"provider_instance_id"}}`,
			encodeURIComponent(String(requestParameters.providerInstanceId)),
		);

		const response = await this.request(
			{
				path: urlPath,
				method: "DELETE",
				headers: headerParameters,
				query: queryParameters,
			},
			initOverrides,
		);

		if (this.isJsonMime(response.headers.get("content-type"))) {
			return new runtime.JSONApiResponse<any>(response);
		} else {
			return new runtime.TextApiResponse(response) as any;
		}
	}

	/**
	 * Delete a provider instance by its unique identifier
	 * Delete provider
	 */
	async deleteProviderInstance(
		requestParameters: V1ApiDeleteProviderInstanceRequest,
		initOverrides?: RequestInit | runtime.InitOverrideFunction,
	): Promise<any> {
		const response = await this.deleteProviderInstanceRaw(
			requestParameters,
			initOverrides,
		);
		return await response.value();
	}

	/**
	 * Delete a secret by its unique identifier
	 * Delete secret
	 */
	async deleteSecretRaw(
		requestParameters: V1ApiDeleteSecretRequest,
		initOverrides?: RequestInit | runtime.InitOverrideFunction,
	): Promise<runtime.ApiResponse<DeleteSecretResponse>> {
		if (requestParameters.secretId == null) {
			throw new runtime.RequiredError(
				"secretId",
				'Required parameter "secretId" was null or undefined when calling deleteSecret().',
			);
		}

		const queryParameters: any = {};

		const headerParameters: runtime.HTTPHeaders = {};

		let urlPath = `/api/secret/v1/{secret_id}`;
		urlPath = urlPath.replace(
			`{${"secret_id"}}`,
			encodeURIComponent(String(requestParameters.secretId)),
		);

		const response = await this.request(
			{
				path: urlPath,
				method: "DELETE",
				headers: headerParameters,
				query: queryParameters,
			},
			initOverrides,
		);

		return new runtime.JSONApiResponse(response, (jsonValue) =>
			DeleteSecretResponseFromJSON(jsonValue),
		);
	}

	/**
	 * Delete a secret by its unique identifier
	 * Delete secret
	 */
	async deleteSecret(
		requestParameters: V1ApiDeleteSecretRequest,
		initOverrides?: RequestInit | runtime.InitOverrideFunction,
	): Promise<DeleteSecretResponse> {
		const response = await this.deleteSecretRaw(
			requestParameters,
			initOverrides,
		);
		return await response.value();
	}

	/**
	 * Disable a function for a provider instance
	 * Disable function
	 */
	async disableFunctionRaw(
		requestParameters: V1ApiDisableFunctionRequest,
		initOverrides?: RequestInit | runtime.InitOverrideFunction,
	): Promise<runtime.ApiResponse<any>> {
		if (requestParameters.providerInstanceId == null) {
			throw new runtime.RequiredError(
				"providerInstanceId",
				'Required parameter "providerInstanceId" was null or undefined when calling disableFunction().',
			);
		}

		if (requestParameters.functionControllerTypeId == null) {
			throw new runtime.RequiredError(
				"functionControllerTypeId",
				'Required parameter "functionControllerTypeId" was null or undefined when calling disableFunction().',
			);
		}

		const queryParameters: any = {};

		const headerParameters: runtime.HTTPHeaders = {};

		let urlPath = `/api/bridge/v1/provider/{provider_instance_id}/function/{function_controller_type_id}/disable`;
		urlPath = urlPath.replace(
			`{${"provider_instance_id"}}`,
			encodeURIComponent(String(requestParameters.providerInstanceId)),
		);
		urlPath = urlPath.replace(
			`{${"function_controller_type_id"}}`,
			encodeURIComponent(String(requestParameters.functionControllerTypeId)),
		);

		const response = await this.request(
			{
				path: urlPath,
				method: "POST",
				headers: headerParameters,
				query: queryParameters,
			},
			initOverrides,
		);

		if (this.isJsonMime(response.headers.get("content-type"))) {
			return new runtime.JSONApiResponse<any>(response);
		} else {
			return new runtime.TextApiResponse(response) as any;
		}
	}

	/**
	 * Disable a function for a provider instance
	 * Disable function
	 */
	async disableFunction(
		requestParameters: V1ApiDisableFunctionRequest,
		initOverrides?: RequestInit | runtime.InitOverrideFunction,
	): Promise<any> {
		const response = await this.disableFunctionRaw(
			requestParameters,
			initOverrides,
		);
		return await response.value();
	}

	/**
	 * Enable a function for a provider instance
	 * Enable function
	 */
	async enableFunctionRaw(
		requestParameters: V1ApiEnableFunctionRequest,
		initOverrides?: RequestInit | runtime.InitOverrideFunction,
	): Promise<runtime.ApiResponse<FunctionInstanceSerialized>> {
		if (requestParameters.providerInstanceId == null) {
			throw new runtime.RequiredError(
				"providerInstanceId",
				'Required parameter "providerInstanceId" was null or undefined when calling enableFunction().',
			);
		}

		if (requestParameters.functionControllerTypeId == null) {
			throw new runtime.RequiredError(
				"functionControllerTypeId",
				'Required parameter "functionControllerTypeId" was null or undefined when calling enableFunction().',
			);
		}

		if (requestParameters.body == null) {
			throw new runtime.RequiredError(
				"body",
				'Required parameter "body" was null or undefined when calling enableFunction().',
			);
		}

		const queryParameters: any = {};

		const headerParameters: runtime.HTTPHeaders = {};

		headerParameters["Content-Type"] = "application/json";

		let urlPath = `/api/bridge/v1/provider/{provider_instance_id}/function/{function_controller_type_id}/enable`;
		urlPath = urlPath.replace(
			`{${"provider_instance_id"}}`,
			encodeURIComponent(String(requestParameters.providerInstanceId)),
		);
		urlPath = urlPath.replace(
			`{${"function_controller_type_id"}}`,
			encodeURIComponent(String(requestParameters.functionControllerTypeId)),
		);

		const response = await this.request(
			{
				path: urlPath,
				method: "POST",
				headers: headerParameters,
				query: queryParameters,
				body: requestParameters.body as any,
			},
			initOverrides,
		);

		return new runtime.JSONApiResponse(response, (jsonValue) =>
			FunctionInstanceSerializedFromJSON(jsonValue),
		);
	}

	/**
	 * Enable a function for a provider instance
	 * Enable function
	 */
	async enableFunction(
		requestParameters: V1ApiEnableFunctionRequest,
		initOverrides?: RequestInit | runtime.InitOverrideFunction,
	): Promise<FunctionInstanceSerialized> {
		const response = await this.enableFunctionRaw(
			requestParameters,
			initOverrides,
		);
		return await response.value();
	}

	/**
	 * Encrypt a resource server credential configuration before storage
	 * Encrypt resource server config
	 */
	async encryptResourceServerConfigurationRaw(
		requestParameters: V1ApiEncryptResourceServerConfigurationRequest,
		initOverrides?: RequestInit | runtime.InitOverrideFunction,
	): Promise<runtime.ApiResponse<any>> {
		if (requestParameters.providerControllerTypeId == null) {
			throw new runtime.RequiredError(
				"providerControllerTypeId",
				'Required parameter "providerControllerTypeId" was null or undefined when calling encryptResourceServerConfiguration().',
			);
		}

		if (requestParameters.credentialControllerTypeId == null) {
			throw new runtime.RequiredError(
				"credentialControllerTypeId",
				'Required parameter "credentialControllerTypeId" was null or undefined when calling encryptResourceServerConfiguration().',
			);
		}

		if (requestParameters.encryptCredentialConfigurationParamsInner == null) {
			throw new runtime.RequiredError(
				"encryptCredentialConfigurationParamsInner",
				'Required parameter "encryptCredentialConfigurationParamsInner" was null or undefined when calling encryptResourceServerConfiguration().',
			);
		}

		const queryParameters: any = {};

		const headerParameters: runtime.HTTPHeaders = {};

		headerParameters["Content-Type"] = "application/json";

		let urlPath = `/api/bridge/v1/available-providers/{provider_controller_type_id}/available-credentials/{credential_controller_type_id}/credential/resource-server/encrypt`;
		urlPath = urlPath.replace(
			`{${"provider_controller_type_id"}}`,
			encodeURIComponent(String(requestParameters.providerControllerTypeId)),
		);
		urlPath = urlPath.replace(
			`{${"credential_controller_type_id"}}`,
			encodeURIComponent(String(requestParameters.credentialControllerTypeId)),
		);

		const response = await this.request(
			{
				path: urlPath,
				method: "POST",
				headers: headerParameters,
				query: queryParameters,
				body: EncryptCredentialConfigurationParamsInnerToJSON(
					requestParameters.encryptCredentialConfigurationParamsInner,
				),
			},
			initOverrides,
		);

		if (this.isJsonMime(response.headers.get("content-type"))) {
			return new runtime.JSONApiResponse<any>(response);
		} else {
			return new runtime.TextApiResponse(response) as any;
		}
	}

	/**
	 * Encrypt a resource server credential configuration before storage
	 * Encrypt resource server config
	 */
	async encryptResourceServerConfiguration(
		requestParameters: V1ApiEncryptResourceServerConfigurationRequest,
		initOverrides?: RequestInit | runtime.InitOverrideFunction,
	): Promise<any> {
		const response = await this.encryptResourceServerConfigurationRaw(
			requestParameters,
			initOverrides,
		);
		return await response.value();
	}

	/**
	 * Encrypt a user credential configuration before storage
	 * Encrypt user credential config
	 */
	async encryptUserCredentialConfigurationRaw(
		requestParameters: V1ApiEncryptUserCredentialConfigurationRequest,
		initOverrides?: RequestInit | runtime.InitOverrideFunction,
	): Promise<runtime.ApiResponse<any>> {
		if (requestParameters.providerControllerTypeId == null) {
			throw new runtime.RequiredError(
				"providerControllerTypeId",
				'Required parameter "providerControllerTypeId" was null or undefined when calling encryptUserCredentialConfiguration().',
			);
		}

		if (requestParameters.credentialControllerTypeId == null) {
			throw new runtime.RequiredError(
				"credentialControllerTypeId",
				'Required parameter "credentialControllerTypeId" was null or undefined when calling encryptUserCredentialConfiguration().',
			);
		}

		if (requestParameters.encryptCredentialConfigurationParamsInner == null) {
			throw new runtime.RequiredError(
				"encryptCredentialConfigurationParamsInner",
				'Required parameter "encryptCredentialConfigurationParamsInner" was null or undefined when calling encryptUserCredentialConfiguration().',
			);
		}

		const queryParameters: any = {};

		const headerParameters: runtime.HTTPHeaders = {};

		headerParameters["Content-Type"] = "application/json";

		let urlPath = `/api/bridge/v1/available-providers/{provider_controller_type_id}/available-credentials/{credential_controller_type_id}/credential/user-credential/encrypt`;
		urlPath = urlPath.replace(
			`{${"provider_controller_type_id"}}`,
			encodeURIComponent(String(requestParameters.providerControllerTypeId)),
		);
		urlPath = urlPath.replace(
			`{${"credential_controller_type_id"}}`,
			encodeURIComponent(String(requestParameters.credentialControllerTypeId)),
		);

		const response = await this.request(
			{
				path: urlPath,
				method: "POST",
				headers: headerParameters,
				query: queryParameters,
				body: EncryptCredentialConfigurationParamsInnerToJSON(
					requestParameters.encryptCredentialConfigurationParamsInner,
				),
			},
			initOverrides,
		);

		if (this.isJsonMime(response.headers.get("content-type"))) {
			return new runtime.JSONApiResponse<any>(response);
		} else {
			return new runtime.TextApiResponse(response) as any;
		}
	}

	/**
	 * Encrypt a user credential configuration before storage
	 * Encrypt user credential config
	 */
	async encryptUserCredentialConfiguration(
		requestParameters: V1ApiEncryptUserCredentialConfigurationRequest,
		initOverrides?: RequestInit | runtime.InitOverrideFunction,
	): Promise<any> {
		const response = await this.encryptUserCredentialConfigurationRaw(
			requestParameters,
			initOverrides,
		);
		return await response.value();
	}

	/**
	 * Get the agent card describing agent capabilities and metadata
	 * Get agent card
	 */
	async getAgentCardRaw(
		initOverrides?: RequestInit | runtime.InitOverrideFunction,
	): Promise<runtime.ApiResponse<object>> {
		const queryParameters: any = {};

		const headerParameters: runtime.HTTPHeaders = {};

		const urlPath = `/api/a2a/v1/.well-known/agent.json`;

		const response = await this.request(
			{
				path: urlPath,
				method: "GET",
				headers: headerParameters,
				query: queryParameters,
			},
			initOverrides,
		);

		return new runtime.JSONApiResponse<any>(response);
	}

	/**
	 * Get the agent card describing agent capabilities and metadata
	 * Get agent card
	 */
	async getAgentCard(
		initOverrides?: RequestInit | runtime.InitOverrideFunction,
	): Promise<object> {
		const response = await this.getAgentCardRaw(initOverrides);
		return await response.value();
	}

	/**
	 * Get the agent definition (capabilities and metadata)
	 * Get agent definition
	 */
	async getAgentDefinitionRaw(
		initOverrides?: RequestInit | runtime.InitOverrideFunction,
	): Promise<runtime.ApiResponse<SomaAgentDefinition>> {
		const queryParameters: any = {};

		const headerParameters: runtime.HTTPHeaders = {};

		const urlPath = `/api/a2a/v1/definition`;

		const response = await this.request(
			{
				path: urlPath,
				method: "GET",
				headers: headerParameters,
				query: queryParameters,
			},
			initOverrides,
		);

		return new runtime.JSONApiResponse(response, (jsonValue) =>
			SomaAgentDefinitionFromJSON(jsonValue),
		);
	}

	/**
	 * Get the agent definition (capabilities and metadata)
	 * Get agent definition
	 */
	async getAgentDefinition(
		initOverrides?: RequestInit | runtime.InitOverrideFunction,
	): Promise<SomaAgentDefinition> {
		const response = await this.getAgentDefinitionRaw(initOverrides);
		return await response.value();
	}

	/**
	 * Retrieve a data encryption key by its alias or ID
	 * Get DEK by alias
	 */
	async getDekByAliasOrIdRaw(
		requestParameters: V1ApiGetDekByAliasOrIdRequest,
		initOverrides?: RequestInit | runtime.InitOverrideFunction,
	): Promise<runtime.ApiResponse<DataEncryptionKey>> {
		if (requestParameters.alias == null) {
			throw new runtime.RequiredError(
				"alias",
				'Required parameter "alias" was null or undefined when calling getDekByAliasOrId().',
			);
		}

		const queryParameters: any = {};

		const headerParameters: runtime.HTTPHeaders = {};

		let urlPath = `/api/encryption/v1/dek/alias/{alias}`;
		urlPath = urlPath.replace(
			`{${"alias"}}`,
			encodeURIComponent(String(requestParameters.alias)),
		);

		const response = await this.request(
			{
				path: urlPath,
				method: "GET",
				headers: headerParameters,
				query: queryParameters,
			},
			initOverrides,
		);

		return new runtime.JSONApiResponse(response, (jsonValue) =>
			DataEncryptionKeyFromJSON(jsonValue),
		);
	}

	/**
	 * Retrieve a data encryption key by its alias or ID
	 * Get DEK by alias
	 */
	async getDekByAliasOrId(
		requestParameters: V1ApiGetDekByAliasOrIdRequest,
		initOverrides?: RequestInit | runtime.InitOverrideFunction,
	): Promise<DataEncryptionKey> {
		const response = await this.getDekByAliasOrIdRaw(
			requestParameters,
			initOverrides,
		);
		return await response.value();
	}

	/**
	 * Get the authenticated extended agent card with additional metadata
	 * Get extended agent card
	 */
	async getExtendedAgentCardRaw(
		initOverrides?: RequestInit | runtime.InitOverrideFunction,
	): Promise<runtime.ApiResponse<object>> {
		const queryParameters: any = {};

		const headerParameters: runtime.HTTPHeaders = {};

		const urlPath = `/api/a2a/v1/agent/authenticatedExtendedCard`;

		const response = await this.request(
			{
				path: urlPath,
				method: "GET",
				headers: headerParameters,
				query: queryParameters,
			},
			initOverrides,
		);

		return new runtime.JSONApiResponse<any>(response);
	}

	/**
	 * Get the authenticated extended agent card with additional metadata
	 * Get extended agent card
	 */
	async getExtendedAgentCard(
		initOverrides?: RequestInit | runtime.InitOverrideFunction,
	): Promise<object> {
		const response = await this.getExtendedAgentCardRaw(initOverrides);
		return await response.value();
	}

	/**
	 * Get the OpenAPI specification for all function instances
	 * Get function OpenAPI spec
	 */
	async getFunctionInstancesOpenapiSpecRaw(
		initOverrides?: RequestInit | runtime.InitOverrideFunction,
	): Promise<runtime.ApiResponse<string>> {
		const queryParameters: any = {};

		const headerParameters: runtime.HTTPHeaders = {};

		const urlPath = `/api/bridge/v1/function-instances/openapi.json`;

		const response = await this.request(
			{
				path: urlPath,
				method: "GET",
				headers: headerParameters,
				query: queryParameters,
			},
			initOverrides,
		);

		if (this.isJsonMime(response.headers.get("content-type"))) {
			return new runtime.JSONApiResponse<string>(response);
		} else {
			return new runtime.TextApiResponse(response) as any;
		}
	}

	/**
	 * Get the OpenAPI specification for all function instances
	 * Get function OpenAPI spec
	 */
	async getFunctionInstancesOpenapiSpec(
		initOverrides?: RequestInit | runtime.InitOverrideFunction,
	): Promise<string> {
		const response =
			await this.getFunctionInstancesOpenapiSpecRaw(initOverrides);
		return await response.value();
	}

	/**
	 * Get the current runtime configuration
	 * Get runtime config
	 */
	async getInternalRuntimeConfigRaw(
		initOverrides?: RequestInit | runtime.InitOverrideFunction,
	): Promise<runtime.ApiResponse<object>> {
		const queryParameters: any = {};

		const headerParameters: runtime.HTTPHeaders = {};

		const urlPath = `/_internal/v1/runtime_config`;

		const response = await this.request(
			{
				path: urlPath,
				method: "GET",
				headers: headerParameters,
				query: queryParameters,
			},
			initOverrides,
		);

		return new runtime.JSONApiResponse<any>(response);
	}

	/**
	 * Get the current runtime configuration
	 * Get runtime config
	 */
	async getInternalRuntimeConfig(
		initOverrides?: RequestInit | runtime.InitOverrideFunction,
	): Promise<object> {
		const response = await this.getInternalRuntimeConfigRaw(initOverrides);
		return await response.value();
	}

	/**
	 * Retrieve a provider instance by its unique identifier
	 * Get provider
	 */
	async getProviderInstanceRaw(
		requestParameters: V1ApiGetProviderInstanceRequest,
		initOverrides?: RequestInit | runtime.InitOverrideFunction,
	): Promise<runtime.ApiResponse<ProviderInstanceSerializedWithEverything>> {
		if (requestParameters.providerInstanceId == null) {
			throw new runtime.RequiredError(
				"providerInstanceId",
				'Required parameter "providerInstanceId" was null or undefined when calling getProviderInstance().',
			);
		}

		const queryParameters: any = {};

		const headerParameters: runtime.HTTPHeaders = {};

		let urlPath = `/api/bridge/v1/provider/{provider_instance_id}`;
		urlPath = urlPath.replace(
			`{${"provider_instance_id"}}`,
			encodeURIComponent(String(requestParameters.providerInstanceId)),
		);

		const response = await this.request(
			{
				path: urlPath,
				method: "GET",
				headers: headerParameters,
				query: queryParameters,
			},
			initOverrides,
		);

		return new runtime.JSONApiResponse(response, (jsonValue) =>
			ProviderInstanceSerializedWithEverythingFromJSON(jsonValue),
		);
	}

	/**
	 * Retrieve a provider instance by its unique identifier
	 * Get provider
	 */
	async getProviderInstance(
		requestParameters: V1ApiGetProviderInstanceRequest,
		initOverrides?: RequestInit | runtime.InitOverrideFunction,
	): Promise<ProviderInstanceSerializedWithEverything> {
		const response = await this.getProviderInstanceRaw(
			requestParameters,
			initOverrides,
		);
		return await response.value();
	}

	/**
	 * Retrieve a secret by its unique identifier
	 * Get secret
	 */
	async getSecretByIdRaw(
		requestParameters: V1ApiGetSecretByIdRequest,
		initOverrides?: RequestInit | runtime.InitOverrideFunction,
	): Promise<runtime.ApiResponse<Secret>> {
		if (requestParameters.secretId == null) {
			throw new runtime.RequiredError(
				"secretId",
				'Required parameter "secretId" was null or undefined when calling getSecretById().',
			);
		}

		const queryParameters: any = {};

		const headerParameters: runtime.HTTPHeaders = {};

		let urlPath = `/api/secret/v1/{secret_id}`;
		urlPath = urlPath.replace(
			`{${"secret_id"}}`,
			encodeURIComponent(String(requestParameters.secretId)),
		);

		const response = await this.request(
			{
				path: urlPath,
				method: "GET",
				headers: headerParameters,
				query: queryParameters,
			},
			initOverrides,
		);

		return new runtime.JSONApiResponse(response, (jsonValue) =>
			SecretFromJSON(jsonValue),
		);
	}

	/**
	 * Retrieve a secret by its unique identifier
	 * Get secret
	 */
	async getSecretById(
		requestParameters: V1ApiGetSecretByIdRequest,
		initOverrides?: RequestInit | runtime.InitOverrideFunction,
	): Promise<Secret> {
		const response = await this.getSecretByIdRaw(
			requestParameters,
			initOverrides,
		);
		return await response.value();
	}

	/**
	 * Retrieve a secret by its key name
	 * Get secret by key
	 */
	async getSecretByKeyRaw(
		requestParameters: V1ApiGetSecretByKeyRequest,
		initOverrides?: RequestInit | runtime.InitOverrideFunction,
	): Promise<runtime.ApiResponse<Secret>> {
		if (requestParameters.key == null) {
			throw new runtime.RequiredError(
				"key",
				'Required parameter "key" was null or undefined when calling getSecretByKey().',
			);
		}

		const queryParameters: any = {};

		const headerParameters: runtime.HTTPHeaders = {};

		let urlPath = `/api/secret/v1/key/{key}`;
		urlPath = urlPath.replace(
			`{${"key"}}`,
			encodeURIComponent(String(requestParameters.key)),
		);

		const response = await this.request(
			{
				path: urlPath,
				method: "GET",
				headers: headerParameters,
				query: queryParameters,
			},
			initOverrides,
		);

		return new runtime.JSONApiResponse(response, (jsonValue) =>
			SecretFromJSON(jsonValue),
		);
	}

	/**
	 * Retrieve a secret by its key name
	 * Get secret by key
	 */
	async getSecretByKey(
		requestParameters: V1ApiGetSecretByKeyRequest,
		initOverrides?: RequestInit | runtime.InitOverrideFunction,
	): Promise<Secret> {
		const response = await this.getSecretByKeyRaw(
			requestParameters,
			initOverrides,
		);
		return await response.value();
	}

	/**
	 * Retrieve a task by its unique identifier
	 * Get task
	 */
	async getTaskByIdRaw(
		requestParameters: V1ApiGetTaskByIdRequest,
		initOverrides?: RequestInit | runtime.InitOverrideFunction,
	): Promise<runtime.ApiResponse<TaskWithDetails>> {
		if (requestParameters.taskId == null) {
			throw new runtime.RequiredError(
				"taskId",
				'Required parameter "taskId" was null or undefined when calling getTaskById().',
			);
		}

		const queryParameters: any = {};

		const headerParameters: runtime.HTTPHeaders = {};

		let urlPath = `/api/task/v1/{task_id}`;
		urlPath = urlPath.replace(
			`{${"task_id"}}`,
			encodeURIComponent(String(requestParameters.taskId)),
		);

		const response = await this.request(
			{
				path: urlPath,
				method: "GET",
				headers: headerParameters,
				query: queryParameters,
			},
			initOverrides,
		);

		return new runtime.JSONApiResponse(response, (jsonValue) =>
			TaskWithDetailsFromJSON(jsonValue),
		);
	}

	/**
	 * Retrieve a task by its unique identifier
	 * Get task
	 */
	async getTaskById(
		requestParameters: V1ApiGetTaskByIdRequest,
		initOverrides?: RequestInit | runtime.InitOverrideFunction,
	): Promise<TaskWithDetails> {
		const response = await this.getTaskByIdRaw(
			requestParameters,
			initOverrides,
		);
		return await response.value();
	}

	/**
	 * Handle JSON-RPC requests for agent-to-agent communication (tasks, messages, etc.)
	 * Handle JSON-RPC
	 */
	async handleJsonrpcRequestRaw(
		requestParameters: V1ApiHandleJsonrpcRequestRequest,
		initOverrides?: RequestInit | runtime.InitOverrideFunction,
	): Promise<runtime.ApiResponse<void>> {
		if (requestParameters.body == null) {
			throw new runtime.RequiredError(
				"body",
				'Required parameter "body" was null or undefined when calling handleJsonrpcRequest().',
			);
		}

		const queryParameters: any = {};

		const headerParameters: runtime.HTTPHeaders = {};

		headerParameters["Content-Type"] = "application/json";

		const urlPath = `/api/a2a/v1`;

		const response = await this.request(
			{
				path: urlPath,
				method: "POST",
				headers: headerParameters,
				query: queryParameters,
				body: requestParameters.body as any,
			},
			initOverrides,
		);

		return new runtime.VoidApiResponse(response);
	}

	/**
	 * Handle JSON-RPC requests for agent-to-agent communication (tasks, messages, etc.)
	 * Handle JSON-RPC
	 */
	async handleJsonrpcRequest(
		requestParameters: V1ApiHandleJsonrpcRequestRequest,
		initOverrides?: RequestInit | runtime.InitOverrideFunction,
	): Promise<void> {
		await this.handleJsonrpcRequestRaw(requestParameters, initOverrides);
	}

	/**
	 * Check the health status of the service and SDK server connectivity
	 * Health check
	 */
	async healthCheckRaw(
		initOverrides?: RequestInit | runtime.InitOverrideFunction,
	): Promise<runtime.ApiResponse<void>> {
		const queryParameters: any = {};

		const headerParameters: runtime.HTTPHeaders = {};

		const urlPath = `/_internal/v1/health`;

		const response = await this.request(
			{
				path: urlPath,
				method: "GET",
				headers: headerParameters,
				query: queryParameters,
			},
			initOverrides,
		);

		return new runtime.VoidApiResponse(response);
	}

	/**
	 * Check the health status of the service and SDK server connectivity
	 * Health check
	 */
	async healthCheck(
		initOverrides?: RequestInit | runtime.InitOverrideFunction,
	): Promise<void> {
		await this.healthCheckRaw(initOverrides);
	}

	/**
	 * Import an existing pre-encrypted data encryption key into the system
	 * Import data key
	 */
	async importDataEncryptionKeyRaw(
		requestParameters: V1ApiImportDataEncryptionKeyRequest,
		initOverrides?: RequestInit | runtime.InitOverrideFunction,
	): Promise<runtime.ApiResponse<DataEncryptionKey>> {
		if (requestParameters.envelopeId == null) {
			throw new runtime.RequiredError(
				"envelopeId",
				'Required parameter "envelopeId" was null or undefined when calling importDataEncryptionKey().',
			);
		}

		if (requestParameters.importDataEncryptionKeyParamsRoute == null) {
			throw new runtime.RequiredError(
				"importDataEncryptionKeyParamsRoute",
				'Required parameter "importDataEncryptionKeyParamsRoute" was null or undefined when calling importDataEncryptionKey().',
			);
		}

		const queryParameters: any = {};

		const headerParameters: runtime.HTTPHeaders = {};

		headerParameters["Content-Type"] = "application/json";

		let urlPath = `/api/encryption/v1/envelope/{envelope_id}/dek/import`;
		urlPath = urlPath.replace(
			`{${"envelope_id"}}`,
			encodeURIComponent(String(requestParameters.envelopeId)),
		);

		const response = await this.request(
			{
				path: urlPath,
				method: "POST",
				headers: headerParameters,
				query: queryParameters,
				body: ImportDataEncryptionKeyParamsRouteToJSON(
					requestParameters.importDataEncryptionKeyParamsRoute,
				),
			},
			initOverrides,
		);

		return new runtime.JSONApiResponse(response, (jsonValue) =>
			DataEncryptionKeyFromJSON(jsonValue),
		);
	}

	/**
	 * Import an existing pre-encrypted data encryption key into the system
	 * Import data key
	 */
	async importDataEncryptionKey(
		requestParameters: V1ApiImportDataEncryptionKeyRequest,
		initOverrides?: RequestInit | runtime.InitOverrideFunction,
	): Promise<DataEncryptionKey> {
		const response = await this.importDataEncryptionKeyRaw(
			requestParameters,
			initOverrides,
		);
		return await response.value();
	}

	/**
	 * Import an existing pre-encrypted secret into the system
	 * Import secret
	 */
	async importSecretRaw(
		requestParameters: V1ApiImportSecretOperationRequest,
		initOverrides?: RequestInit | runtime.InitOverrideFunction,
	): Promise<runtime.ApiResponse<Secret>> {
		if (requestParameters.importSecretRequest == null) {
			throw new runtime.RequiredError(
				"importSecretRequest",
				'Required parameter "importSecretRequest" was null or undefined when calling importSecret().',
			);
		}

		const queryParameters: any = {};

		const headerParameters: runtime.HTTPHeaders = {};

		headerParameters["Content-Type"] = "application/json";

		const urlPath = `/api/secret/v1/import`;

		const response = await this.request(
			{
				path: urlPath,
				method: "POST",
				headers: headerParameters,
				query: queryParameters,
				body: ImportSecretRequestToJSON(requestParameters.importSecretRequest),
			},
			initOverrides,
		);

		return new runtime.JSONApiResponse(response, (jsonValue) =>
			SecretFromJSON(jsonValue),
		);
	}

	/**
	 * Import an existing pre-encrypted secret into the system
	 * Import secret
	 */
	async importSecret(
		requestParameters: V1ApiImportSecretOperationRequest,
		initOverrides?: RequestInit | runtime.InitOverrideFunction,
	): Promise<Secret> {
		const response = await this.importSecretRaw(
			requestParameters,
			initOverrides,
		);
		return await response.value();
	}

	/**
	 * Invoke a function on a provider instance
	 * Invoke function
	 */
	async invokeFunctionRaw(
		requestParameters: V1ApiInvokeFunctionRequest,
		initOverrides?: RequestInit | runtime.InitOverrideFunction,
	): Promise<runtime.ApiResponse<InvokeResult>> {
		if (requestParameters.providerInstanceId == null) {
			throw new runtime.RequiredError(
				"providerInstanceId",
				'Required parameter "providerInstanceId" was null or undefined when calling invokeFunction().',
			);
		}

		if (requestParameters.functionControllerTypeId == null) {
			throw new runtime.RequiredError(
				"functionControllerTypeId",
				'Required parameter "functionControllerTypeId" was null or undefined when calling invokeFunction().',
			);
		}

		if (requestParameters.invokeFunctionParamsInner == null) {
			throw new runtime.RequiredError(
				"invokeFunctionParamsInner",
				'Required parameter "invokeFunctionParamsInner" was null or undefined when calling invokeFunction().',
			);
		}

		const queryParameters: any = {};

		const headerParameters: runtime.HTTPHeaders = {};

		headerParameters["Content-Type"] = "application/json";

		let urlPath = `/api/bridge/v1/provider/{provider_instance_id}/function/{function_controller_type_id}/invoke`;
		urlPath = urlPath.replace(
			`{${"provider_instance_id"}}`,
			encodeURIComponent(String(requestParameters.providerInstanceId)),
		);
		urlPath = urlPath.replace(
			`{${"function_controller_type_id"}}`,
			encodeURIComponent(String(requestParameters.functionControllerTypeId)),
		);

		const response = await this.request(
			{
				path: urlPath,
				method: "POST",
				headers: headerParameters,
				query: queryParameters,
				body: InvokeFunctionParamsInnerToJSON(
					requestParameters.invokeFunctionParamsInner,
				),
			},
			initOverrides,
		);

		return new runtime.JSONApiResponse(response, (jsonValue) =>
			InvokeResultFromJSON(jsonValue),
		);
	}

	/**
	 * Invoke a function on a provider instance
	 * Invoke function
	 */
	async invokeFunction(
		requestParameters: V1ApiInvokeFunctionRequest,
		initOverrides?: RequestInit | runtime.InitOverrideFunction,
	): Promise<InvokeResult> {
		const response = await this.invokeFunctionRaw(
			requestParameters,
			initOverrides,
		);
		return await response.value();
	}

	/**
	 * List all available provider types that can be instantiated
	 * List providers
	 */
	async listAvailableProvidersRaw(
		requestParameters: V1ApiListAvailableProvidersRequest,
		initOverrides?: RequestInit | runtime.InitOverrideFunction,
	): Promise<
		runtime.ApiResponse<ProviderControllerSerializedPaginatedResponse>
	> {
		if (requestParameters.pageSize == null) {
			throw new runtime.RequiredError(
				"pageSize",
				'Required parameter "pageSize" was null or undefined when calling listAvailableProviders().',
			);
		}

		const queryParameters: any = {};

		if (requestParameters.pageSize != null) {
			queryParameters.page_size = requestParameters.pageSize;
		}

		if (requestParameters.nextPageToken != null) {
			queryParameters.next_page_token = requestParameters.nextPageToken;
		}

		const headerParameters: runtime.HTTPHeaders = {};

		const urlPath = `/api/bridge/v1/available-providers`;

		const response = await this.request(
			{
				path: urlPath,
				method: "GET",
				headers: headerParameters,
				query: queryParameters,
			},
			initOverrides,
		);

		return new runtime.JSONApiResponse(response, (jsonValue) =>
			ProviderControllerSerializedPaginatedResponseFromJSON(jsonValue),
		);
	}

	/**
	 * List all available provider types that can be instantiated
	 * List providers
	 */
	async listAvailableProviders(
		requestParameters: V1ApiListAvailableProvidersRequest,
		initOverrides?: RequestInit | runtime.InitOverrideFunction,
	): Promise<ProviderControllerSerializedPaginatedResponse> {
		const response = await this.listAvailableProvidersRaw(
			requestParameters,
			initOverrides,
		);
		return await response.value();
	}

	/**
	 * List all unique task contexts with pagination
	 * List contexts
	 */
	async listContextsRaw(
		requestParameters: V1ApiListContextsRequest,
		initOverrides?: RequestInit | runtime.InitOverrideFunction,
	): Promise<runtime.ApiResponse<ContextInfoPaginatedResponse>> {
		if (requestParameters.pageSize == null) {
			throw new runtime.RequiredError(
				"pageSize",
				'Required parameter "pageSize" was null or undefined when calling listContexts().',
			);
		}

		const queryParameters: any = {};

		if (requestParameters.pageSize != null) {
			queryParameters.page_size = requestParameters.pageSize;
		}

		if (requestParameters.nextPageToken != null) {
			queryParameters.next_page_token = requestParameters.nextPageToken;
		}

		const headerParameters: runtime.HTTPHeaders = {};

		const urlPath = `/api/task/v1/context`;

		const response = await this.request(
			{
				path: urlPath,
				method: "GET",
				headers: headerParameters,
				query: queryParameters,
			},
			initOverrides,
		);

		return new runtime.JSONApiResponse(response, (jsonValue) =>
			ContextInfoPaginatedResponseFromJSON(jsonValue),
		);
	}

	/**
	 * List all unique task contexts with pagination
	 * List contexts
	 */
	async listContexts(
		requestParameters: V1ApiListContextsRequest,
		initOverrides?: RequestInit | runtime.InitOverrideFunction,
	): Promise<ContextInfoPaginatedResponse> {
		const response = await this.listContextsRaw(
			requestParameters,
			initOverrides,
		);
		return await response.value();
	}

	/**
	 * List all data encryption keys encrypted with the specified envelope encryption key
	 * List data keys
	 */
	async listDataEncryptionKeysByEnvelopeRaw(
		requestParameters: V1ApiListDataEncryptionKeysByEnvelopeRequest,
		initOverrides?: RequestInit | runtime.InitOverrideFunction,
	): Promise<runtime.ApiResponse<DataEncryptionKeyListItemPaginatedResponse>> {
		if (requestParameters.envelopeId == null) {
			throw new runtime.RequiredError(
				"envelopeId",
				'Required parameter "envelopeId" was null or undefined when calling listDataEncryptionKeysByEnvelope().',
			);
		}

		if (requestParameters.pageSize == null) {
			throw new runtime.RequiredError(
				"pageSize",
				'Required parameter "pageSize" was null or undefined when calling listDataEncryptionKeysByEnvelope().',
			);
		}

		const queryParameters: any = {};

		if (requestParameters.pageSize != null) {
			queryParameters.page_size = requestParameters.pageSize;
		}

		if (requestParameters.nextPageToken != null) {
			queryParameters.next_page_token = requestParameters.nextPageToken;
		}

		const headerParameters: runtime.HTTPHeaders = {};

		let urlPath = `/api/encryption/v1/envelope/{envelope_id}/dek`;
		urlPath = urlPath.replace(
			`{${"envelope_id"}}`,
			encodeURIComponent(String(requestParameters.envelopeId)),
		);

		const response = await this.request(
			{
				path: urlPath,
				method: "GET",
				headers: headerParameters,
				query: queryParameters,
			},
			initOverrides,
		);

		return new runtime.JSONApiResponse(response, (jsonValue) =>
			DataEncryptionKeyListItemPaginatedResponseFromJSON(jsonValue),
		);
	}

	/**
	 * List all data encryption keys encrypted with the specified envelope encryption key
	 * List data keys
	 */
	async listDataEncryptionKeysByEnvelope(
		requestParameters: V1ApiListDataEncryptionKeysByEnvelopeRequest,
		initOverrides?: RequestInit | runtime.InitOverrideFunction,
	): Promise<DataEncryptionKeyListItemPaginatedResponse> {
		const response = await this.listDataEncryptionKeysByEnvelopeRaw(
			requestParameters,
			initOverrides,
		);
		return await response.value();
	}

	/**
	 * List all secrets with decrypted values (requires decryption access)
	 * List decrypted secrets
	 */
	async listDecryptedSecretsRaw(
		requestParameters: V1ApiListDecryptedSecretsRequest,
		initOverrides?: RequestInit | runtime.InitOverrideFunction,
	): Promise<runtime.ApiResponse<ListDecryptedSecretsResponse>> {
		if (requestParameters.pageSize == null) {
			throw new runtime.RequiredError(
				"pageSize",
				'Required parameter "pageSize" was null or undefined when calling listDecryptedSecrets().',
			);
		}

		const queryParameters: any = {};

		if (requestParameters.pageSize != null) {
			queryParameters.page_size = requestParameters.pageSize;
		}

		if (requestParameters.nextPageToken != null) {
			queryParameters.next_page_token = requestParameters.nextPageToken;
		}

		const headerParameters: runtime.HTTPHeaders = {};

		const urlPath = `/api/secret/v1/list-decrypted`;

		const response = await this.request(
			{
				path: urlPath,
				method: "GET",
				headers: headerParameters,
				query: queryParameters,
			},
			initOverrides,
		);

		return new runtime.JSONApiResponse(response, (jsonValue) =>
			ListDecryptedSecretsResponseFromJSON(jsonValue),
		);
	}

	/**
	 * List all secrets with decrypted values (requires decryption access)
	 * List decrypted secrets
	 */
	async listDecryptedSecrets(
		requestParameters: V1ApiListDecryptedSecretsRequest,
		initOverrides?: RequestInit | runtime.InitOverrideFunction,
	): Promise<ListDecryptedSecretsResponse> {
		const response = await this.listDecryptedSecretsRaw(
			requestParameters,
			initOverrides,
		);
		return await response.value();
	}

	/**
	 * List all envelope encryption keys (master keys) with pagination
	 * List envelope keys
	 */
	async listEnvelopeEncryptionKeysRaw(
		requestParameters: V1ApiListEnvelopeEncryptionKeysRequest,
		initOverrides?: RequestInit | runtime.InitOverrideFunction,
	): Promise<runtime.ApiResponse<EnvelopeEncryptionKeyPaginatedResponse>> {
		if (requestParameters.pageSize == null) {
			throw new runtime.RequiredError(
				"pageSize",
				'Required parameter "pageSize" was null or undefined when calling listEnvelopeEncryptionKeys().',
			);
		}

		const queryParameters: any = {};

		if (requestParameters.pageSize != null) {
			queryParameters.page_size = requestParameters.pageSize;
		}

		if (requestParameters.nextPageToken != null) {
			queryParameters.next_page_token = requestParameters.nextPageToken;
		}

		const headerParameters: runtime.HTTPHeaders = {};

		const urlPath = `/api/encryption/v1/envelope`;

		const response = await this.request(
			{
				path: urlPath,
				method: "GET",
				headers: headerParameters,
				query: queryParameters,
			},
			initOverrides,
		);

		return new runtime.JSONApiResponse(response, (jsonValue) =>
			EnvelopeEncryptionKeyPaginatedResponseFromJSON(jsonValue),
		);
	}

	/**
	 * List all envelope encryption keys (master keys) with pagination
	 * List envelope keys
	 */
	async listEnvelopeEncryptionKeys(
		requestParameters: V1ApiListEnvelopeEncryptionKeysRequest,
		initOverrides?: RequestInit | runtime.InitOverrideFunction,
	): Promise<EnvelopeEncryptionKeyPaginatedResponse> {
		const response = await this.listEnvelopeEncryptionKeysRaw(
			requestParameters,
			initOverrides,
		);
		return await response.value();
	}

	/**
	 * List all function instances with optional filtering by provider instance
	 * List function instances
	 */
	async listFunctionInstancesRaw(
		requestParameters: V1ApiListFunctionInstancesRequest,
		initOverrides?: RequestInit | runtime.InitOverrideFunction,
	): Promise<runtime.ApiResponse<FunctionInstanceSerializedPaginatedResponse>> {
		if (requestParameters.pageSize == null) {
			throw new runtime.RequiredError(
				"pageSize",
				'Required parameter "pageSize" was null or undefined when calling listFunctionInstances().',
			);
		}

		const queryParameters: any = {};

		if (requestParameters.pageSize != null) {
			queryParameters.page_size = requestParameters.pageSize;
		}

		if (requestParameters.nextPageToken != null) {
			queryParameters.next_page_token = requestParameters.nextPageToken;
		}

		if (requestParameters.providerInstanceId != null) {
			queryParameters.provider_instance_id =
				requestParameters.providerInstanceId;
		}

		const headerParameters: runtime.HTTPHeaders = {};

		const urlPath = `/api/bridge/v1/function-instances`;

		const response = await this.request(
			{
				path: urlPath,
				method: "GET",
				headers: headerParameters,
				query: queryParameters,
			},
			initOverrides,
		);

		return new runtime.JSONApiResponse(response, (jsonValue) =>
			FunctionInstanceSerializedPaginatedResponseFromJSON(jsonValue),
		);
	}

	/**
	 * List all function instances with optional filtering by provider instance
	 * List function instances
	 */
	async listFunctionInstances(
		requestParameters: V1ApiListFunctionInstancesRequest,
		initOverrides?: RequestInit | runtime.InitOverrideFunction,
	): Promise<FunctionInstanceSerializedPaginatedResponse> {
		const response = await this.listFunctionInstancesRaw(
			requestParameters,
			initOverrides,
		);
		return await response.value();
	}

	/**
	 * List all provider instances with optional filtering by status and provider type
	 * List provider instances
	 */
	async listProviderInstancesRaw(
		requestParameters: V1ApiListProviderInstancesRequest,
		initOverrides?: RequestInit | runtime.InitOverrideFunction,
	): Promise<runtime.ApiResponse<ProviderInstanceListItemPaginatedResponse>> {
		if (requestParameters.pageSize == null) {
			throw new runtime.RequiredError(
				"pageSize",
				'Required parameter "pageSize" was null or undefined when calling listProviderInstances().',
			);
		}

		const queryParameters: any = {};

		if (requestParameters.pageSize != null) {
			queryParameters.page_size = requestParameters.pageSize;
		}

		if (requestParameters.nextPageToken != null) {
			queryParameters.next_page_token = requestParameters.nextPageToken;
		}

		if (requestParameters.status != null) {
			queryParameters.status = requestParameters.status;
		}

		if (requestParameters.providerControllerTypeId != null) {
			queryParameters.provider_controller_type_id =
				requestParameters.providerControllerTypeId;
		}

		const headerParameters: runtime.HTTPHeaders = {};

		const urlPath = `/api/bridge/v1/provider`;

		const response = await this.request(
			{
				path: urlPath,
				method: "GET",
				headers: headerParameters,
				query: queryParameters,
			},
			initOverrides,
		);

		return new runtime.JSONApiResponse(response, (jsonValue) =>
			ProviderInstanceListItemPaginatedResponseFromJSON(jsonValue),
		);
	}

	/**
	 * List all provider instances with optional filtering by status and provider type
	 * List provider instances
	 */
	async listProviderInstances(
		requestParameters: V1ApiListProviderInstancesRequest,
		initOverrides?: RequestInit | runtime.InitOverrideFunction,
	): Promise<ProviderInstanceListItemPaginatedResponse> {
		const response = await this.listProviderInstancesRaw(
			requestParameters,
			initOverrides,
		);
		return await response.value();
	}

	/**
	 * List provider instances grouped by their associated functions
	 * List providers by function
	 */
	async listProviderInstancesGroupedByFunctionRaw(
		requestParameters: V1ApiListProviderInstancesGroupedByFunctionRequest,
		initOverrides?: RequestInit | runtime.InitOverrideFunction,
	): Promise<runtime.ApiResponse<FunctionInstanceConfigPaginatedResponse>> {
		if (requestParameters.pageSize == null) {
			throw new runtime.RequiredError(
				"pageSize",
				'Required parameter "pageSize" was null or undefined when calling listProviderInstancesGroupedByFunction().',
			);
		}

		const queryParameters: any = {};

		if (requestParameters.nextPageToken != null) {
			queryParameters.next_page_token = requestParameters.nextPageToken;
		}

		if (requestParameters.pageSize != null) {
			queryParameters.page_size = requestParameters.pageSize;
		}

		if (requestParameters.providerControllerTypeId != null) {
			queryParameters.provider_controller_type_id =
				requestParameters.providerControllerTypeId;
		}

		if (requestParameters.functionCategory != null) {
			queryParameters.function_category = requestParameters.functionCategory;
		}

		const headerParameters: runtime.HTTPHeaders = {};

		const urlPath = `/api/bridge/v1/provider/grouped-by-function`;

		const response = await this.request(
			{
				path: urlPath,
				method: "GET",
				headers: headerParameters,
				query: queryParameters,
			},
			initOverrides,
		);

		return new runtime.JSONApiResponse(response, (jsonValue) =>
			FunctionInstanceConfigPaginatedResponseFromJSON(jsonValue),
		);
	}

	/**
	 * List provider instances grouped by their associated functions
	 * List providers by function
	 */
	async listProviderInstancesGroupedByFunction(
		requestParameters: V1ApiListProviderInstancesGroupedByFunctionRequest,
		initOverrides?: RequestInit | runtime.InitOverrideFunction,
	): Promise<FunctionInstanceConfigPaginatedResponse> {
		const response = await this.listProviderInstancesGroupedByFunctionRaw(
			requestParameters,
			initOverrides,
		);
		return await response.value();
	}

	/**
	 * List all secrets with pagination (values are encrypted)
	 * List secrets
	 */
	async listSecretsRaw(
		requestParameters: V1ApiListSecretsRequest,
		initOverrides?: RequestInit | runtime.InitOverrideFunction,
	): Promise<runtime.ApiResponse<ListSecretsResponse>> {
		if (requestParameters.pageSize == null) {
			throw new runtime.RequiredError(
				"pageSize",
				'Required parameter "pageSize" was null or undefined when calling listSecrets().',
			);
		}

		const queryParameters: any = {};

		if (requestParameters.pageSize != null) {
			queryParameters.page_size = requestParameters.pageSize;
		}

		if (requestParameters.nextPageToken != null) {
			queryParameters.next_page_token = requestParameters.nextPageToken;
		}

		const headerParameters: runtime.HTTPHeaders = {};

		const urlPath = `/api/secret/v1`;

		const response = await this.request(
			{
				path: urlPath,
				method: "GET",
				headers: headerParameters,
				query: queryParameters,
			},
			initOverrides,
		);

		return new runtime.JSONApiResponse(response, (jsonValue) =>
			ListSecretsResponseFromJSON(jsonValue),
		);
	}

	/**
	 * List all secrets with pagination (values are encrypted)
	 * List secrets
	 */
	async listSecrets(
		requestParameters: V1ApiListSecretsRequest,
		initOverrides?: RequestInit | runtime.InitOverrideFunction,
	): Promise<ListSecretsResponse> {
		const response = await this.listSecretsRaw(
			requestParameters,
			initOverrides,
		);
		return await response.value();
	}

	/**
	 * List all tasks with pagination
	 * List tasks
	 */
	async listTasksRaw(
		requestParameters: V1ApiListTasksRequest,
		initOverrides?: RequestInit | runtime.InitOverrideFunction,
	): Promise<runtime.ApiResponse<TaskPaginatedResponse>> {
		if (requestParameters.pageSize == null) {
			throw new runtime.RequiredError(
				"pageSize",
				'Required parameter "pageSize" was null or undefined when calling listTasks().',
			);
		}

		const queryParameters: any = {};

		if (requestParameters.pageSize != null) {
			queryParameters.page_size = requestParameters.pageSize;
		}

		if (requestParameters.nextPageToken != null) {
			queryParameters.next_page_token = requestParameters.nextPageToken;
		}

		const headerParameters: runtime.HTTPHeaders = {};

		const urlPath = `/api/task/v1`;

		const response = await this.request(
			{
				path: urlPath,
				method: "GET",
				headers: headerParameters,
				query: queryParameters,
			},
			initOverrides,
		);

		return new runtime.JSONApiResponse(response, (jsonValue) =>
			TaskPaginatedResponseFromJSON(jsonValue),
		);
	}

	/**
	 * List all tasks with pagination
	 * List tasks
	 */
	async listTasks(
		requestParameters: V1ApiListTasksRequest,
		initOverrides?: RequestInit | runtime.InitOverrideFunction,
	): Promise<TaskPaginatedResponse> {
		const response = await this.listTasksRaw(requestParameters, initOverrides);
		return await response.value();
	}

	/**
	 * List all tasks for a specific context ID with pagination
	 * List tasks by context
	 */
	async listTasksByContextIdRaw(
		requestParameters: V1ApiListTasksByContextIdRequest,
		initOverrides?: RequestInit | runtime.InitOverrideFunction,
	): Promise<runtime.ApiResponse<TaskPaginatedResponse>> {
		if (requestParameters.pageSize == null) {
			throw new runtime.RequiredError(
				"pageSize",
				'Required parameter "pageSize" was null or undefined when calling listTasksByContextId().',
			);
		}

		if (requestParameters.contextId == null) {
			throw new runtime.RequiredError(
				"contextId",
				'Required parameter "contextId" was null or undefined when calling listTasksByContextId().',
			);
		}

		const queryParameters: any = {};

		if (requestParameters.pageSize != null) {
			queryParameters.page_size = requestParameters.pageSize;
		}

		if (requestParameters.nextPageToken != null) {
			queryParameters.next_page_token = requestParameters.nextPageToken;
		}

		const headerParameters: runtime.HTTPHeaders = {};

		let urlPath = `/api/task/v1/context/{context_id}/task`;
		urlPath = urlPath.replace(
			`{${"context_id"}}`,
			encodeURIComponent(String(requestParameters.contextId)),
		);

		const response = await this.request(
			{
				path: urlPath,
				method: "GET",
				headers: headerParameters,
				query: queryParameters,
			},
			initOverrides,
		);

		return new runtime.JSONApiResponse(response, (jsonValue) =>
			TaskPaginatedResponseFromJSON(jsonValue),
		);
	}

	/**
	 * List all tasks for a specific context ID with pagination
	 * List tasks by context
	 */
	async listTasksByContextId(
		requestParameters: V1ApiListTasksByContextIdRequest,
		initOverrides?: RequestInit | runtime.InitOverrideFunction,
	): Promise<TaskPaginatedResponse> {
		const response = await this.listTasksByContextIdRaw(
			requestParameters,
			initOverrides,
		);
		return await response.value();
	}

	/**
	 * Establish Server-Sent Events (SSE) connection for MCP protocol communication
	 * MCP SSE connection
	 */
	async listenToMcpSseRaw(
		initOverrides?: RequestInit | runtime.InitOverrideFunction,
	): Promise<runtime.ApiResponse<void>> {
		const queryParameters: any = {};

		const headerParameters: runtime.HTTPHeaders = {};

		const urlPath = `/api/bridge/v1/mcp`;

		const response = await this.request(
			{
				path: urlPath,
				method: "GET",
				headers: headerParameters,
				query: queryParameters,
			},
			initOverrides,
		);

		return new runtime.VoidApiResponse(response);
	}

	/**
	 * Establish Server-Sent Events (SSE) connection for MCP protocol communication
	 * MCP SSE connection
	 */
	async listenToMcpSse(
		initOverrides?: RequestInit | runtime.InitOverrideFunction,
	): Promise<void> {
		await this.listenToMcpSseRaw(initOverrides);
	}

	/**
	 * Migrate all data encryption keys encrypted with the specified envelope key to a new envelope key
	 * Migrate all data keys
	 */
	async migrateAllDataEncryptionKeysRaw(
		requestParameters: V1ApiMigrateAllDataEncryptionKeysRequest,
		initOverrides?: RequestInit | runtime.InitOverrideFunction,
	): Promise<runtime.ApiResponse<void>> {
		if (requestParameters.envelopeId == null) {
			throw new runtime.RequiredError(
				"envelopeId",
				'Required parameter "envelopeId" was null or undefined when calling migrateAllDataEncryptionKeys().',
			);
		}

		if (requestParameters.migrateAllDataEncryptionKeysParamsRoute == null) {
			throw new runtime.RequiredError(
				"migrateAllDataEncryptionKeysParamsRoute",
				'Required parameter "migrateAllDataEncryptionKeysParamsRoute" was null or undefined when calling migrateAllDataEncryptionKeys().',
			);
		}

		const queryParameters: any = {};

		const headerParameters: runtime.HTTPHeaders = {};

		headerParameters["Content-Type"] = "application/json";

		let urlPath = `/api/encryption/v1/envelope/{envelope_id}/migrate`;
		urlPath = urlPath.replace(
			`{${"envelope_id"}}`,
			encodeURIComponent(String(requestParameters.envelopeId)),
		);

		const response = await this.request(
			{
				path: urlPath,
				method: "POST",
				headers: headerParameters,
				query: queryParameters,
				body: MigrateAllDataEncryptionKeysParamsRouteToJSON(
					requestParameters.migrateAllDataEncryptionKeysParamsRoute,
				),
			},
			initOverrides,
		);

		return new runtime.VoidApiResponse(response);
	}

	/**
	 * Migrate all data encryption keys encrypted with the specified envelope key to a new envelope key
	 * Migrate all data keys
	 */
	async migrateAllDataEncryptionKeys(
		requestParameters: V1ApiMigrateAllDataEncryptionKeysRequest,
		initOverrides?: RequestInit | runtime.InitOverrideFunction,
	): Promise<void> {
		await this.migrateAllDataEncryptionKeysRaw(
			requestParameters,
			initOverrides,
		);
	}

	/**
	 * Migrate a data encryption key to be encrypted with a different envelope encryption key
	 * Migrate data key
	 */
	async migrateDataEncryptionKeyRaw(
		requestParameters: V1ApiMigrateDataEncryptionKeyRequest,
		initOverrides?: RequestInit | runtime.InitOverrideFunction,
	): Promise<runtime.ApiResponse<void>> {
		if (requestParameters.envelopeId == null) {
			throw new runtime.RequiredError(
				"envelopeId",
				'Required parameter "envelopeId" was null or undefined when calling migrateDataEncryptionKey().',
			);
		}

		if (requestParameters.dekId == null) {
			throw new runtime.RequiredError(
				"dekId",
				'Required parameter "dekId" was null or undefined when calling migrateDataEncryptionKey().',
			);
		}

		if (requestParameters.migrateDataEncryptionKeyParamsRoute == null) {
			throw new runtime.RequiredError(
				"migrateDataEncryptionKeyParamsRoute",
				'Required parameter "migrateDataEncryptionKeyParamsRoute" was null or undefined when calling migrateDataEncryptionKey().',
			);
		}

		const queryParameters: any = {};

		const headerParameters: runtime.HTTPHeaders = {};

		headerParameters["Content-Type"] = "application/json";

		let urlPath = `/api/encryption/v1/envelope/{envelope_id}/dek/{dek_id}/migrate`;
		urlPath = urlPath.replace(
			`{${"envelope_id"}}`,
			encodeURIComponent(String(requestParameters.envelopeId)),
		);
		urlPath = urlPath.replace(
			`{${"dek_id"}}`,
			encodeURIComponent(String(requestParameters.dekId)),
		);

		const response = await this.request(
			{
				path: urlPath,
				method: "POST",
				headers: headerParameters,
				query: queryParameters,
				body: MigrateDataEncryptionKeyParamsRouteToJSON(
					requestParameters.migrateDataEncryptionKeyParamsRoute,
				),
			},
			initOverrides,
		);

		return new runtime.VoidApiResponse(response);
	}

	/**
	 * Migrate a data encryption key to be encrypted with a different envelope encryption key
	 * Migrate data key
	 */
	async migrateDataEncryptionKey(
		requestParameters: V1ApiMigrateDataEncryptionKeyRequest,
		initOverrides?: RequestInit | runtime.InitOverrideFunction,
	): Promise<void> {
		await this.migrateDataEncryptionKeyRaw(requestParameters, initOverrides);
	}

	/**
	 * Handle OAuth callback to complete user credential brokering flow
	 * OAuth callback
	 */
	async resumeUserCredentialBrokeringRaw(
		requestParameters: V1ApiResumeUserCredentialBrokeringRequest,
		initOverrides?: RequestInit | runtime.InitOverrideFunction,
	): Promise<runtime.ApiResponse<UserCredentialBrokeringResponse>> {
		const queryParameters: any = {};

		if (requestParameters.state != null) {
			queryParameters.state = requestParameters.state;
		}

		if (requestParameters.code != null) {
			queryParameters.code = requestParameters.code;
		}

		if (requestParameters.error != null) {
			queryParameters.error = requestParameters.error;
		}

		if (requestParameters.errorDescription != null) {
			queryParameters.error_description = requestParameters.errorDescription;
		}

		const headerParameters: runtime.HTTPHeaders = {};

		const urlPath = `/api/bridge/v1/generic-oauth-callback`;

		const response = await this.request(
			{
				path: urlPath,
				method: "GET",
				headers: headerParameters,
				query: queryParameters,
			},
			initOverrides,
		);

		return new runtime.JSONApiResponse(response, (jsonValue) =>
			UserCredentialBrokeringResponseFromJSON(jsonValue),
		);
	}

	/**
	 * Handle OAuth callback to complete user credential brokering flow
	 * OAuth callback
	 */
	async resumeUserCredentialBrokering(
		requestParameters: V1ApiResumeUserCredentialBrokeringRequest = {},
		initOverrides?: RequestInit | runtime.InitOverrideFunction,
	): Promise<UserCredentialBrokeringResponse> {
		const response = await this.resumeUserCredentialBrokeringRaw(
			requestParameters,
			initOverrides,
		);
		return await response.value();
	}

	/**
	 * Send a message to a task
	 * Send message
	 */
	async sendMessageRaw(
		requestParameters: V1ApiSendMessageRequest,
		initOverrides?: RequestInit | runtime.InitOverrideFunction,
	): Promise<runtime.ApiResponse<CreateMessageResponse>> {
		if (requestParameters.taskId == null) {
			throw new runtime.RequiredError(
				"taskId",
				'Required parameter "taskId" was null or undefined when calling sendMessage().',
			);
		}

		if (requestParameters.createMessageRequest == null) {
			throw new runtime.RequiredError(
				"createMessageRequest",
				'Required parameter "createMessageRequest" was null or undefined when calling sendMessage().',
			);
		}

		const queryParameters: any = {};

		const headerParameters: runtime.HTTPHeaders = {};

		headerParameters["Content-Type"] = "application/json";

		let urlPath = `/api/task/v1/{task_id}/message`;
		urlPath = urlPath.replace(
			`{${"task_id"}}`,
			encodeURIComponent(String(requestParameters.taskId)),
		);

		const response = await this.request(
			{
				path: urlPath,
				method: "POST",
				headers: headerParameters,
				query: queryParameters,
				body: CreateMessageRequestToJSON(
					requestParameters.createMessageRequest,
				),
			},
			initOverrides,
		);

		return new runtime.JSONApiResponse(response, (jsonValue) =>
			CreateMessageResponseFromJSON(jsonValue),
		);
	}

	/**
	 * Send a message to a task
	 * Send message
	 */
	async sendMessage(
		requestParameters: V1ApiSendMessageRequest,
		initOverrides?: RequestInit | runtime.InitOverrideFunction,
	): Promise<CreateMessageResponse> {
		const response = await this.sendMessageRaw(
			requestParameters,
			initOverrides,
		);
		return await response.value();
	}

	/**
	 * Start the OAuth flow for user credential brokering
	 * Start credential brokering
	 */
	async startUserCredentialBrokeringRaw(
		requestParameters: V1ApiStartUserCredentialBrokeringRequest,
		initOverrides?: RequestInit | runtime.InitOverrideFunction,
	): Promise<runtime.ApiResponse<UserCredentialBrokeringResponse>> {
		if (requestParameters.providerControllerTypeId == null) {
			throw new runtime.RequiredError(
				"providerControllerTypeId",
				'Required parameter "providerControllerTypeId" was null or undefined when calling startUserCredentialBrokering().',
			);
		}

		if (requestParameters.credentialControllerTypeId == null) {
			throw new runtime.RequiredError(
				"credentialControllerTypeId",
				'Required parameter "credentialControllerTypeId" was null or undefined when calling startUserCredentialBrokering().',
			);
		}

		if (requestParameters.startUserCredentialBrokeringParamsInner == null) {
			throw new runtime.RequiredError(
				"startUserCredentialBrokeringParamsInner",
				'Required parameter "startUserCredentialBrokeringParamsInner" was null or undefined when calling startUserCredentialBrokering().',
			);
		}

		const queryParameters: any = {};

		const headerParameters: runtime.HTTPHeaders = {};

		headerParameters["Content-Type"] = "application/json";

		let urlPath = `/api/bridge/v1/available-providers/{provider_controller_type_id}/available-credentials/{credential_controller_type_id}/credential/user-credential/broker`;
		urlPath = urlPath.replace(
			`{${"provider_controller_type_id"}}`,
			encodeURIComponent(String(requestParameters.providerControllerTypeId)),
		);
		urlPath = urlPath.replace(
			`{${"credential_controller_type_id"}}`,
			encodeURIComponent(String(requestParameters.credentialControllerTypeId)),
		);

		const response = await this.request(
			{
				path: urlPath,
				method: "POST",
				headers: headerParameters,
				query: queryParameters,
				body: StartUserCredentialBrokeringParamsInnerToJSON(
					requestParameters.startUserCredentialBrokeringParamsInner,
				),
			},
			initOverrides,
		);

		return new runtime.JSONApiResponse(response, (jsonValue) =>
			UserCredentialBrokeringResponseFromJSON(jsonValue),
		);
	}

	/**
	 * Start the OAuth flow for user credential brokering
	 * Start credential brokering
	 */
	async startUserCredentialBrokering(
		requestParameters: V1ApiStartUserCredentialBrokeringRequest,
		initOverrides?: RequestInit | runtime.InitOverrideFunction,
	): Promise<UserCredentialBrokeringResponse> {
		const response = await this.startUserCredentialBrokeringRaw(
			requestParameters,
			initOverrides,
		);
		return await response.value();
	}

	/**
	 * Get the timeline history of a task with pagination
	 * Get task timeline
	 */
	async taskHistoryRaw(
		requestParameters: V1ApiTaskHistoryRequest,
		initOverrides?: RequestInit | runtime.InitOverrideFunction,
	): Promise<runtime.ApiResponse<TaskTimelineItemPaginatedResponse>> {
		if (requestParameters.pageSize == null) {
			throw new runtime.RequiredError(
				"pageSize",
				'Required parameter "pageSize" was null or undefined when calling taskHistory().',
			);
		}

		if (requestParameters.taskId == null) {
			throw new runtime.RequiredError(
				"taskId",
				'Required parameter "taskId" was null or undefined when calling taskHistory().',
			);
		}

		const queryParameters: any = {};

		if (requestParameters.pageSize != null) {
			queryParameters.page_size = requestParameters.pageSize;
		}

		if (requestParameters.nextPageToken != null) {
			queryParameters.next_page_token = requestParameters.nextPageToken;
		}

		const headerParameters: runtime.HTTPHeaders = {};

		let urlPath = `/api/task/v1/{task_id}/timeline`;
		urlPath = urlPath.replace(
			`{${"task_id"}}`,
			encodeURIComponent(String(requestParameters.taskId)),
		);

		const response = await this.request(
			{
				path: urlPath,
				method: "GET",
				headers: headerParameters,
				query: queryParameters,
			},
			initOverrides,
		);

		return new runtime.JSONApiResponse(response, (jsonValue) =>
			TaskTimelineItemPaginatedResponseFromJSON(jsonValue),
		);
	}

	/**
	 * Get the timeline history of a task with pagination
	 * Get task timeline
	 */
	async taskHistory(
		requestParameters: V1ApiTaskHistoryRequest,
		initOverrides?: RequestInit | runtime.InitOverrideFunction,
	): Promise<TaskTimelineItemPaginatedResponse> {
		const response = await this.taskHistoryRaw(
			requestParameters,
			initOverrides,
		);
		return await response.value();
	}

	/**
	 * Trigger code generation for the SDK
	 * Trigger codegen
	 */
	async triggerCodegenRaw(
		initOverrides?: RequestInit | runtime.InitOverrideFunction,
	): Promise<runtime.ApiResponse<TriggerCodegenResponse>> {
		const queryParameters: any = {};

		const headerParameters: runtime.HTTPHeaders = {};

		const urlPath = `/_internal/v1/trigger_codegen`;

		const response = await this.request(
			{
				path: urlPath,
				method: "POST",
				headers: headerParameters,
				query: queryParameters,
			},
			initOverrides,
		);

		return new runtime.JSONApiResponse(response, (jsonValue) =>
			TriggerCodegenResponseFromJSON(jsonValue),
		);
	}

	/**
	 * Trigger code generation for the SDK
	 * Trigger codegen
	 */
	async triggerCodegen(
		initOverrides?: RequestInit | runtime.InitOverrideFunction,
	): Promise<TriggerCodegenResponse> {
		const response = await this.triggerCodegenRaw(initOverrides);
		return await response.value();
	}

	/**
	 * Send a JSON-RPC message to the MCP server
	 * Send MCP message
	 */
	async triggerMcpMessageRaw(
		requestParameters: V1ApiTriggerMcpMessageRequest,
		initOverrides?: RequestInit | runtime.InitOverrideFunction,
	): Promise<runtime.ApiResponse<void>> {
		if (requestParameters.body == null) {
			throw new runtime.RequiredError(
				"body",
				'Required parameter "body" was null or undefined when calling triggerMcpMessage().',
			);
		}

		const queryParameters: any = {};

		const headerParameters: runtime.HTTPHeaders = {};

		headerParameters["Content-Type"] = "application/json";

		const urlPath = `/api/bridge/v1/mcp`;

		const response = await this.request(
			{
				path: urlPath,
				method: "POST",
				headers: headerParameters,
				query: queryParameters,
				body: requestParameters.body as any,
			},
			initOverrides,
		);

		return new runtime.VoidApiResponse(response);
	}

	/**
	 * Send a JSON-RPC message to the MCP server
	 * Send MCP message
	 */
	async triggerMcpMessage(
		requestParameters: V1ApiTriggerMcpMessageRequest,
		initOverrides?: RequestInit | runtime.InitOverrideFunction,
	): Promise<void> {
		await this.triggerMcpMessageRaw(requestParameters, initOverrides);
	}

	/**
	 * Update the alias for a data encryption key
	 * Update DEK alias
	 */
	async updateDekAliasRaw(
		requestParameters: V1ApiUpdateDekAliasRequest,
		initOverrides?: RequestInit | runtime.InitOverrideFunction,
	): Promise<runtime.ApiResponse<DataEncryptionKeyAlias>> {
		if (requestParameters.alias == null) {
			throw new runtime.RequiredError(
				"alias",
				'Required parameter "alias" was null or undefined when calling updateDekAlias().',
			);
		}

		if (requestParameters.updateAliasParams == null) {
			throw new runtime.RequiredError(
				"updateAliasParams",
				'Required parameter "updateAliasParams" was null or undefined when calling updateDekAlias().',
			);
		}

		const queryParameters: any = {};

		const headerParameters: runtime.HTTPHeaders = {};

		headerParameters["Content-Type"] = "application/json";

		let urlPath = `/api/encryption/v1/dek/alias/{alias}`;
		urlPath = urlPath.replace(
			`{${"alias"}}`,
			encodeURIComponent(String(requestParameters.alias)),
		);

		const response = await this.request(
			{
				path: urlPath,
				method: "PUT",
				headers: headerParameters,
				query: queryParameters,
				body: UpdateAliasParamsToJSON(requestParameters.updateAliasParams),
			},
			initOverrides,
		);

		return new runtime.JSONApiResponse(response, (jsonValue) =>
			DataEncryptionKeyAliasFromJSON(jsonValue),
		);
	}

	/**
	 * Update the alias for a data encryption key
	 * Update DEK alias
	 */
	async updateDekAlias(
		requestParameters: V1ApiUpdateDekAliasRequest,
		initOverrides?: RequestInit | runtime.InitOverrideFunction,
	): Promise<DataEncryptionKeyAlias> {
		const response = await this.updateDekAliasRaw(
			requestParameters,
			initOverrides,
		);
		return await response.value();
	}

	/**
	 * Update an existing provider instance configuration
	 * Update provider
	 */
	async updateProviderInstanceRaw(
		requestParameters: V1ApiUpdateProviderInstanceRequest,
		initOverrides?: RequestInit | runtime.InitOverrideFunction,
	): Promise<runtime.ApiResponse<any>> {
		if (requestParameters.providerInstanceId == null) {
			throw new runtime.RequiredError(
				"providerInstanceId",
				'Required parameter "providerInstanceId" was null or undefined when calling updateProviderInstance().',
			);
		}

		if (requestParameters.updateProviderInstanceParamsInner == null) {
			throw new runtime.RequiredError(
				"updateProviderInstanceParamsInner",
				'Required parameter "updateProviderInstanceParamsInner" was null or undefined when calling updateProviderInstance().',
			);
		}

		const queryParameters: any = {};

		const headerParameters: runtime.HTTPHeaders = {};

		headerParameters["Content-Type"] = "application/json";

		let urlPath = `/api/bridge/v1/provider/{provider_instance_id}`;
		urlPath = urlPath.replace(
			`{${"provider_instance_id"}}`,
			encodeURIComponent(String(requestParameters.providerInstanceId)),
		);

		const response = await this.request(
			{
				path: urlPath,
				method: "PATCH",
				headers: headerParameters,
				query: queryParameters,
				body: UpdateProviderInstanceParamsInnerToJSON(
					requestParameters.updateProviderInstanceParamsInner,
				),
			},
			initOverrides,
		);

		if (this.isJsonMime(response.headers.get("content-type"))) {
			return new runtime.JSONApiResponse<any>(response);
		} else {
			return new runtime.TextApiResponse(response) as any;
		}
	}

	/**
	 * Update an existing provider instance configuration
	 * Update provider
	 */
	async updateProviderInstance(
		requestParameters: V1ApiUpdateProviderInstanceRequest,
		initOverrides?: RequestInit | runtime.InitOverrideFunction,
	): Promise<any> {
		const response = await this.updateProviderInstanceRaw(
			requestParameters,
			initOverrides,
		);
		return await response.value();
	}

	/**
	 * Update an existing secret\'s value or metadata
	 * Update secret
	 */
	async updateSecretRaw(
		requestParameters: V1ApiUpdateSecretOperationRequest,
		initOverrides?: RequestInit | runtime.InitOverrideFunction,
	): Promise<runtime.ApiResponse<Secret>> {
		if (requestParameters.secretId == null) {
			throw new runtime.RequiredError(
				"secretId",
				'Required parameter "secretId" was null or undefined when calling updateSecret().',
			);
		}

		if (requestParameters.updateSecretRequest == null) {
			throw new runtime.RequiredError(
				"updateSecretRequest",
				'Required parameter "updateSecretRequest" was null or undefined when calling updateSecret().',
			);
		}

		const queryParameters: any = {};

		const headerParameters: runtime.HTTPHeaders = {};

		headerParameters["Content-Type"] = "application/json";

		let urlPath = `/api/secret/v1/{secret_id}`;
		urlPath = urlPath.replace(
			`{${"secret_id"}}`,
			encodeURIComponent(String(requestParameters.secretId)),
		);

		const response = await this.request(
			{
				path: urlPath,
				method: "PUT",
				headers: headerParameters,
				query: queryParameters,
				body: UpdateSecretRequestToJSON(requestParameters.updateSecretRequest),
			},
			initOverrides,
		);

		return new runtime.JSONApiResponse(response, (jsonValue) =>
			SecretFromJSON(jsonValue),
		);
	}

	/**
	 * Update an existing secret\'s value or metadata
	 * Update secret
	 */
	async updateSecret(
		requestParameters: V1ApiUpdateSecretOperationRequest,
		initOverrides?: RequestInit | runtime.InitOverrideFunction,
	): Promise<Secret> {
		const response = await this.updateSecretRaw(
			requestParameters,
			initOverrides,
		);
		return await response.value();
	}

	/**
	 * Update the status of a task
	 * Update task status
	 */
	async updateTaskStatusRaw(
		requestParameters: V1ApiUpdateTaskStatusOperationRequest,
		initOverrides?: RequestInit | runtime.InitOverrideFunction,
	): Promise<runtime.ApiResponse<any>> {
		if (requestParameters.taskId == null) {
			throw new runtime.RequiredError(
				"taskId",
				'Required parameter "taskId" was null or undefined when calling updateTaskStatus().',
			);
		}

		if (requestParameters.updateTaskStatusRequest == null) {
			throw new runtime.RequiredError(
				"updateTaskStatusRequest",
				'Required parameter "updateTaskStatusRequest" was null or undefined when calling updateTaskStatus().',
			);
		}

		const queryParameters: any = {};

		const headerParameters: runtime.HTTPHeaders = {};

		headerParameters["Content-Type"] = "application/json";

		let urlPath = `/api/task/v1/{task_id}`;
		urlPath = urlPath.replace(
			`{${"task_id"}}`,
			encodeURIComponent(String(requestParameters.taskId)),
		);

		const response = await this.request(
			{
				path: urlPath,
				method: "PUT",
				headers: headerParameters,
				query: queryParameters,
				body: UpdateTaskStatusRequestToJSON(
					requestParameters.updateTaskStatusRequest,
				),
			},
			initOverrides,
		);

		if (this.isJsonMime(response.headers.get("content-type"))) {
			return new runtime.JSONApiResponse<any>(response);
		} else {
			return new runtime.TextApiResponse(response) as any;
		}
	}

	/**
	 * Update the status of a task
	 * Update task status
	 */
	async updateTaskStatus(
		requestParameters: V1ApiUpdateTaskStatusOperationRequest,
		initOverrides?: RequestInit | runtime.InitOverrideFunction,
	): Promise<any> {
		const response = await this.updateTaskStatusRaw(
			requestParameters,
			initOverrides,
		);
		return await response.value();
	}
}
