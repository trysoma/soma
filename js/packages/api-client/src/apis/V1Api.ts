/* tslint:disable */
/* eslint-disable */
/**
 * soma
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: v1
 *
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

import type {
	AddMcpServerInstanceFunctionRequest,
	ContextInfoPaginatedResponse,
	CreateApiKeyParams,
	CreateApiKeyResponse,
	CreateDataEncryptionKeyParamsRoute,
	CreateDekAliasRequest,
	CreateEnvironmentVariableRequest,
	CreateMcpServerInstanceRequest,
	CreateMessageRequest,
	CreateMessageResponse,
	CreateProviderInstanceParamsInner,
	CreateResourceServerCredentialParamsInner,
	CreateSecretRequest,
	CreateUserAuthFlowConfigParams,
	CreateUserAuthFlowConfigResponse,
	CreateUserCredentialParamsInner,
	DataEncryptionKey,
	DataEncryptionKeyAlias,
	DataEncryptionKeyListItemPaginatedResponse,
	DeleteEnvironmentVariableResponse,
	DeleteSecretResponse,
	EncryptCredentialConfigurationParamsInner,
	EncryptedApiKeyConfig,
	EnvelopeEncryptionKey,
	EnvelopeEncryptionKeyPaginatedResponse,
	EnvironmentVariable,
	FunctionInstanceConfigPaginatedResponse,
	FunctionInstanceSerialized,
	FunctionInstanceSerializedPaginatedResponse,
	GetUserAuthFlowConfigResponse,
	Identity,
	ImportDataEncryptionKeyParamsRoute,
	ImportEnvironmentVariableRequest,
	ImportSecretRequest,
	ImportUserAuthFlowConfigParams,
	InvokeFunctionParamsInner,
	InvokeResult,
	JwkResponsePaginatedResponse,
	JwksResponse,
	ListAgentsResponse,
	ListApiKeysResponse,
	ListDecryptedSecretsResponse,
	ListEnvironmentVariablesResponse,
	ListSecretsResponse,
	ListUserAuthFlowConfigResponse,
	McpServerInstanceSerializedWithFunctions,
	McpServerInstanceSerializedWithFunctionsPaginatedResponse,
	MigrateAllDataEncryptionKeysParamsRoute,
	MigrateDataEncryptionKeyParamsRoute,
	NormalizedTokenIssuanceResult,
	ProviderControllerSerializedPaginatedResponse,
	ProviderInstanceListItemPaginatedResponse,
	ProviderInstanceSerialized,
	ProviderInstanceSerializedWithEverything,
	RefreshTokenRequest,
	ResourceServerCredentialSerialized,
	Secret,
	StartUserCredentialBrokeringParamsInner,
	StsTokenConfig,
	StsTokenConfigPaginatedResponse,
	TaskPaginatedResponse,
	TaskTimelineItemPaginatedResponse,
	TaskWithDetails,
	TokenResponse,
	UpdateAliasParams,
	UpdateEnvironmentVariableRequest,
	UpdateMcpServerInstanceFunctionRequest,
	UpdateMcpServerInstanceRequest,
	UpdateProviderInstanceParamsInner,
	UpdateSecretRequest,
	UpdateTaskStatusRequest,
	UserCredentialBrokeringResponse,
	UserCredentialSerialized,
} from "../models/index";
import {
	AddMcpServerInstanceFunctionRequestToJSON,
	ContextInfoPaginatedResponseFromJSON,
	CreateApiKeyParamsToJSON,
	CreateApiKeyResponseFromJSON,
	CreateDataEncryptionKeyParamsRouteToJSON,
	CreateDekAliasRequestToJSON,
	CreateEnvironmentVariableRequestToJSON,
	CreateMcpServerInstanceRequestToJSON,
	CreateMessageRequestToJSON,
	CreateMessageResponseFromJSON,
	CreateProviderInstanceParamsInnerToJSON,
	CreateResourceServerCredentialParamsInnerToJSON,
	CreateSecretRequestToJSON,
	CreateUserAuthFlowConfigParamsToJSON,
	CreateUserAuthFlowConfigResponseFromJSON,
	CreateUserCredentialParamsInnerToJSON,
	DataEncryptionKeyAliasFromJSON,
	DataEncryptionKeyFromJSON,
	DataEncryptionKeyListItemPaginatedResponseFromJSON,
	DeleteEnvironmentVariableResponseFromJSON,
	DeleteSecretResponseFromJSON,
	EncryptCredentialConfigurationParamsInnerToJSON,
	EncryptedApiKeyConfigToJSON,
	EnvelopeEncryptionKeyFromJSON,
	EnvelopeEncryptionKeyPaginatedResponseFromJSON,
	EnvelopeEncryptionKeyToJSON,
	EnvironmentVariableFromJSON,
	FunctionInstanceConfigPaginatedResponseFromJSON,
	FunctionInstanceSerializedFromJSON,
	FunctionInstanceSerializedPaginatedResponseFromJSON,
	GetUserAuthFlowConfigResponseFromJSON,
	IdentityFromJSON,
	ImportDataEncryptionKeyParamsRouteToJSON,
	ImportEnvironmentVariableRequestToJSON,
	ImportSecretRequestToJSON,
	ImportUserAuthFlowConfigParamsToJSON,
	InvokeFunctionParamsInnerToJSON,
	InvokeResultFromJSON,
	JwkResponsePaginatedResponseFromJSON,
	JwksResponseFromJSON,
	ListAgentsResponseFromJSON,
	ListApiKeysResponseFromJSON,
	ListDecryptedSecretsResponseFromJSON,
	ListEnvironmentVariablesResponseFromJSON,
	ListSecretsResponseFromJSON,
	ListUserAuthFlowConfigResponseFromJSON,
	McpServerInstanceSerializedWithFunctionsFromJSON,
	McpServerInstanceSerializedWithFunctionsPaginatedResponseFromJSON,
	MigrateAllDataEncryptionKeysParamsRouteToJSON,
	MigrateDataEncryptionKeyParamsRouteToJSON,
	NormalizedTokenIssuanceResultFromJSON,
	ProviderControllerSerializedPaginatedResponseFromJSON,
	ProviderInstanceListItemPaginatedResponseFromJSON,
	ProviderInstanceSerializedFromJSON,
	ProviderInstanceSerializedWithEverythingFromJSON,
	RefreshTokenRequestToJSON,
	ResourceServerCredentialSerializedFromJSON,
	SecretFromJSON,
	StartUserCredentialBrokeringParamsInnerToJSON,
	StsTokenConfigFromJSON,
	StsTokenConfigPaginatedResponseFromJSON,
	StsTokenConfigToJSON,
	TaskPaginatedResponseFromJSON,
	TaskTimelineItemPaginatedResponseFromJSON,
	TaskWithDetailsFromJSON,
	TokenResponseFromJSON,
	UpdateAliasParamsToJSON,
	UpdateEnvironmentVariableRequestToJSON,
	UpdateMcpServerInstanceFunctionRequestToJSON,
	UpdateMcpServerInstanceRequestToJSON,
	UpdateProviderInstanceParamsInnerToJSON,
	UpdateSecretRequestToJSON,
	UpdateTaskStatusRequestToJSON,
	UserCredentialBrokeringResponseFromJSON,
	UserCredentialSerializedFromJSON,
} from "../models/index";
import * as runtime from "../runtime";

export interface V1ApiAddMcpServerInstanceFunctionOperationRequest {
	mcpServerInstanceId: string;
	addMcpServerInstanceFunctionRequest: AddMcpServerInstanceFunctionRequest;
}

export interface V1ApiCreateDataEncryptionKeyRequest {
	envelopeId: string;
	createDataEncryptionKeyParamsRoute: CreateDataEncryptionKeyParamsRoute;
}

export interface V1ApiCreateDekAliasOperationRequest {
	createDekAliasRequest: CreateDekAliasRequest;
}

export interface V1ApiCreateEnvelopeEncryptionKeyRequest {
	envelopeEncryptionKey: EnvelopeEncryptionKey;
}

export interface V1ApiCreateEnvironmentVariableOperationRequest {
	createEnvironmentVariableRequest: CreateEnvironmentVariableRequest;
}

export interface V1ApiCreateMcpServerInstanceOperationRequest {
	createMcpServerInstanceRequest: CreateMcpServerInstanceRequest;
}

export interface V1ApiCreateProviderInstanceRequest {
	providerControllerTypeId: string;
	credentialControllerTypeId: string;
	createProviderInstanceParamsInner: CreateProviderInstanceParamsInner;
}

export interface V1ApiCreateResourceServerCredentialRequest {
	providerControllerTypeId: string;
	credentialControllerTypeId: string;
	createResourceServerCredentialParamsInner: CreateResourceServerCredentialParamsInner;
}

export interface V1ApiCreateSecretOperationRequest {
	createSecretRequest: CreateSecretRequest;
}

export interface V1ApiCreateUserCredentialRequest {
	providerControllerTypeId: string;
	credentialControllerTypeId: string;
	createUserCredentialParamsInner: CreateUserCredentialParamsInner;
}

export interface V1ApiDeleteDekAliasRequest {
	alias: string;
}

export interface V1ApiDeleteEnvironmentVariableRequest {
	envVarId: string;
}

export interface V1ApiDeleteMcpServerInstanceRequest {
	mcpServerInstanceId: string;
}

export interface V1ApiDeleteProviderInstanceRequest {
	providerInstanceId: string;
}

export interface V1ApiDeleteSecretRequest {
	secretId: string;
}

export interface V1ApiDisableFunctionRequest {
	providerInstanceId: string;
	functionControllerTypeId: string;
}

export interface V1ApiEnableFunctionRequest {
	providerInstanceId: string;
	functionControllerTypeId: string;
	body: object;
}

export interface V1ApiEncryptResourceServerConfigurationRequest {
	providerControllerTypeId: string;
	credentialControllerTypeId: string;
	encryptCredentialConfigurationParamsInner: EncryptCredentialConfigurationParamsInner;
}

export interface V1ApiEncryptUserCredentialConfigurationRequest {
	providerControllerTypeId: string;
	credentialControllerTypeId: string;
	encryptCredentialConfigurationParamsInner: EncryptCredentialConfigurationParamsInner;
}

export interface V1ApiGetAgentCardRequest {
	projectId: string;
	agentId: string;
}

export interface V1ApiGetDekByAliasOrIdRequest {
	alias: string;
}

export interface V1ApiGetEnvironmentVariableByIdRequest {
	envVarId: string;
}

export interface V1ApiGetEnvironmentVariableByKeyRequest {
	key: string;
}

export interface V1ApiGetMcpServerInstanceRequest {
	mcpServerInstanceId: string;
}

export interface V1ApiGetProviderInstanceRequest {
	providerInstanceId: string;
}

export interface V1ApiGetSecretByIdRequest {
	secretId: string;
}

export interface V1ApiGetSecretByKeyRequest {
	key: string;
}

export interface V1ApiGetTaskByIdRequest {
	taskId: string;
}

export interface V1ApiHandleA2aJsonrpcRequestRequest {
	projectId: string;
	agentId: string;
	body: object;
}

export interface V1ApiImportDataEncryptionKeyRequest {
	envelopeId: string;
	importDataEncryptionKeyParamsRoute: ImportDataEncryptionKeyParamsRoute;
}

export interface V1ApiImportEnvironmentVariableOperationRequest {
	importEnvironmentVariableRequest: ImportEnvironmentVariableRequest;
}

export interface V1ApiImportSecretOperationRequest {
	importSecretRequest: ImportSecretRequest;
}

export interface V1ApiInvokeFunctionRequest {
	providerInstanceId: string;
	functionControllerTypeId: string;
	invokeFunctionParamsInner: InvokeFunctionParamsInner;
}

export interface V1ApiListAvailableProvidersRequest {
	pageSize: number;
	nextPageToken?: string;
}

export interface V1ApiListContextsRequest {
	pageSize: number;
	nextPageToken?: string;
}

export interface V1ApiListDataEncryptionKeysByEnvelopeRequest {
	envelopeId: string;
	pageSize: number;
	nextPageToken?: string;
}

export interface V1ApiListDecryptedSecretsRequest {
	pageSize: number;
	nextPageToken?: string;
}

export interface V1ApiListEnvelopeEncryptionKeysRequest {
	pageSize: number;
	nextPageToken?: string;
}

export interface V1ApiListEnvironmentVariablesRequest {
	pageSize: number;
	nextPageToken?: string;
}

export interface V1ApiListFunctionInstancesRequest {
	pageSize: number;
	nextPageToken?: string;
	providerInstanceId?: string;
}

export interface V1ApiListMcpServerInstancesRequest {
	pageSize: number;
	nextPageToken?: string;
}

export interface V1ApiListProviderInstancesRequest {
	pageSize: number;
	nextPageToken?: string;
	status?: string;
	providerControllerTypeId?: string;
}

export interface V1ApiListProviderInstancesGroupedByFunctionRequest {
	pageSize: number;
	nextPageToken?: string | null;
	providerControllerTypeId?: string | null;
	functionCategory?: string | null;
}

export interface V1ApiListSecretsRequest {
	pageSize: number;
	nextPageToken?: string;
}

export interface V1ApiListTasksRequest {
	pageSize: number;
	nextPageToken?: string;
}

export interface V1ApiListTasksByContextIdRequest {
	pageSize: number;
	contextId: string;
	nextPageToken?: string;
}

export interface V1ApiMigrateAllDataEncryptionKeysRequest {
	envelopeId: string;
	migrateAllDataEncryptionKeysParamsRoute: MigrateAllDataEncryptionKeysParamsRoute;
}

export interface V1ApiMigrateDataEncryptionKeyRequest {
	envelopeId: string;
	dekId: string;
	migrateDataEncryptionKeyParamsRoute: MigrateDataEncryptionKeyParamsRoute;
}

export interface V1ApiRemoveMcpServerInstanceFunctionRequest {
	mcpServerInstanceId: string;
	functionControllerTypeId: string;
	providerControllerTypeId: string;
	providerInstanceId: string;
}

export interface V1ApiResumeUserCredentialBrokeringRequest {
	state?: string;
	code?: string;
	error?: string;
	errorDescription?: string;
}

export interface V1ApiRouteAuthCallbackRequest {
	code?: string | null;
	state?: string | null;
	error?: string | null;
	errorDescription?: string | null;
}

export interface V1ApiRouteCreateApiKeyRequest {
	createApiKeyParams: CreateApiKeyParams;
}

export interface V1ApiRouteCreateStsConfigRequest {
	stsTokenConfig: StsTokenConfig;
}

export interface V1ApiRouteCreateUserAuthFlowConfigRequest {
	createUserAuthFlowConfigParams: CreateUserAuthFlowConfigParams;
}

export interface V1ApiRouteDeleteApiKeyRequest {
	id: string;
}

export interface V1ApiRouteDeleteStsConfigRequest {
	id: string;
}

export interface V1ApiRouteDeleteUserAuthFlowConfigRequest {
	id: string;
}

export interface V1ApiRouteExchangeStsTokenRequest {
	stsConfigId: string;
}

export interface V1ApiRouteGetStsConfigRequest {
	id: string;
}

export interface V1ApiRouteGetUserAuthFlowConfigRequest {
	id: string;
}

export interface V1ApiRouteImportApiKeyRequest {
	encryptedApiKeyConfig: EncryptedApiKeyConfig;
}

export interface V1ApiRouteImportUserAuthFlowConfigRequest {
	importUserAuthFlowConfigParams: ImportUserAuthFlowConfigParams;
}

export interface V1ApiRouteInvalidateJwkRequest {
	kid: string;
}

export interface V1ApiRouteListApiKeysRequest {
	pageSize: number;
	nextPageToken?: string;
}

export interface V1ApiRouteListJwksRequest {
	pageSize: number;
	nextPageToken?: string;
}

export interface V1ApiRouteListStsConfigsRequest {
	pageSize: number;
	nextPageToken?: string;
}

export interface V1ApiRouteListUserAuthFlowConfigsRequest {
	pageSize?: number | null;
	nextPageToken?: string | null;
	type?: string | null;
}

export interface V1ApiRouteRefreshTokenRequest {
	refreshTokenRequest?: RefreshTokenRequest;
}

export interface V1ApiRouteStartAuthorizationRequest {
	configId: string;
	redirectAfterLogin?: string | null;
}

export interface V1ApiSendMessageRequest {
	taskId: string;
	createMessageRequest: CreateMessageRequest;
}

export interface V1ApiStartUserCredentialBrokeringRequest {
	providerControllerTypeId: string;
	credentialControllerTypeId: string;
	startUserCredentialBrokeringParamsInner: StartUserCredentialBrokeringParamsInner;
}

export interface V1ApiTaskHistoryRequest {
	pageSize: number;
	taskId: string;
	nextPageToken?: string;
}

export interface V1ApiUpdateDekAliasRequest {
	alias: string;
	updateAliasParams: UpdateAliasParams;
}

export interface V1ApiUpdateEnvironmentVariableOperationRequest {
	envVarId: string;
	updateEnvironmentVariableRequest: UpdateEnvironmentVariableRequest;
}

export interface V1ApiUpdateMcpServerInstanceOperationRequest {
	mcpServerInstanceId: string;
	updateMcpServerInstanceRequest: UpdateMcpServerInstanceRequest;
}

export interface V1ApiUpdateMcpServerInstanceFunctionOperationRequest {
	mcpServerInstanceId: string;
	functionControllerTypeId: string;
	providerControllerTypeId: string;
	providerInstanceId: string;
	updateMcpServerInstanceFunctionRequest: UpdateMcpServerInstanceFunctionRequest;
}

export interface V1ApiUpdateProviderInstanceRequest {
	providerInstanceId: string;
	updateProviderInstanceParamsInner: UpdateProviderInstanceParamsInner;
}

export interface V1ApiUpdateSecretOperationRequest {
	secretId: string;
	updateSecretRequest: UpdateSecretRequest;
}

export interface V1ApiUpdateTaskStatusOperationRequest {
	taskId: string;
	updateTaskStatusRequest: UpdateTaskStatusRequest;
}

/**
 *
 */
export class V1Api extends runtime.BaseAPI {
	/**
	 * Add a function mapping to an MCP server instance with a custom name
	 * Add function to MCP server instance
	 */
	async addMcpServerInstanceFunctionRaw(
		requestParameters: V1ApiAddMcpServerInstanceFunctionOperationRequest,
		initOverrides?: RequestInit | runtime.InitOverrideFunction,
	): Promise<runtime.ApiResponse<McpServerInstanceSerializedWithFunctions>> {
		if (requestParameters.mcpServerInstanceId == null) {
			throw new runtime.RequiredError(
				"mcpServerInstanceId",
				'Required parameter "mcpServerInstanceId" was null or undefined when calling addMcpServerInstanceFunction().',
			);
		}

		if (requestParameters.addMcpServerInstanceFunctionRequest == null) {
			throw new runtime.RequiredError(
				"addMcpServerInstanceFunctionRequest",
				'Required parameter "addMcpServerInstanceFunctionRequest" was null or undefined when calling addMcpServerInstanceFunction().',
			);
		}

		const queryParameters: any = {};

		const headerParameters: runtime.HTTPHeaders = {};

		headerParameters["Content-Type"] = "application/json";

		let urlPath = `/api/bridge/v1/mcp-instance/{mcp_server_instance_id}/function`;
		urlPath = urlPath.replace(
			`{${"mcp_server_instance_id"}}`,
			encodeURIComponent(String(requestParameters.mcpServerInstanceId)),
		);

		const response = await this.request(
			{
				path: urlPath,
				method: "POST",
				headers: headerParameters,
				query: queryParameters,
				body: AddMcpServerInstanceFunctionRequestToJSON(
					requestParameters.addMcpServerInstanceFunctionRequest,
				),
			},
			initOverrides,
		);

		return new runtime.JSONApiResponse(response, (jsonValue) =>
			McpServerInstanceSerializedWithFunctionsFromJSON(jsonValue),
		);
	}

	/**
	 * Add a function mapping to an MCP server instance with a custom name
	 * Add function to MCP server instance
	 */
	async addMcpServerInstanceFunction(
		requestParameters: V1ApiAddMcpServerInstanceFunctionOperationRequest,
		initOverrides?: RequestInit | runtime.InitOverrideFunction,
	): Promise<McpServerInstanceSerializedWithFunctions> {
		const response = await this.addMcpServerInstanceFunctionRaw(
			requestParameters,
			initOverrides,
		);
		return await response.value();
	}

	/**
	 * Create a new data encryption key (DEK) encrypted with the specified envelope encryption key
	 * Create data key
	 */
	async createDataEncryptionKeyRaw(
		requestParameters: V1ApiCreateDataEncryptionKeyRequest,
		initOverrides?: RequestInit | runtime.InitOverrideFunction,
	): Promise<runtime.ApiResponse<DataEncryptionKey>> {
		if (requestParameters.envelopeId == null) {
			throw new runtime.RequiredError(
				"envelopeId",
				'Required parameter "envelopeId" was null or undefined when calling createDataEncryptionKey().',
			);
		}

		if (requestParameters.createDataEncryptionKeyParamsRoute == null) {
			throw new runtime.RequiredError(
				"createDataEncryptionKeyParamsRoute",
				'Required parameter "createDataEncryptionKeyParamsRoute" was null or undefined when calling createDataEncryptionKey().',
			);
		}

		const queryParameters: any = {};

		const headerParameters: runtime.HTTPHeaders = {};

		headerParameters["Content-Type"] = "application/json";

		let urlPath = `/api/encryption/v1/envelope/{envelope_id}/dek`;
		urlPath = urlPath.replace(
			`{${"envelope_id"}}`,
			encodeURIComponent(String(requestParameters.envelopeId)),
		);

		const response = await this.request(
			{
				path: urlPath,
				method: "POST",
				headers: headerParameters,
				query: queryParameters,
				body: CreateDataEncryptionKeyParamsRouteToJSON(
					requestParameters.createDataEncryptionKeyParamsRoute,
				),
			},
			initOverrides,
		);

		return new runtime.JSONApiResponse(response, (jsonValue) =>
			DataEncryptionKeyFromJSON(jsonValue),
		);
	}

	/**
	 * Create a new data encryption key (DEK) encrypted with the specified envelope encryption key
	 * Create data key
	 */
	async createDataEncryptionKey(
		requestParameters: V1ApiCreateDataEncryptionKeyRequest,
		initOverrides?: RequestInit | runtime.InitOverrideFunction,
	): Promise<DataEncryptionKey> {
		const response = await this.createDataEncryptionKeyRaw(
			requestParameters,
			initOverrides,
		);
		return await response.value();
	}

	/**
	 * Create an alias for a data encryption key to enable lookup by friendly name
	 * Create DEK alias
	 */
	async createDekAliasRaw(
		requestParameters: V1ApiCreateDekAliasOperationRequest,
		initOverrides?: RequestInit | runtime.InitOverrideFunction,
	): Promise<runtime.ApiResponse<DataEncryptionKeyAlias>> {
		if (requestParameters.createDekAliasRequest == null) {
			throw new runtime.RequiredError(
				"createDekAliasRequest",
				'Required parameter "createDekAliasRequest" was null or undefined when calling createDekAlias().',
			);
		}

		const queryParameters: any = {};

		const headerParameters: runtime.HTTPHeaders = {};

		headerParameters["Content-Type"] = "application/json";

		const urlPath = `/api/encryption/v1/dek/alias`;

		const response = await this.request(
			{
				path: urlPath,
				method: "POST",
				headers: headerParameters,
				query: queryParameters,
				body: CreateDekAliasRequestToJSON(
					requestParameters.createDekAliasRequest,
				),
			},
			initOverrides,
		);

		return new runtime.JSONApiResponse(response, (jsonValue) =>
			DataEncryptionKeyAliasFromJSON(jsonValue),
		);
	}

	/**
	 * Create an alias for a data encryption key to enable lookup by friendly name
	 * Create DEK alias
	 */
	async createDekAlias(
		requestParameters: V1ApiCreateDekAliasOperationRequest,
		initOverrides?: RequestInit | runtime.InitOverrideFunction,
	): Promise<DataEncryptionKeyAlias> {
		const response = await this.createDekAliasRaw(
			requestParameters,
			initOverrides,
		);
		return await response.value();
	}

	/**
	 * Create a new envelope encryption key (master key) for encrypting data encryption keys
	 * Create envelope key
	 */
	async createEnvelopeEncryptionKeyRaw(
		requestParameters: V1ApiCreateEnvelopeEncryptionKeyRequest,
		initOverrides?: RequestInit | runtime.InitOverrideFunction,
	): Promise<runtime.ApiResponse<EnvelopeEncryptionKey>> {
		if (requestParameters.envelopeEncryptionKey == null) {
			throw new runtime.RequiredError(
				"envelopeEncryptionKey",
				'Required parameter "envelopeEncryptionKey" was null or undefined when calling createEnvelopeEncryptionKey().',
			);
		}

		const queryParameters: any = {};

		const headerParameters: runtime.HTTPHeaders = {};

		headerParameters["Content-Type"] = "application/json";

		const urlPath = `/api/encryption/v1/envelope`;

		const response = await this.request(
			{
				path: urlPath,
				method: "POST",
				headers: headerParameters,
				query: queryParameters,
				body: EnvelopeEncryptionKeyToJSON(
					requestParameters.envelopeEncryptionKey,
				),
			},
			initOverrides,
		);

		return new runtime.JSONApiResponse(response, (jsonValue) =>
			EnvelopeEncryptionKeyFromJSON(jsonValue),
		);
	}

	/**
	 * Create a new envelope encryption key (master key) for encrypting data encryption keys
	 * Create envelope key
	 */
	async createEnvelopeEncryptionKey(
		requestParameters: V1ApiCreateEnvelopeEncryptionKeyRequest,
		initOverrides?: RequestInit | runtime.InitOverrideFunction,
	): Promise<EnvelopeEncryptionKey> {
		const response = await this.createEnvelopeEncryptionKeyRaw(
			requestParameters,
			initOverrides,
		);
		return await response.value();
	}

	/**
	 * Create a new environment variable with the specified key and value
	 * Create environment variable
	 */
	async createEnvironmentVariableRaw(
		requestParameters: V1ApiCreateEnvironmentVariableOperationRequest,
		initOverrides?: RequestInit | runtime.InitOverrideFunction,
	): Promise<runtime.ApiResponse<EnvironmentVariable>> {
		if (requestParameters.createEnvironmentVariableRequest == null) {
			throw new runtime.RequiredError(
				"createEnvironmentVariableRequest",
				'Required parameter "createEnvironmentVariableRequest" was null or undefined when calling createEnvironmentVariable().',
			);
		}

		const queryParameters: any = {};

		const headerParameters: runtime.HTTPHeaders = {};

		headerParameters["Content-Type"] = "application/json";

		const urlPath = `/api/environment-variable/v1`;

		const response = await this.request(
			{
				path: urlPath,
				method: "POST",
				headers: headerParameters,
				query: queryParameters,
				body: CreateEnvironmentVariableRequestToJSON(
					requestParameters.createEnvironmentVariableRequest,
				),
			},
			initOverrides,
		);

		return new runtime.JSONApiResponse(response, (jsonValue) =>
			EnvironmentVariableFromJSON(jsonValue),
		);
	}

	/**
	 * Create a new environment variable with the specified key and value
	 * Create environment variable
	 */
	async createEnvironmentVariable(
		requestParameters: V1ApiCreateEnvironmentVariableOperationRequest,
		initOverrides?: RequestInit | runtime.InitOverrideFunction,
	): Promise<EnvironmentVariable> {
		const response = await this.createEnvironmentVariableRaw(
			requestParameters,
			initOverrides,
		);
		return await response.value();
	}

	/**
	 * Create a new MCP server instance with a user-provided ID
	 * Create MCP server instance
	 */
	async createMcpServerInstanceRaw(
		requestParameters: V1ApiCreateMcpServerInstanceOperationRequest,
		initOverrides?: RequestInit | runtime.InitOverrideFunction,
	): Promise<runtime.ApiResponse<McpServerInstanceSerializedWithFunctions>> {
		if (requestParameters.createMcpServerInstanceRequest == null) {
			throw new runtime.RequiredError(
				"createMcpServerInstanceRequest",
				'Required parameter "createMcpServerInstanceRequest" was null or undefined when calling createMcpServerInstance().',
			);
		}

		const queryParameters: any = {};

		const headerParameters: runtime.HTTPHeaders = {};

		headerParameters["Content-Type"] = "application/json";

		const urlPath = `/api/bridge/v1/mcp-instance`;

		const response = await this.request(
			{
				path: urlPath,
				method: "POST",
				headers: headerParameters,
				query: queryParameters,
				body: CreateMcpServerInstanceRequestToJSON(
					requestParameters.createMcpServerInstanceRequest,
				),
			},
			initOverrides,
		);

		return new runtime.JSONApiResponse(response, (jsonValue) =>
			McpServerInstanceSerializedWithFunctionsFromJSON(jsonValue),
		);
	}

	/**
	 * Create a new MCP server instance with a user-provided ID
	 * Create MCP server instance
	 */
	async createMcpServerInstance(
		requestParameters: V1ApiCreateMcpServerInstanceOperationRequest,
		initOverrides?: RequestInit | runtime.InitOverrideFunction,
	): Promise<McpServerInstanceSerializedWithFunctions> {
		const response = await this.createMcpServerInstanceRaw(
			requestParameters,
			initOverrides,
		);
		return await response.value();
	}

	/**
	 * Create a new provider instance with the specified configuration
	 * Create provider
	 */
	async createProviderInstanceRaw(
		requestParameters: V1ApiCreateProviderInstanceRequest,
		initOverrides?: RequestInit | runtime.InitOverrideFunction,
	): Promise<runtime.ApiResponse<ProviderInstanceSerialized>> {
		if (requestParameters.providerControllerTypeId == null) {
			throw new runtime.RequiredError(
				"providerControllerTypeId",
				'Required parameter "providerControllerTypeId" was null or undefined when calling createProviderInstance().',
			);
		}

		if (requestParameters.credentialControllerTypeId == null) {
			throw new runtime.RequiredError(
				"credentialControllerTypeId",
				'Required parameter "credentialControllerTypeId" was null or undefined when calling createProviderInstance().',
			);
		}

		if (requestParameters.createProviderInstanceParamsInner == null) {
			throw new runtime.RequiredError(
				"createProviderInstanceParamsInner",
				'Required parameter "createProviderInstanceParamsInner" was null or undefined when calling createProviderInstance().',
			);
		}

		const queryParameters: any = {};

		const headerParameters: runtime.HTTPHeaders = {};

		headerParameters["Content-Type"] = "application/json";

		let urlPath = `/api/bridge/v1/available-providers/{provider_controller_type_id}/available-credentials/{credential_controller_type_id}`;
		urlPath = urlPath.replace(
			`{${"provider_controller_type_id"}}`,
			encodeURIComponent(String(requestParameters.providerControllerTypeId)),
		);
		urlPath = urlPath.replace(
			`{${"credential_controller_type_id"}}`,
			encodeURIComponent(String(requestParameters.credentialControllerTypeId)),
		);

		const response = await this.request(
			{
				path: urlPath,
				method: "POST",
				headers: headerParameters,
				query: queryParameters,
				body: CreateProviderInstanceParamsInnerToJSON(
					requestParameters.createProviderInstanceParamsInner,
				),
			},
			initOverrides,
		);

		return new runtime.JSONApiResponse(response, (jsonValue) =>
			ProviderInstanceSerializedFromJSON(jsonValue),
		);
	}

	/**
	 * Create a new provider instance with the specified configuration
	 * Create provider
	 */
	async createProviderInstance(
		requestParameters: V1ApiCreateProviderInstanceRequest,
		initOverrides?: RequestInit | runtime.InitOverrideFunction,
	): Promise<ProviderInstanceSerialized> {
		const response = await this.createProviderInstanceRaw(
			requestParameters,
			initOverrides,
		);
		return await response.value();
	}

	/**
	 * Create a new resource server credential
	 * Create resource server credential
	 */
	async createResourceServerCredentialRaw(
		requestParameters: V1ApiCreateResourceServerCredentialRequest,
		initOverrides?: RequestInit | runtime.InitOverrideFunction,
	): Promise<runtime.ApiResponse<ResourceServerCredentialSerialized>> {
		if (requestParameters.providerControllerTypeId == null) {
			throw new runtime.RequiredError(
				"providerControllerTypeId",
				'Required parameter "providerControllerTypeId" was null or undefined when calling createResourceServerCredential().',
			);
		}

		if (requestParameters.credentialControllerTypeId == null) {
			throw new runtime.RequiredError(
				"credentialControllerTypeId",
				'Required parameter "credentialControllerTypeId" was null or undefined when calling createResourceServerCredential().',
			);
		}

		if (requestParameters.createResourceServerCredentialParamsInner == null) {
			throw new runtime.RequiredError(
				"createResourceServerCredentialParamsInner",
				'Required parameter "createResourceServerCredentialParamsInner" was null or undefined when calling createResourceServerCredential().',
			);
		}

		const queryParameters: any = {};

		const headerParameters: runtime.HTTPHeaders = {};

		headerParameters["Content-Type"] = "application/json";

		let urlPath = `/api/bridge/v1/available-providers/{provider_controller_type_id}/available-credentials/{credential_controller_type_id}/credential/resource-server`;
		urlPath = urlPath.replace(
			`{${"provider_controller_type_id"}}`,
			encodeURIComponent(String(requestParameters.providerControllerTypeId)),
		);
		urlPath = urlPath.replace(
			`{${"credential_controller_type_id"}}`,
			encodeURIComponent(String(requestParameters.credentialControllerTypeId)),
		);

		const response = await this.request(
			{
				path: urlPath,
				method: "POST",
				headers: headerParameters,
				query: queryParameters,
				body: CreateResourceServerCredentialParamsInnerToJSON(
					requestParameters.createResourceServerCredentialParamsInner,
				),
			},
			initOverrides,
		);

		return new runtime.JSONApiResponse(response, (jsonValue) =>
			ResourceServerCredentialSerializedFromJSON(jsonValue),
		);
	}

	/**
	 * Create a new resource server credential
	 * Create resource server credential
	 */
	async createResourceServerCredential(
		requestParameters: V1ApiCreateResourceServerCredentialRequest,
		initOverrides?: RequestInit | runtime.InitOverrideFunction,
	): Promise<ResourceServerCredentialSerialized> {
		const response = await this.createResourceServerCredentialRaw(
			requestParameters,
			initOverrides,
		);
		return await response.value();
	}

	/**
	 * Create a new encrypted secret with the specified key and value
	 * Create secret
	 */
	async createSecretRaw(
		requestParameters: V1ApiCreateSecretOperationRequest,
		initOverrides?: RequestInit | runtime.InitOverrideFunction,
	): Promise<runtime.ApiResponse<Secret>> {
		if (requestParameters.createSecretRequest == null) {
			throw new runtime.RequiredError(
				"createSecretRequest",
				'Required parameter "createSecretRequest" was null or undefined when calling createSecret().',
			);
		}

		const queryParameters: any = {};

		const headerParameters: runtime.HTTPHeaders = {};

		headerParameters["Content-Type"] = "application/json";

		const urlPath = `/api/secret/v1`;

		const response = await this.request(
			{
				path: urlPath,
				method: "POST",
				headers: headerParameters,
				query: queryParameters,
				body: CreateSecretRequestToJSON(requestParameters.createSecretRequest),
			},
			initOverrides,
		);

		return new runtime.JSONApiResponse(response, (jsonValue) =>
			SecretFromJSON(jsonValue),
		);
	}

	/**
	 * Create a new encrypted secret with the specified key and value
	 * Create secret
	 */
	async createSecret(
		requestParameters: V1ApiCreateSecretOperationRequest,
		initOverrides?: RequestInit | runtime.InitOverrideFunction,
	): Promise<Secret> {
		const response = await this.createSecretRaw(
			requestParameters,
			initOverrides,
		);
		return await response.value();
	}

	/**
	 * Create a new user credential
	 * Create user credential
	 */
	async createUserCredentialRaw(
		requestParameters: V1ApiCreateUserCredentialRequest,
		initOverrides?: RequestInit | runtime.InitOverrideFunction,
	): Promise<runtime.ApiResponse<UserCredentialSerialized>> {
		if (requestParameters.providerControllerTypeId == null) {
			throw new runtime.RequiredError(
				"providerControllerTypeId",
				'Required parameter "providerControllerTypeId" was null or undefined when calling createUserCredential().',
			);
		}

		if (requestParameters.credentialControllerTypeId == null) {
			throw new runtime.RequiredError(
				"credentialControllerTypeId",
				'Required parameter "credentialControllerTypeId" was null or undefined when calling createUserCredential().',
			);
		}

		if (requestParameters.createUserCredentialParamsInner == null) {
			throw new runtime.RequiredError(
				"createUserCredentialParamsInner",
				'Required parameter "createUserCredentialParamsInner" was null or undefined when calling createUserCredential().',
			);
		}

		const queryParameters: any = {};

		const headerParameters: runtime.HTTPHeaders = {};

		headerParameters["Content-Type"] = "application/json";

		let urlPath = `/api/bridge/v1/available-providers/{provider_controller_type_id}/available-credentials/{credential_controller_type_id}/credential/user-credential`;
		urlPath = urlPath.replace(
			`{${"provider_controller_type_id"}}`,
			encodeURIComponent(String(requestParameters.providerControllerTypeId)),
		);
		urlPath = urlPath.replace(
			`{${"credential_controller_type_id"}}`,
			encodeURIComponent(String(requestParameters.credentialControllerTypeId)),
		);

		const response = await this.request(
			{
				path: urlPath,
				method: "POST",
				headers: headerParameters,
				query: queryParameters,
				body: CreateUserCredentialParamsInnerToJSON(
					requestParameters.createUserCredentialParamsInner,
				),
			},
			initOverrides,
		);

		return new runtime.JSONApiResponse(response, (jsonValue) =>
			UserCredentialSerializedFromJSON(jsonValue),
		);
	}

	/**
	 * Create a new user credential
	 * Create user credential
	 */
	async createUserCredential(
		requestParameters: V1ApiCreateUserCredentialRequest,
		initOverrides?: RequestInit | runtime.InitOverrideFunction,
	): Promise<UserCredentialSerialized> {
		const response = await this.createUserCredentialRaw(
			requestParameters,
			initOverrides,
		);
		return await response.value();
	}

	/**
	 * Delete an alias for a data encryption key
	 * Delete DEK alias
	 */
	async deleteDekAliasRaw(
		requestParameters: V1ApiDeleteDekAliasRequest,
		initOverrides?: RequestInit | runtime.InitOverrideFunction,
	): Promise<runtime.ApiResponse<void>> {
		if (requestParameters.alias == null) {
			throw new runtime.RequiredError(
				"alias",
				'Required parameter "alias" was null or undefined when calling deleteDekAlias().',
			);
		}

		const queryParameters: any = {};

		const headerParameters: runtime.HTTPHeaders = {};

		let urlPath = `/api/encryption/v1/dek/alias/{alias}`;
		urlPath = urlPath.replace(
			`{${"alias"}}`,
			encodeURIComponent(String(requestParameters.alias)),
		);

		const response = await this.request(
			{
				path: urlPath,
				method: "DELETE",
				headers: headerParameters,
				query: queryParameters,
			},
			initOverrides,
		);

		return new runtime.VoidApiResponse(response);
	}

	/**
	 * Delete an alias for a data encryption key
	 * Delete DEK alias
	 */
	async deleteDekAlias(
		requestParameters: V1ApiDeleteDekAliasRequest,
		initOverrides?: RequestInit | runtime.InitOverrideFunction,
	): Promise<void> {
		await this.deleteDekAliasRaw(requestParameters, initOverrides);
	}

	/**
	 * Delete an environment variable by its unique identifier
	 * Delete environment variable
	 */
	async deleteEnvironmentVariableRaw(
		requestParameters: V1ApiDeleteEnvironmentVariableRequest,
		initOverrides?: RequestInit | runtime.InitOverrideFunction,
	): Promise<runtime.ApiResponse<DeleteEnvironmentVariableResponse>> {
		if (requestParameters.envVarId == null) {
			throw new runtime.RequiredError(
				"envVarId",
				'Required parameter "envVarId" was null or undefined when calling deleteEnvironmentVariable().',
			);
		}

		const queryParameters: any = {};

		const headerParameters: runtime.HTTPHeaders = {};

		let urlPath = `/api/environment-variable/v1/{env_var_id}`;
		urlPath = urlPath.replace(
			`{${"env_var_id"}}`,
			encodeURIComponent(String(requestParameters.envVarId)),
		);

		const response = await this.request(
			{
				path: urlPath,
				method: "DELETE",
				headers: headerParameters,
				query: queryParameters,
			},
			initOverrides,
		);

		return new runtime.JSONApiResponse(response, (jsonValue) =>
			DeleteEnvironmentVariableResponseFromJSON(jsonValue),
		);
	}

	/**
	 * Delete an environment variable by its unique identifier
	 * Delete environment variable
	 */
	async deleteEnvironmentVariable(
		requestParameters: V1ApiDeleteEnvironmentVariableRequest,
		initOverrides?: RequestInit | runtime.InitOverrideFunction,
	): Promise<DeleteEnvironmentVariableResponse> {
		const response = await this.deleteEnvironmentVariableRaw(
			requestParameters,
			initOverrides,
		);
		return await response.value();
	}

	/**
	 * Delete an MCP server instance and all its function mappings
	 * Delete MCP server instance
	 */
	async deleteMcpServerInstanceRaw(
		requestParameters: V1ApiDeleteMcpServerInstanceRequest,
		initOverrides?: RequestInit | runtime.InitOverrideFunction,
	): Promise<runtime.ApiResponse<void>> {
		if (requestParameters.mcpServerInstanceId == null) {
			throw new runtime.RequiredError(
				"mcpServerInstanceId",
				'Required parameter "mcpServerInstanceId" was null or undefined when calling deleteMcpServerInstance().',
			);
		}

		const queryParameters: any = {};

		const headerParameters: runtime.HTTPHeaders = {};

		let urlPath = `/api/bridge/v1/mcp-instance/{mcp_server_instance_id}`;
		urlPath = urlPath.replace(
			`{${"mcp_server_instance_id"}}`,
			encodeURIComponent(String(requestParameters.mcpServerInstanceId)),
		);

		const response = await this.request(
			{
				path: urlPath,
				method: "DELETE",
				headers: headerParameters,
				query: queryParameters,
			},
			initOverrides,
		);

		return new runtime.VoidApiResponse(response);
	}

	/**
	 * Delete an MCP server instance and all its function mappings
	 * Delete MCP server instance
	 */
	async deleteMcpServerInstance(
		requestParameters: V1ApiDeleteMcpServerInstanceRequest,
		initOverrides?: RequestInit | runtime.InitOverrideFunction,
	): Promise<void> {
		await this.deleteMcpServerInstanceRaw(requestParameters, initOverrides);
	}

	/**
	 * Delete a provider instance by its unique identifier
	 * Delete provider
	 */
	async deleteProviderInstanceRaw(
		requestParameters: V1ApiDeleteProviderInstanceRequest,
		initOverrides?: RequestInit | runtime.InitOverrideFunction,
	): Promise<runtime.ApiResponse<any>> {
		if (requestParameters.providerInstanceId == null) {
			throw new runtime.RequiredError(
				"providerInstanceId",
				'Required parameter "providerInstanceId" was null or undefined when calling deleteProviderInstance().',
			);
		}

		const queryParameters: any = {};

		const headerParameters: runtime.HTTPHeaders = {};

		let urlPath = `/api/bridge/v1/provider/{provider_instance_id}`;
		urlPath = urlPath.replace(
			`{${"provider_instance_id"}}`,
			encodeURIComponent(String(requestParameters.providerInstanceId)),
		);

		const response = await this.request(
			{
				path: urlPath,
				method: "DELETE",
				headers: headerParameters,
				query: queryParameters,
			},
			initOverrides,
		);

		if (this.isJsonMime(response.headers.get("content-type"))) {
			return new runtime.JSONApiResponse<any>(response);
		} else {
			return new runtime.TextApiResponse(response) as any;
		}
	}

	/**
	 * Delete a provider instance by its unique identifier
	 * Delete provider
	 */
	async deleteProviderInstance(
		requestParameters: V1ApiDeleteProviderInstanceRequest,
		initOverrides?: RequestInit | runtime.InitOverrideFunction,
	): Promise<any> {
		const response = await this.deleteProviderInstanceRaw(
			requestParameters,
			initOverrides,
		);
		return await response.value();
	}

	/**
	 * Delete a secret by its unique identifier
	 * Delete secret
	 */
	async deleteSecretRaw(
		requestParameters: V1ApiDeleteSecretRequest,
		initOverrides?: RequestInit | runtime.InitOverrideFunction,
	): Promise<runtime.ApiResponse<DeleteSecretResponse>> {
		if (requestParameters.secretId == null) {
			throw new runtime.RequiredError(
				"secretId",
				'Required parameter "secretId" was null or undefined when calling deleteSecret().',
			);
		}

		const queryParameters: any = {};

		const headerParameters: runtime.HTTPHeaders = {};

		let urlPath = `/api/secret/v1/{secret_id}`;
		urlPath = urlPath.replace(
			`{${"secret_id"}}`,
			encodeURIComponent(String(requestParameters.secretId)),
		);

		const response = await this.request(
			{
				path: urlPath,
				method: "DELETE",
				headers: headerParameters,
				query: queryParameters,
			},
			initOverrides,
		);

		return new runtime.JSONApiResponse(response, (jsonValue) =>
			DeleteSecretResponseFromJSON(jsonValue),
		);
	}

	/**
	 * Delete a secret by its unique identifier
	 * Delete secret
	 */
	async deleteSecret(
		requestParameters: V1ApiDeleteSecretRequest,
		initOverrides?: RequestInit | runtime.InitOverrideFunction,
	): Promise<DeleteSecretResponse> {
		const response = await this.deleteSecretRaw(
			requestParameters,
			initOverrides,
		);
		return await response.value();
	}

	/**
	 * Disable a function for a provider instance
	 * Disable function
	 */
	async disableFunctionRaw(
		requestParameters: V1ApiDisableFunctionRequest,
		initOverrides?: RequestInit | runtime.InitOverrideFunction,
	): Promise<runtime.ApiResponse<any>> {
		if (requestParameters.providerInstanceId == null) {
			throw new runtime.RequiredError(
				"providerInstanceId",
				'Required parameter "providerInstanceId" was null or undefined when calling disableFunction().',
			);
		}

		if (requestParameters.functionControllerTypeId == null) {
			throw new runtime.RequiredError(
				"functionControllerTypeId",
				'Required parameter "functionControllerTypeId" was null or undefined when calling disableFunction().',
			);
		}

		const queryParameters: any = {};

		const headerParameters: runtime.HTTPHeaders = {};

		let urlPath = `/api/bridge/v1/provider/{provider_instance_id}/function/{function_controller_type_id}/disable`;
		urlPath = urlPath.replace(
			`{${"provider_instance_id"}}`,
			encodeURIComponent(String(requestParameters.providerInstanceId)),
		);
		urlPath = urlPath.replace(
			`{${"function_controller_type_id"}}`,
			encodeURIComponent(String(requestParameters.functionControllerTypeId)),
		);

		const response = await this.request(
			{
				path: urlPath,
				method: "POST",
				headers: headerParameters,
				query: queryParameters,
			},
			initOverrides,
		);

		if (this.isJsonMime(response.headers.get("content-type"))) {
			return new runtime.JSONApiResponse<any>(response);
		} else {
			return new runtime.TextApiResponse(response) as any;
		}
	}

	/**
	 * Disable a function for a provider instance
	 * Disable function
	 */
	async disableFunction(
		requestParameters: V1ApiDisableFunctionRequest,
		initOverrides?: RequestInit | runtime.InitOverrideFunction,
	): Promise<any> {
		const response = await this.disableFunctionRaw(
			requestParameters,
			initOverrides,
		);
		return await response.value();
	}

	/**
	 * Enable a function for a provider instance
	 * Enable function
	 */
	async enableFunctionRaw(
		requestParameters: V1ApiEnableFunctionRequest,
		initOverrides?: RequestInit | runtime.InitOverrideFunction,
	): Promise<runtime.ApiResponse<FunctionInstanceSerialized>> {
		if (requestParameters.providerInstanceId == null) {
			throw new runtime.RequiredError(
				"providerInstanceId",
				'Required parameter "providerInstanceId" was null or undefined when calling enableFunction().',
			);
		}

		if (requestParameters.functionControllerTypeId == null) {
			throw new runtime.RequiredError(
				"functionControllerTypeId",
				'Required parameter "functionControllerTypeId" was null or undefined when calling enableFunction().',
			);
		}

		if (requestParameters.body == null) {
			throw new runtime.RequiredError(
				"body",
				'Required parameter "body" was null or undefined when calling enableFunction().',
			);
		}

		const queryParameters: any = {};

		const headerParameters: runtime.HTTPHeaders = {};

		headerParameters["Content-Type"] = "application/json";

		let urlPath = `/api/bridge/v1/provider/{provider_instance_id}/function/{function_controller_type_id}/enable`;
		urlPath = urlPath.replace(
			`{${"provider_instance_id"}}`,
			encodeURIComponent(String(requestParameters.providerInstanceId)),
		);
		urlPath = urlPath.replace(
			`{${"function_controller_type_id"}}`,
			encodeURIComponent(String(requestParameters.functionControllerTypeId)),
		);

		const response = await this.request(
			{
				path: urlPath,
				method: "POST",
				headers: headerParameters,
				query: queryParameters,
				body: requestParameters.body as any,
			},
			initOverrides,
		);

		return new runtime.JSONApiResponse(response, (jsonValue) =>
			FunctionInstanceSerializedFromJSON(jsonValue),
		);
	}

	/**
	 * Enable a function for a provider instance
	 * Enable function
	 */
	async enableFunction(
		requestParameters: V1ApiEnableFunctionRequest,
		initOverrides?: RequestInit | runtime.InitOverrideFunction,
	): Promise<FunctionInstanceSerialized> {
		const response = await this.enableFunctionRaw(
			requestParameters,
			initOverrides,
		);
		return await response.value();
	}

	/**
	 * Encrypt a resource server credential configuration before storage
	 * Encrypt resource server config
	 */
	async encryptResourceServerConfigurationRaw(
		requestParameters: V1ApiEncryptResourceServerConfigurationRequest,
		initOverrides?: RequestInit | runtime.InitOverrideFunction,
	): Promise<runtime.ApiResponse<any>> {
		if (requestParameters.providerControllerTypeId == null) {
			throw new runtime.RequiredError(
				"providerControllerTypeId",
				'Required parameter "providerControllerTypeId" was null or undefined when calling encryptResourceServerConfiguration().',
			);
		}

		if (requestParameters.credentialControllerTypeId == null) {
			throw new runtime.RequiredError(
				"credentialControllerTypeId",
				'Required parameter "credentialControllerTypeId" was null or undefined when calling encryptResourceServerConfiguration().',
			);
		}

		if (requestParameters.encryptCredentialConfigurationParamsInner == null) {
			throw new runtime.RequiredError(
				"encryptCredentialConfigurationParamsInner",
				'Required parameter "encryptCredentialConfigurationParamsInner" was null or undefined when calling encryptResourceServerConfiguration().',
			);
		}

		const queryParameters: any = {};

		const headerParameters: runtime.HTTPHeaders = {};

		headerParameters["Content-Type"] = "application/json";

		let urlPath = `/api/bridge/v1/available-providers/{provider_controller_type_id}/available-credentials/{credential_controller_type_id}/credential/resource-server/encrypt`;
		urlPath = urlPath.replace(
			`{${"provider_controller_type_id"}}`,
			encodeURIComponent(String(requestParameters.providerControllerTypeId)),
		);
		urlPath = urlPath.replace(
			`{${"credential_controller_type_id"}}`,
			encodeURIComponent(String(requestParameters.credentialControllerTypeId)),
		);

		const response = await this.request(
			{
				path: urlPath,
				method: "POST",
				headers: headerParameters,
				query: queryParameters,
				body: EncryptCredentialConfigurationParamsInnerToJSON(
					requestParameters.encryptCredentialConfigurationParamsInner,
				),
			},
			initOverrides,
		);

		if (this.isJsonMime(response.headers.get("content-type"))) {
			return new runtime.JSONApiResponse<any>(response);
		} else {
			return new runtime.TextApiResponse(response) as any;
		}
	}

	/**
	 * Encrypt a resource server credential configuration before storage
	 * Encrypt resource server config
	 */
	async encryptResourceServerConfiguration(
		requestParameters: V1ApiEncryptResourceServerConfigurationRequest,
		initOverrides?: RequestInit | runtime.InitOverrideFunction,
	): Promise<any> {
		const response = await this.encryptResourceServerConfigurationRaw(
			requestParameters,
			initOverrides,
		);
		return await response.value();
	}

	/**
	 * Encrypt a user credential configuration before storage
	 * Encrypt user credential config
	 */
	async encryptUserCredentialConfigurationRaw(
		requestParameters: V1ApiEncryptUserCredentialConfigurationRequest,
		initOverrides?: RequestInit | runtime.InitOverrideFunction,
	): Promise<runtime.ApiResponse<any>> {
		if (requestParameters.providerControllerTypeId == null) {
			throw new runtime.RequiredError(
				"providerControllerTypeId",
				'Required parameter "providerControllerTypeId" was null or undefined when calling encryptUserCredentialConfiguration().',
			);
		}

		if (requestParameters.credentialControllerTypeId == null) {
			throw new runtime.RequiredError(
				"credentialControllerTypeId",
				'Required parameter "credentialControllerTypeId" was null or undefined when calling encryptUserCredentialConfiguration().',
			);
		}

		if (requestParameters.encryptCredentialConfigurationParamsInner == null) {
			throw new runtime.RequiredError(
				"encryptCredentialConfigurationParamsInner",
				'Required parameter "encryptCredentialConfigurationParamsInner" was null or undefined when calling encryptUserCredentialConfiguration().',
			);
		}

		const queryParameters: any = {};

		const headerParameters: runtime.HTTPHeaders = {};

		headerParameters["Content-Type"] = "application/json";

		let urlPath = `/api/bridge/v1/available-providers/{provider_controller_type_id}/available-credentials/{credential_controller_type_id}/credential/user-credential/encrypt`;
		urlPath = urlPath.replace(
			`{${"provider_controller_type_id"}}`,
			encodeURIComponent(String(requestParameters.providerControllerTypeId)),
		);
		urlPath = urlPath.replace(
			`{${"credential_controller_type_id"}}`,
			encodeURIComponent(String(requestParameters.credentialControllerTypeId)),
		);

		const response = await this.request(
			{
				path: urlPath,
				method: "POST",
				headers: headerParameters,
				query: queryParameters,
				body: EncryptCredentialConfigurationParamsInnerToJSON(
					requestParameters.encryptCredentialConfigurationParamsInner,
				),
			},
			initOverrides,
		);

		if (this.isJsonMime(response.headers.get("content-type"))) {
			return new runtime.JSONApiResponse<any>(response);
		} else {
			return new runtime.TextApiResponse(response) as any;
		}
	}

	/**
	 * Encrypt a user credential configuration before storage
	 * Encrypt user credential config
	 */
	async encryptUserCredentialConfiguration(
		requestParameters: V1ApiEncryptUserCredentialConfigurationRequest,
		initOverrides?: RequestInit | runtime.InitOverrideFunction,
	): Promise<any> {
		const response = await this.encryptUserCredentialConfigurationRaw(
			requestParameters,
			initOverrides,
		);
		return await response.value();
	}

	/**
	 * Get the agent card describing agent capabilities and metadata for a specific agent
	 * Get agent card for specific agent
	 */
	async getAgentCardRaw(
		requestParameters: V1ApiGetAgentCardRequest,
		initOverrides?: RequestInit | runtime.InitOverrideFunction,
	): Promise<runtime.ApiResponse<object>> {
		if (requestParameters.projectId == null) {
			throw new runtime.RequiredError(
				"projectId",
				'Required parameter "projectId" was null or undefined when calling getAgentCard().',
			);
		}

		if (requestParameters.agentId == null) {
			throw new runtime.RequiredError(
				"agentId",
				'Required parameter "agentId" was null or undefined when calling getAgentCard().',
			);
		}

		const queryParameters: any = {};

		const headerParameters: runtime.HTTPHeaders = {};

		let urlPath = `/api/agent/{project_id}/{agent_id}/a2a/.well-known/agent.json`;
		urlPath = urlPath.replace(
			`{${"project_id"}}`,
			encodeURIComponent(String(requestParameters.projectId)),
		);
		urlPath = urlPath.replace(
			`{${"agent_id"}}`,
			encodeURIComponent(String(requestParameters.agentId)),
		);

		const response = await this.request(
			{
				path: urlPath,
				method: "GET",
				headers: headerParameters,
				query: queryParameters,
			},
			initOverrides,
		);

		return new runtime.JSONApiResponse<any>(response);
	}

	/**
	 * Get the agent card describing agent capabilities and metadata for a specific agent
	 * Get agent card for specific agent
	 */
	async getAgentCard(
		requestParameters: V1ApiGetAgentCardRequest,
		initOverrides?: RequestInit | runtime.InitOverrideFunction,
	): Promise<object> {
		const response = await this.getAgentCardRaw(
			requestParameters,
			initOverrides,
		);
		return await response.value();
	}

	/**
	 * Retrieve a data encryption key by its alias or ID
	 * Get DEK by alias
	 */
	async getDekByAliasOrIdRaw(
		requestParameters: V1ApiGetDekByAliasOrIdRequest,
		initOverrides?: RequestInit | runtime.InitOverrideFunction,
	): Promise<runtime.ApiResponse<DataEncryptionKey>> {
		if (requestParameters.alias == null) {
			throw new runtime.RequiredError(
				"alias",
				'Required parameter "alias" was null or undefined when calling getDekByAliasOrId().',
			);
		}

		const queryParameters: any = {};

		const headerParameters: runtime.HTTPHeaders = {};

		let urlPath = `/api/encryption/v1/dek/alias/{alias}`;
		urlPath = urlPath.replace(
			`{${"alias"}}`,
			encodeURIComponent(String(requestParameters.alias)),
		);

		const response = await this.request(
			{
				path: urlPath,
				method: "GET",
				headers: headerParameters,
				query: queryParameters,
			},
			initOverrides,
		);

		return new runtime.JSONApiResponse(response, (jsonValue) =>
			DataEncryptionKeyFromJSON(jsonValue),
		);
	}

	/**
	 * Retrieve a data encryption key by its alias or ID
	 * Get DEK by alias
	 */
	async getDekByAliasOrId(
		requestParameters: V1ApiGetDekByAliasOrIdRequest,
		initOverrides?: RequestInit | runtime.InitOverrideFunction,
	): Promise<DataEncryptionKey> {
		const response = await this.getDekByAliasOrIdRaw(
			requestParameters,
			initOverrides,
		);
		return await response.value();
	}

	/**
	 * Retrieve an environment variable by its unique identifier
	 * Get environment variable
	 */
	async getEnvironmentVariableByIdRaw(
		requestParameters: V1ApiGetEnvironmentVariableByIdRequest,
		initOverrides?: RequestInit | runtime.InitOverrideFunction,
	): Promise<runtime.ApiResponse<EnvironmentVariable>> {
		if (requestParameters.envVarId == null) {
			throw new runtime.RequiredError(
				"envVarId",
				'Required parameter "envVarId" was null or undefined when calling getEnvironmentVariableById().',
			);
		}

		const queryParameters: any = {};

		const headerParameters: runtime.HTTPHeaders = {};

		let urlPath = `/api/environment-variable/v1/{env_var_id}`;
		urlPath = urlPath.replace(
			`{${"env_var_id"}}`,
			encodeURIComponent(String(requestParameters.envVarId)),
		);

		const response = await this.request(
			{
				path: urlPath,
				method: "GET",
				headers: headerParameters,
				query: queryParameters,
			},
			initOverrides,
		);

		return new runtime.JSONApiResponse(response, (jsonValue) =>
			EnvironmentVariableFromJSON(jsonValue),
		);
	}

	/**
	 * Retrieve an environment variable by its unique identifier
	 * Get environment variable
	 */
	async getEnvironmentVariableById(
		requestParameters: V1ApiGetEnvironmentVariableByIdRequest,
		initOverrides?: RequestInit | runtime.InitOverrideFunction,
	): Promise<EnvironmentVariable> {
		const response = await this.getEnvironmentVariableByIdRaw(
			requestParameters,
			initOverrides,
		);
		return await response.value();
	}

	/**
	 * Retrieve an environment variable by its key name
	 * Get environment variable by key
	 */
	async getEnvironmentVariableByKeyRaw(
		requestParameters: V1ApiGetEnvironmentVariableByKeyRequest,
		initOverrides?: RequestInit | runtime.InitOverrideFunction,
	): Promise<runtime.ApiResponse<EnvironmentVariable>> {
		if (requestParameters.key == null) {
			throw new runtime.RequiredError(
				"key",
				'Required parameter "key" was null or undefined when calling getEnvironmentVariableByKey().',
			);
		}

		const queryParameters: any = {};

		const headerParameters: runtime.HTTPHeaders = {};

		let urlPath = `/api/environment-variable/v1/key/{key}`;
		urlPath = urlPath.replace(
			`{${"key"}}`,
			encodeURIComponent(String(requestParameters.key)),
		);

		const response = await this.request(
			{
				path: urlPath,
				method: "GET",
				headers: headerParameters,
				query: queryParameters,
			},
			initOverrides,
		);

		return new runtime.JSONApiResponse(response, (jsonValue) =>
			EnvironmentVariableFromJSON(jsonValue),
		);
	}

	/**
	 * Retrieve an environment variable by its key name
	 * Get environment variable by key
	 */
	async getEnvironmentVariableByKey(
		requestParameters: V1ApiGetEnvironmentVariableByKeyRequest,
		initOverrides?: RequestInit | runtime.InitOverrideFunction,
	): Promise<EnvironmentVariable> {
		const response = await this.getEnvironmentVariableByKeyRaw(
			requestParameters,
			initOverrides,
		);
		return await response.value();
	}

	/**
	 * Get the OpenAPI specification for all function instances
	 * Get function OpenAPI spec
	 */
	async getFunctionInstancesOpenapiSpecRaw(
		initOverrides?: RequestInit | runtime.InitOverrideFunction,
	): Promise<runtime.ApiResponse<string>> {
		const queryParameters: any = {};

		const headerParameters: runtime.HTTPHeaders = {};

		const urlPath = `/api/bridge/v1/function-instances/openapi.json`;

		const response = await this.request(
			{
				path: urlPath,
				method: "GET",
				headers: headerParameters,
				query: queryParameters,
			},
			initOverrides,
		);

		if (this.isJsonMime(response.headers.get("content-type"))) {
			return new runtime.JSONApiResponse<string>(response);
		} else {
			return new runtime.TextApiResponse(response) as any;
		}
	}

	/**
	 * Get the OpenAPI specification for all function instances
	 * Get function OpenAPI spec
	 */
	async getFunctionInstancesOpenapiSpec(
		initOverrides?: RequestInit | runtime.InitOverrideFunction,
	): Promise<string> {
		const response =
			await this.getFunctionInstancesOpenapiSpecRaw(initOverrides);
		return await response.value();
	}

	/**
	 * Get the current runtime configuration
	 * Get runtime config
	 */
	async getInternalRuntimeConfigRaw(
		initOverrides?: RequestInit | runtime.InitOverrideFunction,
	): Promise<runtime.ApiResponse<object>> {
		const queryParameters: any = {};

		const headerParameters: runtime.HTTPHeaders = {};

		const urlPath = `/_internal/v1/runtime_config`;

		const response = await this.request(
			{
				path: urlPath,
				method: "GET",
				headers: headerParameters,
				query: queryParameters,
			},
			initOverrides,
		);

		return new runtime.JSONApiResponse<any>(response);
	}

	/**
	 * Get the current runtime configuration
	 * Get runtime config
	 */
	async getInternalRuntimeConfig(
		initOverrides?: RequestInit | runtime.InitOverrideFunction,
	): Promise<object> {
		const response = await this.getInternalRuntimeConfigRaw(initOverrides);
		return await response.value();
	}

	/**
	 * Retrieve an MCP server instance by its ID
	 * Get MCP server instance
	 */
	async getMcpServerInstanceRaw(
		requestParameters: V1ApiGetMcpServerInstanceRequest,
		initOverrides?: RequestInit | runtime.InitOverrideFunction,
	): Promise<runtime.ApiResponse<McpServerInstanceSerializedWithFunctions>> {
		if (requestParameters.mcpServerInstanceId == null) {
			throw new runtime.RequiredError(
				"mcpServerInstanceId",
				'Required parameter "mcpServerInstanceId" was null or undefined when calling getMcpServerInstance().',
			);
		}

		const queryParameters: any = {};

		const headerParameters: runtime.HTTPHeaders = {};

		let urlPath = `/api/bridge/v1/mcp-instance/{mcp_server_instance_id}`;
		urlPath = urlPath.replace(
			`{${"mcp_server_instance_id"}}`,
			encodeURIComponent(String(requestParameters.mcpServerInstanceId)),
		);

		const response = await this.request(
			{
				path: urlPath,
				method: "GET",
				headers: headerParameters,
				query: queryParameters,
			},
			initOverrides,
		);

		return new runtime.JSONApiResponse(response, (jsonValue) =>
			McpServerInstanceSerializedWithFunctionsFromJSON(jsonValue),
		);
	}

	/**
	 * Retrieve an MCP server instance by its ID
	 * Get MCP server instance
	 */
	async getMcpServerInstance(
		requestParameters: V1ApiGetMcpServerInstanceRequest,
		initOverrides?: RequestInit | runtime.InitOverrideFunction,
	): Promise<McpServerInstanceSerializedWithFunctions> {
		const response = await this.getMcpServerInstanceRaw(
			requestParameters,
			initOverrides,
		);
		return await response.value();
	}

	/**
	 * Retrieve a provider instance by its unique identifier
	 * Get provider
	 */
	async getProviderInstanceRaw(
		requestParameters: V1ApiGetProviderInstanceRequest,
		initOverrides?: RequestInit | runtime.InitOverrideFunction,
	): Promise<runtime.ApiResponse<ProviderInstanceSerializedWithEverything>> {
		if (requestParameters.providerInstanceId == null) {
			throw new runtime.RequiredError(
				"providerInstanceId",
				'Required parameter "providerInstanceId" was null or undefined when calling getProviderInstance().',
			);
		}

		const queryParameters: any = {};

		const headerParameters: runtime.HTTPHeaders = {};

		let urlPath = `/api/bridge/v1/provider/{provider_instance_id}`;
		urlPath = urlPath.replace(
			`{${"provider_instance_id"}}`,
			encodeURIComponent(String(requestParameters.providerInstanceId)),
		);

		const response = await this.request(
			{
				path: urlPath,
				method: "GET",
				headers: headerParameters,
				query: queryParameters,
			},
			initOverrides,
		);

		return new runtime.JSONApiResponse(response, (jsonValue) =>
			ProviderInstanceSerializedWithEverythingFromJSON(jsonValue),
		);
	}

	/**
	 * Retrieve a provider instance by its unique identifier
	 * Get provider
	 */
	async getProviderInstance(
		requestParameters: V1ApiGetProviderInstanceRequest,
		initOverrides?: RequestInit | runtime.InitOverrideFunction,
	): Promise<ProviderInstanceSerializedWithEverything> {
		const response = await this.getProviderInstanceRaw(
			requestParameters,
			initOverrides,
		);
		return await response.value();
	}

	/**
	 * Retrieve a secret by its unique identifier
	 * Get secret
	 */
	async getSecretByIdRaw(
		requestParameters: V1ApiGetSecretByIdRequest,
		initOverrides?: RequestInit | runtime.InitOverrideFunction,
	): Promise<runtime.ApiResponse<Secret>> {
		if (requestParameters.secretId == null) {
			throw new runtime.RequiredError(
				"secretId",
				'Required parameter "secretId" was null or undefined when calling getSecretById().',
			);
		}

		const queryParameters: any = {};

		const headerParameters: runtime.HTTPHeaders = {};

		let urlPath = `/api/secret/v1/{secret_id}`;
		urlPath = urlPath.replace(
			`{${"secret_id"}}`,
			encodeURIComponent(String(requestParameters.secretId)),
		);

		const response = await this.request(
			{
				path: urlPath,
				method: "GET",
				headers: headerParameters,
				query: queryParameters,
			},
			initOverrides,
		);

		return new runtime.JSONApiResponse(response, (jsonValue) =>
			SecretFromJSON(jsonValue),
		);
	}

	/**
	 * Retrieve a secret by its unique identifier
	 * Get secret
	 */
	async getSecretById(
		requestParameters: V1ApiGetSecretByIdRequest,
		initOverrides?: RequestInit | runtime.InitOverrideFunction,
	): Promise<Secret> {
		const response = await this.getSecretByIdRaw(
			requestParameters,
			initOverrides,
		);
		return await response.value();
	}

	/**
	 * Retrieve a secret by its key name
	 * Get secret by key
	 */
	async getSecretByKeyRaw(
		requestParameters: V1ApiGetSecretByKeyRequest,
		initOverrides?: RequestInit | runtime.InitOverrideFunction,
	): Promise<runtime.ApiResponse<Secret>> {
		if (requestParameters.key == null) {
			throw new runtime.RequiredError(
				"key",
				'Required parameter "key" was null or undefined when calling getSecretByKey().',
			);
		}

		const queryParameters: any = {};

		const headerParameters: runtime.HTTPHeaders = {};

		let urlPath = `/api/secret/v1/key/{key}`;
		urlPath = urlPath.replace(
			`{${"key"}}`,
			encodeURIComponent(String(requestParameters.key)),
		);

		const response = await this.request(
			{
				path: urlPath,
				method: "GET",
				headers: headerParameters,
				query: queryParameters,
			},
			initOverrides,
		);

		return new runtime.JSONApiResponse(response, (jsonValue) =>
			SecretFromJSON(jsonValue),
		);
	}

	/**
	 * Retrieve a secret by its key name
	 * Get secret by key
	 */
	async getSecretByKey(
		requestParameters: V1ApiGetSecretByKeyRequest,
		initOverrides?: RequestInit | runtime.InitOverrideFunction,
	): Promise<Secret> {
		const response = await this.getSecretByKeyRaw(
			requestParameters,
			initOverrides,
		);
		return await response.value();
	}

	/**
	 * Retrieve a task by its unique identifier
	 * Get task
	 */
	async getTaskByIdRaw(
		requestParameters: V1ApiGetTaskByIdRequest,
		initOverrides?: RequestInit | runtime.InitOverrideFunction,
	): Promise<runtime.ApiResponse<TaskWithDetails>> {
		if (requestParameters.taskId == null) {
			throw new runtime.RequiredError(
				"taskId",
				'Required parameter "taskId" was null or undefined when calling getTaskById().',
			);
		}

		const queryParameters: any = {};

		const headerParameters: runtime.HTTPHeaders = {};

		let urlPath = `/api/task/v1/{task_id}`;
		urlPath = urlPath.replace(
			`{${"task_id"}}`,
			encodeURIComponent(String(requestParameters.taskId)),
		);

		const response = await this.request(
			{
				path: urlPath,
				method: "GET",
				headers: headerParameters,
				query: queryParameters,
			},
			initOverrides,
		);

		return new runtime.JSONApiResponse(response, (jsonValue) =>
			TaskWithDetailsFromJSON(jsonValue),
		);
	}

	/**
	 * Retrieve a task by its unique identifier
	 * Get task
	 */
	async getTaskById(
		requestParameters: V1ApiGetTaskByIdRequest,
		initOverrides?: RequestInit | runtime.InitOverrideFunction,
	): Promise<TaskWithDetails> {
		const response = await this.getTaskByIdRaw(
			requestParameters,
			initOverrides,
		);
		return await response.value();
	}

	/**
	 * Handle JSON-RPC requests for agent-to-agent communication for a specific agent
	 * Handle A2A JSON-RPC for specific agent
	 */
	async handleA2aJsonrpcRequestRaw(
		requestParameters: V1ApiHandleA2aJsonrpcRequestRequest,
		initOverrides?: RequestInit | runtime.InitOverrideFunction,
	): Promise<runtime.ApiResponse<void>> {
		if (requestParameters.projectId == null) {
			throw new runtime.RequiredError(
				"projectId",
				'Required parameter "projectId" was null or undefined when calling handleA2aJsonrpcRequest().',
			);
		}

		if (requestParameters.agentId == null) {
			throw new runtime.RequiredError(
				"agentId",
				'Required parameter "agentId" was null or undefined when calling handleA2aJsonrpcRequest().',
			);
		}

		if (requestParameters.body == null) {
			throw new runtime.RequiredError(
				"body",
				'Required parameter "body" was null or undefined when calling handleA2aJsonrpcRequest().',
			);
		}

		const queryParameters: any = {};

		const headerParameters: runtime.HTTPHeaders = {};

		headerParameters["Content-Type"] = "application/json";

		let urlPath = `/api/agent/{project_id}/{agent_id}/a2a`;
		urlPath = urlPath.replace(
			`{${"project_id"}}`,
			encodeURIComponent(String(requestParameters.projectId)),
		);
		urlPath = urlPath.replace(
			`{${"agent_id"}}`,
			encodeURIComponent(String(requestParameters.agentId)),
		);

		const response = await this.request(
			{
				path: urlPath,
				method: "POST",
				headers: headerParameters,
				query: queryParameters,
				body: requestParameters.body as any,
			},
			initOverrides,
		);

		return new runtime.VoidApiResponse(response);
	}

	/**
	 * Handle JSON-RPC requests for agent-to-agent communication for a specific agent
	 * Handle A2A JSON-RPC for specific agent
	 */
	async handleA2aJsonrpcRequest(
		requestParameters: V1ApiHandleA2aJsonrpcRequestRequest,
		initOverrides?: RequestInit | runtime.InitOverrideFunction,
	): Promise<void> {
		await this.handleA2aJsonrpcRequestRaw(requestParameters, initOverrides);
	}

	/**
	 * Check the health status of the service and SDK server connectivity
	 * Health check
	 */
	async healthCheckRaw(
		initOverrides?: RequestInit | runtime.InitOverrideFunction,
	): Promise<runtime.ApiResponse<object>> {
		const queryParameters: any = {};

		const headerParameters: runtime.HTTPHeaders = {};

		const urlPath = `/_internal/v1/health`;

		const response = await this.request(
			{
				path: urlPath,
				method: "GET",
				headers: headerParameters,
				query: queryParameters,
			},
			initOverrides,
		);

		return new runtime.JSONApiResponse<any>(response);
	}

	/**
	 * Check the health status of the service and SDK server connectivity
	 * Health check
	 */
	async healthCheck(
		initOverrides?: RequestInit | runtime.InitOverrideFunction,
	): Promise<object> {
		const response = await this.healthCheckRaw(initOverrides);
		return await response.value();
	}

	/**
	 * Import an existing pre-encrypted data encryption key into the system
	 * Import data key
	 */
	async importDataEncryptionKeyRaw(
		requestParameters: V1ApiImportDataEncryptionKeyRequest,
		initOverrides?: RequestInit | runtime.InitOverrideFunction,
	): Promise<runtime.ApiResponse<DataEncryptionKey>> {
		if (requestParameters.envelopeId == null) {
			throw new runtime.RequiredError(
				"envelopeId",
				'Required parameter "envelopeId" was null or undefined when calling importDataEncryptionKey().',
			);
		}

		if (requestParameters.importDataEncryptionKeyParamsRoute == null) {
			throw new runtime.RequiredError(
				"importDataEncryptionKeyParamsRoute",
				'Required parameter "importDataEncryptionKeyParamsRoute" was null or undefined when calling importDataEncryptionKey().',
			);
		}

		const queryParameters: any = {};

		const headerParameters: runtime.HTTPHeaders = {};

		headerParameters["Content-Type"] = "application/json";

		let urlPath = `/api/encryption/v1/envelope/{envelope_id}/dek/import`;
		urlPath = urlPath.replace(
			`{${"envelope_id"}}`,
			encodeURIComponent(String(requestParameters.envelopeId)),
		);

		const response = await this.request(
			{
				path: urlPath,
				method: "POST",
				headers: headerParameters,
				query: queryParameters,
				body: ImportDataEncryptionKeyParamsRouteToJSON(
					requestParameters.importDataEncryptionKeyParamsRoute,
				),
			},
			initOverrides,
		);

		return new runtime.JSONApiResponse(response, (jsonValue) =>
			DataEncryptionKeyFromJSON(jsonValue),
		);
	}

	/**
	 * Import an existing pre-encrypted data encryption key into the system
	 * Import data key
	 */
	async importDataEncryptionKey(
		requestParameters: V1ApiImportDataEncryptionKeyRequest,
		initOverrides?: RequestInit | runtime.InitOverrideFunction,
	): Promise<DataEncryptionKey> {
		const response = await this.importDataEncryptionKeyRaw(
			requestParameters,
			initOverrides,
		);
		return await response.value();
	}

	/**
	 * Import an existing environment variable into the system
	 * Import environment variable
	 */
	async importEnvironmentVariableRaw(
		requestParameters: V1ApiImportEnvironmentVariableOperationRequest,
		initOverrides?: RequestInit | runtime.InitOverrideFunction,
	): Promise<runtime.ApiResponse<EnvironmentVariable>> {
		if (requestParameters.importEnvironmentVariableRequest == null) {
			throw new runtime.RequiredError(
				"importEnvironmentVariableRequest",
				'Required parameter "importEnvironmentVariableRequest" was null or undefined when calling importEnvironmentVariable().',
			);
		}

		const queryParameters: any = {};

		const headerParameters: runtime.HTTPHeaders = {};

		headerParameters["Content-Type"] = "application/json";

		const urlPath = `/api/environment-variable/v1/import`;

		const response = await this.request(
			{
				path: urlPath,
				method: "POST",
				headers: headerParameters,
				query: queryParameters,
				body: ImportEnvironmentVariableRequestToJSON(
					requestParameters.importEnvironmentVariableRequest,
				),
			},
			initOverrides,
		);

		return new runtime.JSONApiResponse(response, (jsonValue) =>
			EnvironmentVariableFromJSON(jsonValue),
		);
	}

	/**
	 * Import an existing environment variable into the system
	 * Import environment variable
	 */
	async importEnvironmentVariable(
		requestParameters: V1ApiImportEnvironmentVariableOperationRequest,
		initOverrides?: RequestInit | runtime.InitOverrideFunction,
	): Promise<EnvironmentVariable> {
		const response = await this.importEnvironmentVariableRaw(
			requestParameters,
			initOverrides,
		);
		return await response.value();
	}

	/**
	 * Import an existing pre-encrypted secret into the system
	 * Import secret
	 */
	async importSecretRaw(
		requestParameters: V1ApiImportSecretOperationRequest,
		initOverrides?: RequestInit | runtime.InitOverrideFunction,
	): Promise<runtime.ApiResponse<Secret>> {
		if (requestParameters.importSecretRequest == null) {
			throw new runtime.RequiredError(
				"importSecretRequest",
				'Required parameter "importSecretRequest" was null or undefined when calling importSecret().',
			);
		}

		const queryParameters: any = {};

		const headerParameters: runtime.HTTPHeaders = {};

		headerParameters["Content-Type"] = "application/json";

		const urlPath = `/api/secret/v1/import`;

		const response = await this.request(
			{
				path: urlPath,
				method: "POST",
				headers: headerParameters,
				query: queryParameters,
				body: ImportSecretRequestToJSON(requestParameters.importSecretRequest),
			},
			initOverrides,
		);

		return new runtime.JSONApiResponse(response, (jsonValue) =>
			SecretFromJSON(jsonValue),
		);
	}

	/**
	 * Import an existing pre-encrypted secret into the system
	 * Import secret
	 */
	async importSecret(
		requestParameters: V1ApiImportSecretOperationRequest,
		initOverrides?: RequestInit | runtime.InitOverrideFunction,
	): Promise<Secret> {
		const response = await this.importSecretRaw(
			requestParameters,
			initOverrides,
		);
		return await response.value();
	}

	/**
	 * Invoke a function on a provider instance
	 * Invoke function
	 */
	async invokeFunctionRaw(
		requestParameters: V1ApiInvokeFunctionRequest,
		initOverrides?: RequestInit | runtime.InitOverrideFunction,
	): Promise<runtime.ApiResponse<InvokeResult>> {
		if (requestParameters.providerInstanceId == null) {
			throw new runtime.RequiredError(
				"providerInstanceId",
				'Required parameter "providerInstanceId" was null or undefined when calling invokeFunction().',
			);
		}

		if (requestParameters.functionControllerTypeId == null) {
			throw new runtime.RequiredError(
				"functionControllerTypeId",
				'Required parameter "functionControllerTypeId" was null or undefined when calling invokeFunction().',
			);
		}

		if (requestParameters.invokeFunctionParamsInner == null) {
			throw new runtime.RequiredError(
				"invokeFunctionParamsInner",
				'Required parameter "invokeFunctionParamsInner" was null or undefined when calling invokeFunction().',
			);
		}

		const queryParameters: any = {};

		const headerParameters: runtime.HTTPHeaders = {};

		headerParameters["Content-Type"] = "application/json";

		let urlPath = `/api/bridge/v1/provider/{provider_instance_id}/function/{function_controller_type_id}/invoke`;
		urlPath = urlPath.replace(
			`{${"provider_instance_id"}}`,
			encodeURIComponent(String(requestParameters.providerInstanceId)),
		);
		urlPath = urlPath.replace(
			`{${"function_controller_type_id"}}`,
			encodeURIComponent(String(requestParameters.functionControllerTypeId)),
		);

		const response = await this.request(
			{
				path: urlPath,
				method: "POST",
				headers: headerParameters,
				query: queryParameters,
				body: InvokeFunctionParamsInnerToJSON(
					requestParameters.invokeFunctionParamsInner,
				),
			},
			initOverrides,
		);

		return new runtime.JSONApiResponse(response, (jsonValue) =>
			InvokeResultFromJSON(jsonValue),
		);
	}

	/**
	 * Invoke a function on a provider instance
	 * Invoke function
	 */
	async invokeFunction(
		requestParameters: V1ApiInvokeFunctionRequest,
		initOverrides?: RequestInit | runtime.InitOverrideFunction,
	): Promise<InvokeResult> {
		const response = await this.invokeFunctionRaw(
			requestParameters,
			initOverrides,
		);
		return await response.value();
	}

	/**
	 * List all available agents from the agent cache
	 * List available agents
	 */
	async listAgentsRaw(
		initOverrides?: RequestInit | runtime.InitOverrideFunction,
	): Promise<runtime.ApiResponse<ListAgentsResponse>> {
		const queryParameters: any = {};

		const headerParameters: runtime.HTTPHeaders = {};

		const urlPath = `/api/agent`;

		const response = await this.request(
			{
				path: urlPath,
				method: "GET",
				headers: headerParameters,
				query: queryParameters,
			},
			initOverrides,
		);

		return new runtime.JSONApiResponse(response, (jsonValue) =>
			ListAgentsResponseFromJSON(jsonValue),
		);
	}

	/**
	 * List all available agents from the agent cache
	 * List available agents
	 */
	async listAgents(
		initOverrides?: RequestInit | runtime.InitOverrideFunction,
	): Promise<ListAgentsResponse> {
		const response = await this.listAgentsRaw(initOverrides);
		return await response.value();
	}

	/**
	 * List all available provider types that can be instantiated
	 * List providers
	 */
	async listAvailableProvidersRaw(
		requestParameters: V1ApiListAvailableProvidersRequest,
		initOverrides?: RequestInit | runtime.InitOverrideFunction,
	): Promise<
		runtime.ApiResponse<ProviderControllerSerializedPaginatedResponse>
	> {
		if (requestParameters.pageSize == null) {
			throw new runtime.RequiredError(
				"pageSize",
				'Required parameter "pageSize" was null or undefined when calling listAvailableProviders().',
			);
		}

		const queryParameters: any = {};

		if (requestParameters.pageSize != null) {
			queryParameters.page_size = requestParameters.pageSize;
		}

		if (requestParameters.nextPageToken != null) {
			queryParameters.next_page_token = requestParameters.nextPageToken;
		}

		const headerParameters: runtime.HTTPHeaders = {};

		const urlPath = `/api/bridge/v1/available-providers`;

		const response = await this.request(
			{
				path: urlPath,
				method: "GET",
				headers: headerParameters,
				query: queryParameters,
			},
			initOverrides,
		);

		return new runtime.JSONApiResponse(response, (jsonValue) =>
			ProviderControllerSerializedPaginatedResponseFromJSON(jsonValue),
		);
	}

	/**
	 * List all available provider types that can be instantiated
	 * List providers
	 */
	async listAvailableProviders(
		requestParameters: V1ApiListAvailableProvidersRequest,
		initOverrides?: RequestInit | runtime.InitOverrideFunction,
	): Promise<ProviderControllerSerializedPaginatedResponse> {
		const response = await this.listAvailableProvidersRaw(
			requestParameters,
			initOverrides,
		);
		return await response.value();
	}

	/**
	 * List all unique task contexts with pagination
	 * List contexts
	 */
	async listContextsRaw(
		requestParameters: V1ApiListContextsRequest,
		initOverrides?: RequestInit | runtime.InitOverrideFunction,
	): Promise<runtime.ApiResponse<ContextInfoPaginatedResponse>> {
		if (requestParameters.pageSize == null) {
			throw new runtime.RequiredError(
				"pageSize",
				'Required parameter "pageSize" was null or undefined when calling listContexts().',
			);
		}

		const queryParameters: any = {};

		if (requestParameters.pageSize != null) {
			queryParameters.page_size = requestParameters.pageSize;
		}

		if (requestParameters.nextPageToken != null) {
			queryParameters.next_page_token = requestParameters.nextPageToken;
		}

		const headerParameters: runtime.HTTPHeaders = {};

		const urlPath = `/api/task/v1/context`;

		const response = await this.request(
			{
				path: urlPath,
				method: "GET",
				headers: headerParameters,
				query: queryParameters,
			},
			initOverrides,
		);

		return new runtime.JSONApiResponse(response, (jsonValue) =>
			ContextInfoPaginatedResponseFromJSON(jsonValue),
		);
	}

	/**
	 * List all unique task contexts with pagination
	 * List contexts
	 */
	async listContexts(
		requestParameters: V1ApiListContextsRequest,
		initOverrides?: RequestInit | runtime.InitOverrideFunction,
	): Promise<ContextInfoPaginatedResponse> {
		const response = await this.listContextsRaw(
			requestParameters,
			initOverrides,
		);
		return await response.value();
	}

	/**
	 * List all data encryption keys encrypted with the specified envelope encryption key
	 * List data keys
	 */
	async listDataEncryptionKeysByEnvelopeRaw(
		requestParameters: V1ApiListDataEncryptionKeysByEnvelopeRequest,
		initOverrides?: RequestInit | runtime.InitOverrideFunction,
	): Promise<runtime.ApiResponse<DataEncryptionKeyListItemPaginatedResponse>> {
		if (requestParameters.envelopeId == null) {
			throw new runtime.RequiredError(
				"envelopeId",
				'Required parameter "envelopeId" was null or undefined when calling listDataEncryptionKeysByEnvelope().',
			);
		}

		if (requestParameters.pageSize == null) {
			throw new runtime.RequiredError(
				"pageSize",
				'Required parameter "pageSize" was null or undefined when calling listDataEncryptionKeysByEnvelope().',
			);
		}

		const queryParameters: any = {};

		if (requestParameters.pageSize != null) {
			queryParameters.page_size = requestParameters.pageSize;
		}

		if (requestParameters.nextPageToken != null) {
			queryParameters.next_page_token = requestParameters.nextPageToken;
		}

		const headerParameters: runtime.HTTPHeaders = {};

		let urlPath = `/api/encryption/v1/envelope/{envelope_id}/dek`;
		urlPath = urlPath.replace(
			`{${"envelope_id"}}`,
			encodeURIComponent(String(requestParameters.envelopeId)),
		);

		const response = await this.request(
			{
				path: urlPath,
				method: "GET",
				headers: headerParameters,
				query: queryParameters,
			},
			initOverrides,
		);

		return new runtime.JSONApiResponse(response, (jsonValue) =>
			DataEncryptionKeyListItemPaginatedResponseFromJSON(jsonValue),
		);
	}

	/**
	 * List all data encryption keys encrypted with the specified envelope encryption key
	 * List data keys
	 */
	async listDataEncryptionKeysByEnvelope(
		requestParameters: V1ApiListDataEncryptionKeysByEnvelopeRequest,
		initOverrides?: RequestInit | runtime.InitOverrideFunction,
	): Promise<DataEncryptionKeyListItemPaginatedResponse> {
		const response = await this.listDataEncryptionKeysByEnvelopeRaw(
			requestParameters,
			initOverrides,
		);
		return await response.value();
	}

	/**
	 * List all secrets with decrypted values (requires decryption access)
	 * List decrypted secrets
	 */
	async listDecryptedSecretsRaw(
		requestParameters: V1ApiListDecryptedSecretsRequest,
		initOverrides?: RequestInit | runtime.InitOverrideFunction,
	): Promise<runtime.ApiResponse<ListDecryptedSecretsResponse>> {
		if (requestParameters.pageSize == null) {
			throw new runtime.RequiredError(
				"pageSize",
				'Required parameter "pageSize" was null or undefined when calling listDecryptedSecrets().',
			);
		}

		const queryParameters: any = {};

		if (requestParameters.pageSize != null) {
			queryParameters.page_size = requestParameters.pageSize;
		}

		if (requestParameters.nextPageToken != null) {
			queryParameters.next_page_token = requestParameters.nextPageToken;
		}

		const headerParameters: runtime.HTTPHeaders = {};

		const urlPath = `/api/secret/v1/list-decrypted`;

		const response = await this.request(
			{
				path: urlPath,
				method: "GET",
				headers: headerParameters,
				query: queryParameters,
			},
			initOverrides,
		);

		return new runtime.JSONApiResponse(response, (jsonValue) =>
			ListDecryptedSecretsResponseFromJSON(jsonValue),
		);
	}

	/**
	 * List all secrets with decrypted values (requires decryption access)
	 * List decrypted secrets
	 */
	async listDecryptedSecrets(
		requestParameters: V1ApiListDecryptedSecretsRequest,
		initOverrides?: RequestInit | runtime.InitOverrideFunction,
	): Promise<ListDecryptedSecretsResponse> {
		const response = await this.listDecryptedSecretsRaw(
			requestParameters,
			initOverrides,
		);
		return await response.value();
	}

	/**
	 * List all envelope encryption keys (master keys) with pagination
	 * List envelope keys
	 */
	async listEnvelopeEncryptionKeysRaw(
		requestParameters: V1ApiListEnvelopeEncryptionKeysRequest,
		initOverrides?: RequestInit | runtime.InitOverrideFunction,
	): Promise<runtime.ApiResponse<EnvelopeEncryptionKeyPaginatedResponse>> {
		if (requestParameters.pageSize == null) {
			throw new runtime.RequiredError(
				"pageSize",
				'Required parameter "pageSize" was null or undefined when calling listEnvelopeEncryptionKeys().',
			);
		}

		const queryParameters: any = {};

		if (requestParameters.pageSize != null) {
			queryParameters.page_size = requestParameters.pageSize;
		}

		if (requestParameters.nextPageToken != null) {
			queryParameters.next_page_token = requestParameters.nextPageToken;
		}

		const headerParameters: runtime.HTTPHeaders = {};

		const urlPath = `/api/encryption/v1/envelope`;

		const response = await this.request(
			{
				path: urlPath,
				method: "GET",
				headers: headerParameters,
				query: queryParameters,
			},
			initOverrides,
		);

		return new runtime.JSONApiResponse(response, (jsonValue) =>
			EnvelopeEncryptionKeyPaginatedResponseFromJSON(jsonValue),
		);
	}

	/**
	 * List all envelope encryption keys (master keys) with pagination
	 * List envelope keys
	 */
	async listEnvelopeEncryptionKeys(
		requestParameters: V1ApiListEnvelopeEncryptionKeysRequest,
		initOverrides?: RequestInit | runtime.InitOverrideFunction,
	): Promise<EnvelopeEncryptionKeyPaginatedResponse> {
		const response = await this.listEnvelopeEncryptionKeysRaw(
			requestParameters,
			initOverrides,
		);
		return await response.value();
	}

	/**
	 * List all environment variables with pagination
	 * List environment variables
	 */
	async listEnvironmentVariablesRaw(
		requestParameters: V1ApiListEnvironmentVariablesRequest,
		initOverrides?: RequestInit | runtime.InitOverrideFunction,
	): Promise<runtime.ApiResponse<ListEnvironmentVariablesResponse>> {
		if (requestParameters.pageSize == null) {
			throw new runtime.RequiredError(
				"pageSize",
				'Required parameter "pageSize" was null or undefined when calling listEnvironmentVariables().',
			);
		}

		const queryParameters: any = {};

		if (requestParameters.pageSize != null) {
			queryParameters.page_size = requestParameters.pageSize;
		}

		if (requestParameters.nextPageToken != null) {
			queryParameters.next_page_token = requestParameters.nextPageToken;
		}

		const headerParameters: runtime.HTTPHeaders = {};

		const urlPath = `/api/environment-variable/v1`;

		const response = await this.request(
			{
				path: urlPath,
				method: "GET",
				headers: headerParameters,
				query: queryParameters,
			},
			initOverrides,
		);

		return new runtime.JSONApiResponse(response, (jsonValue) =>
			ListEnvironmentVariablesResponseFromJSON(jsonValue),
		);
	}

	/**
	 * List all environment variables with pagination
	 * List environment variables
	 */
	async listEnvironmentVariables(
		requestParameters: V1ApiListEnvironmentVariablesRequest,
		initOverrides?: RequestInit | runtime.InitOverrideFunction,
	): Promise<ListEnvironmentVariablesResponse> {
		const response = await this.listEnvironmentVariablesRaw(
			requestParameters,
			initOverrides,
		);
		return await response.value();
	}

	/**
	 * List all function instances with optional filtering by provider instance
	 * List function instances
	 */
	async listFunctionInstancesRaw(
		requestParameters: V1ApiListFunctionInstancesRequest,
		initOverrides?: RequestInit | runtime.InitOverrideFunction,
	): Promise<runtime.ApiResponse<FunctionInstanceSerializedPaginatedResponse>> {
		if (requestParameters.pageSize == null) {
			throw new runtime.RequiredError(
				"pageSize",
				'Required parameter "pageSize" was null or undefined when calling listFunctionInstances().',
			);
		}

		const queryParameters: any = {};

		if (requestParameters.pageSize != null) {
			queryParameters.page_size = requestParameters.pageSize;
		}

		if (requestParameters.nextPageToken != null) {
			queryParameters.next_page_token = requestParameters.nextPageToken;
		}

		if (requestParameters.providerInstanceId != null) {
			queryParameters.provider_instance_id =
				requestParameters.providerInstanceId;
		}

		const headerParameters: runtime.HTTPHeaders = {};

		const urlPath = `/api/bridge/v1/function-instances`;

		const response = await this.request(
			{
				path: urlPath,
				method: "GET",
				headers: headerParameters,
				query: queryParameters,
			},
			initOverrides,
		);

		return new runtime.JSONApiResponse(response, (jsonValue) =>
			FunctionInstanceSerializedPaginatedResponseFromJSON(jsonValue),
		);
	}

	/**
	 * List all function instances with optional filtering by provider instance
	 * List function instances
	 */
	async listFunctionInstances(
		requestParameters: V1ApiListFunctionInstancesRequest,
		initOverrides?: RequestInit | runtime.InitOverrideFunction,
	): Promise<FunctionInstanceSerializedPaginatedResponse> {
		const response = await this.listFunctionInstancesRaw(
			requestParameters,
			initOverrides,
		);
		return await response.value();
	}

	/**
	 * List all MCP server instances with pagination
	 * List MCP server instances
	 */
	async listMcpServerInstancesRaw(
		requestParameters: V1ApiListMcpServerInstancesRequest,
		initOverrides?: RequestInit | runtime.InitOverrideFunction,
	): Promise<
		runtime.ApiResponse<McpServerInstanceSerializedWithFunctionsPaginatedResponse>
	> {
		if (requestParameters.pageSize == null) {
			throw new runtime.RequiredError(
				"pageSize",
				'Required parameter "pageSize" was null or undefined when calling listMcpServerInstances().',
			);
		}

		const queryParameters: any = {};

		if (requestParameters.pageSize != null) {
			queryParameters.page_size = requestParameters.pageSize;
		}

		if (requestParameters.nextPageToken != null) {
			queryParameters.next_page_token = requestParameters.nextPageToken;
		}

		const headerParameters: runtime.HTTPHeaders = {};

		const urlPath = `/api/bridge/v1/mcp-instance`;

		const response = await this.request(
			{
				path: urlPath,
				method: "GET",
				headers: headerParameters,
				query: queryParameters,
			},
			initOverrides,
		);

		return new runtime.JSONApiResponse(response, (jsonValue) =>
			McpServerInstanceSerializedWithFunctionsPaginatedResponseFromJSON(
				jsonValue,
			),
		);
	}

	/**
	 * List all MCP server instances with pagination
	 * List MCP server instances
	 */
	async listMcpServerInstances(
		requestParameters: V1ApiListMcpServerInstancesRequest,
		initOverrides?: RequestInit | runtime.InitOverrideFunction,
	): Promise<McpServerInstanceSerializedWithFunctionsPaginatedResponse> {
		const response = await this.listMcpServerInstancesRaw(
			requestParameters,
			initOverrides,
		);
		return await response.value();
	}

	/**
	 * List all provider instances with optional filtering by status and provider type
	 * List provider instances
	 */
	async listProviderInstancesRaw(
		requestParameters: V1ApiListProviderInstancesRequest,
		initOverrides?: RequestInit | runtime.InitOverrideFunction,
	): Promise<runtime.ApiResponse<ProviderInstanceListItemPaginatedResponse>> {
		if (requestParameters.pageSize == null) {
			throw new runtime.RequiredError(
				"pageSize",
				'Required parameter "pageSize" was null or undefined when calling listProviderInstances().',
			);
		}

		const queryParameters: any = {};

		if (requestParameters.pageSize != null) {
			queryParameters.page_size = requestParameters.pageSize;
		}

		if (requestParameters.nextPageToken != null) {
			queryParameters.next_page_token = requestParameters.nextPageToken;
		}

		if (requestParameters.status != null) {
			queryParameters.status = requestParameters.status;
		}

		if (requestParameters.providerControllerTypeId != null) {
			queryParameters.provider_controller_type_id =
				requestParameters.providerControllerTypeId;
		}

		const headerParameters: runtime.HTTPHeaders = {};

		const urlPath = `/api/bridge/v1/provider`;

		const response = await this.request(
			{
				path: urlPath,
				method: "GET",
				headers: headerParameters,
				query: queryParameters,
			},
			initOverrides,
		);

		return new runtime.JSONApiResponse(response, (jsonValue) =>
			ProviderInstanceListItemPaginatedResponseFromJSON(jsonValue),
		);
	}

	/**
	 * List all provider instances with optional filtering by status and provider type
	 * List provider instances
	 */
	async listProviderInstances(
		requestParameters: V1ApiListProviderInstancesRequest,
		initOverrides?: RequestInit | runtime.InitOverrideFunction,
	): Promise<ProviderInstanceListItemPaginatedResponse> {
		const response = await this.listProviderInstancesRaw(
			requestParameters,
			initOverrides,
		);
		return await response.value();
	}

	/**
	 * List provider instances grouped by their associated functions
	 * List providers by function
	 */
	async listProviderInstancesGroupedByFunctionRaw(
		requestParameters: V1ApiListProviderInstancesGroupedByFunctionRequest,
		initOverrides?: RequestInit | runtime.InitOverrideFunction,
	): Promise<runtime.ApiResponse<FunctionInstanceConfigPaginatedResponse>> {
		if (requestParameters.pageSize == null) {
			throw new runtime.RequiredError(
				"pageSize",
				'Required parameter "pageSize" was null or undefined when calling listProviderInstancesGroupedByFunction().',
			);
		}

		const queryParameters: any = {};

		if (requestParameters.nextPageToken != null) {
			queryParameters.next_page_token = requestParameters.nextPageToken;
		}

		if (requestParameters.pageSize != null) {
			queryParameters.page_size = requestParameters.pageSize;
		}

		if (requestParameters.providerControllerTypeId != null) {
			queryParameters.provider_controller_type_id =
				requestParameters.providerControllerTypeId;
		}

		if (requestParameters.functionCategory != null) {
			queryParameters.function_category = requestParameters.functionCategory;
		}

		const headerParameters: runtime.HTTPHeaders = {};

		const urlPath = `/api/bridge/v1/provider/grouped-by-function`;

		const response = await this.request(
			{
				path: urlPath,
				method: "GET",
				headers: headerParameters,
				query: queryParameters,
			},
			initOverrides,
		);

		return new runtime.JSONApiResponse(response, (jsonValue) =>
			FunctionInstanceConfigPaginatedResponseFromJSON(jsonValue),
		);
	}

	/**
	 * List provider instances grouped by their associated functions
	 * List providers by function
	 */
	async listProviderInstancesGroupedByFunction(
		requestParameters: V1ApiListProviderInstancesGroupedByFunctionRequest,
		initOverrides?: RequestInit | runtime.InitOverrideFunction,
	): Promise<FunctionInstanceConfigPaginatedResponse> {
		const response = await this.listProviderInstancesGroupedByFunctionRaw(
			requestParameters,
			initOverrides,
		);
		return await response.value();
	}

	/**
	 * List all secrets with pagination (values are encrypted)
	 * List secrets
	 */
	async listSecretsRaw(
		requestParameters: V1ApiListSecretsRequest,
		initOverrides?: RequestInit | runtime.InitOverrideFunction,
	): Promise<runtime.ApiResponse<ListSecretsResponse>> {
		if (requestParameters.pageSize == null) {
			throw new runtime.RequiredError(
				"pageSize",
				'Required parameter "pageSize" was null or undefined when calling listSecrets().',
			);
		}

		const queryParameters: any = {};

		if (requestParameters.pageSize != null) {
			queryParameters.page_size = requestParameters.pageSize;
		}

		if (requestParameters.nextPageToken != null) {
			queryParameters.next_page_token = requestParameters.nextPageToken;
		}

		const headerParameters: runtime.HTTPHeaders = {};

		const urlPath = `/api/secret/v1`;

		const response = await this.request(
			{
				path: urlPath,
				method: "GET",
				headers: headerParameters,
				query: queryParameters,
			},
			initOverrides,
		);

		return new runtime.JSONApiResponse(response, (jsonValue) =>
			ListSecretsResponseFromJSON(jsonValue),
		);
	}

	/**
	 * List all secrets with pagination (values are encrypted)
	 * List secrets
	 */
	async listSecrets(
		requestParameters: V1ApiListSecretsRequest,
		initOverrides?: RequestInit | runtime.InitOverrideFunction,
	): Promise<ListSecretsResponse> {
		const response = await this.listSecretsRaw(
			requestParameters,
			initOverrides,
		);
		return await response.value();
	}

	/**
	 * List all tasks with pagination
	 * List tasks
	 */
	async listTasksRaw(
		requestParameters: V1ApiListTasksRequest,
		initOverrides?: RequestInit | runtime.InitOverrideFunction,
	): Promise<runtime.ApiResponse<TaskPaginatedResponse>> {
		if (requestParameters.pageSize == null) {
			throw new runtime.RequiredError(
				"pageSize",
				'Required parameter "pageSize" was null or undefined when calling listTasks().',
			);
		}

		const queryParameters: any = {};

		if (requestParameters.pageSize != null) {
			queryParameters.page_size = requestParameters.pageSize;
		}

		if (requestParameters.nextPageToken != null) {
			queryParameters.next_page_token = requestParameters.nextPageToken;
		}

		const headerParameters: runtime.HTTPHeaders = {};

		const urlPath = `/api/task/v1`;

		const response = await this.request(
			{
				path: urlPath,
				method: "GET",
				headers: headerParameters,
				query: queryParameters,
			},
			initOverrides,
		);

		return new runtime.JSONApiResponse(response, (jsonValue) =>
			TaskPaginatedResponseFromJSON(jsonValue),
		);
	}

	/**
	 * List all tasks with pagination
	 * List tasks
	 */
	async listTasks(
		requestParameters: V1ApiListTasksRequest,
		initOverrides?: RequestInit | runtime.InitOverrideFunction,
	): Promise<TaskPaginatedResponse> {
		const response = await this.listTasksRaw(requestParameters, initOverrides);
		return await response.value();
	}

	/**
	 * List all tasks for a specific context ID with pagination
	 * List tasks by context
	 */
	async listTasksByContextIdRaw(
		requestParameters: V1ApiListTasksByContextIdRequest,
		initOverrides?: RequestInit | runtime.InitOverrideFunction,
	): Promise<runtime.ApiResponse<TaskPaginatedResponse>> {
		if (requestParameters.pageSize == null) {
			throw new runtime.RequiredError(
				"pageSize",
				'Required parameter "pageSize" was null or undefined when calling listTasksByContextId().',
			);
		}

		if (requestParameters.contextId == null) {
			throw new runtime.RequiredError(
				"contextId",
				'Required parameter "contextId" was null or undefined when calling listTasksByContextId().',
			);
		}

		const queryParameters: any = {};

		if (requestParameters.pageSize != null) {
			queryParameters.page_size = requestParameters.pageSize;
		}

		if (requestParameters.nextPageToken != null) {
			queryParameters.next_page_token = requestParameters.nextPageToken;
		}

		const headerParameters: runtime.HTTPHeaders = {};

		let urlPath = `/api/task/v1/context/{context_id}/task`;
		urlPath = urlPath.replace(
			`{${"context_id"}}`,
			encodeURIComponent(String(requestParameters.contextId)),
		);

		const response = await this.request(
			{
				path: urlPath,
				method: "GET",
				headers: headerParameters,
				query: queryParameters,
			},
			initOverrides,
		);

		return new runtime.JSONApiResponse(response, (jsonValue) =>
			TaskPaginatedResponseFromJSON(jsonValue),
		);
	}

	/**
	 * List all tasks for a specific context ID with pagination
	 * List tasks by context
	 */
	async listTasksByContextId(
		requestParameters: V1ApiListTasksByContextIdRequest,
		initOverrides?: RequestInit | runtime.InitOverrideFunction,
	): Promise<TaskPaginatedResponse> {
		const response = await this.listTasksByContextIdRaw(
			requestParameters,
			initOverrides,
		);
		return await response.value();
	}

	/**
	 * Migrate all data encryption keys encrypted with the specified envelope key to a new envelope key
	 * Migrate all data keys
	 */
	async migrateAllDataEncryptionKeysRaw(
		requestParameters: V1ApiMigrateAllDataEncryptionKeysRequest,
		initOverrides?: RequestInit | runtime.InitOverrideFunction,
	): Promise<runtime.ApiResponse<void>> {
		if (requestParameters.envelopeId == null) {
			throw new runtime.RequiredError(
				"envelopeId",
				'Required parameter "envelopeId" was null or undefined when calling migrateAllDataEncryptionKeys().',
			);
		}

		if (requestParameters.migrateAllDataEncryptionKeysParamsRoute == null) {
			throw new runtime.RequiredError(
				"migrateAllDataEncryptionKeysParamsRoute",
				'Required parameter "migrateAllDataEncryptionKeysParamsRoute" was null or undefined when calling migrateAllDataEncryptionKeys().',
			);
		}

		const queryParameters: any = {};

		const headerParameters: runtime.HTTPHeaders = {};

		headerParameters["Content-Type"] = "application/json";

		let urlPath = `/api/encryption/v1/envelope/{envelope_id}/migrate`;
		urlPath = urlPath.replace(
			`{${"envelope_id"}}`,
			encodeURIComponent(String(requestParameters.envelopeId)),
		);

		const response = await this.request(
			{
				path: urlPath,
				method: "POST",
				headers: headerParameters,
				query: queryParameters,
				body: MigrateAllDataEncryptionKeysParamsRouteToJSON(
					requestParameters.migrateAllDataEncryptionKeysParamsRoute,
				),
			},
			initOverrides,
		);

		return new runtime.VoidApiResponse(response);
	}

	/**
	 * Migrate all data encryption keys encrypted with the specified envelope key to a new envelope key
	 * Migrate all data keys
	 */
	async migrateAllDataEncryptionKeys(
		requestParameters: V1ApiMigrateAllDataEncryptionKeysRequest,
		initOverrides?: RequestInit | runtime.InitOverrideFunction,
	): Promise<void> {
		await this.migrateAllDataEncryptionKeysRaw(
			requestParameters,
			initOverrides,
		);
	}

	/**
	 * Migrate a data encryption key to be encrypted with a different envelope encryption key
	 * Migrate data key
	 */
	async migrateDataEncryptionKeyRaw(
		requestParameters: V1ApiMigrateDataEncryptionKeyRequest,
		initOverrides?: RequestInit | runtime.InitOverrideFunction,
	): Promise<runtime.ApiResponse<void>> {
		if (requestParameters.envelopeId == null) {
			throw new runtime.RequiredError(
				"envelopeId",
				'Required parameter "envelopeId" was null or undefined when calling migrateDataEncryptionKey().',
			);
		}

		if (requestParameters.dekId == null) {
			throw new runtime.RequiredError(
				"dekId",
				'Required parameter "dekId" was null or undefined when calling migrateDataEncryptionKey().',
			);
		}

		if (requestParameters.migrateDataEncryptionKeyParamsRoute == null) {
			throw new runtime.RequiredError(
				"migrateDataEncryptionKeyParamsRoute",
				'Required parameter "migrateDataEncryptionKeyParamsRoute" was null or undefined when calling migrateDataEncryptionKey().',
			);
		}

		const queryParameters: any = {};

		const headerParameters: runtime.HTTPHeaders = {};

		headerParameters["Content-Type"] = "application/json";

		let urlPath = `/api/encryption/v1/envelope/{envelope_id}/dek/{dek_id}/migrate`;
		urlPath = urlPath.replace(
			`{${"envelope_id"}}`,
			encodeURIComponent(String(requestParameters.envelopeId)),
		);
		urlPath = urlPath.replace(
			`{${"dek_id"}}`,
			encodeURIComponent(String(requestParameters.dekId)),
		);

		const response = await this.request(
			{
				path: urlPath,
				method: "POST",
				headers: headerParameters,
				query: queryParameters,
				body: MigrateDataEncryptionKeyParamsRouteToJSON(
					requestParameters.migrateDataEncryptionKeyParamsRoute,
				),
			},
			initOverrides,
		);

		return new runtime.VoidApiResponse(response);
	}

	/**
	 * Migrate a data encryption key to be encrypted with a different envelope encryption key
	 * Migrate data key
	 */
	async migrateDataEncryptionKey(
		requestParameters: V1ApiMigrateDataEncryptionKeyRequest,
		initOverrides?: RequestInit | runtime.InitOverrideFunction,
	): Promise<void> {
		await this.migrateDataEncryptionKeyRaw(requestParameters, initOverrides);
	}

	/**
	 * Remove a function mapping from an MCP server instance
	 * Remove function from MCP server instance
	 */
	async removeMcpServerInstanceFunctionRaw(
		requestParameters: V1ApiRemoveMcpServerInstanceFunctionRequest,
		initOverrides?: RequestInit | runtime.InitOverrideFunction,
	): Promise<runtime.ApiResponse<McpServerInstanceSerializedWithFunctions>> {
		if (requestParameters.mcpServerInstanceId == null) {
			throw new runtime.RequiredError(
				"mcpServerInstanceId",
				'Required parameter "mcpServerInstanceId" was null or undefined when calling removeMcpServerInstanceFunction().',
			);
		}

		if (requestParameters.functionControllerTypeId == null) {
			throw new runtime.RequiredError(
				"functionControllerTypeId",
				'Required parameter "functionControllerTypeId" was null or undefined when calling removeMcpServerInstanceFunction().',
			);
		}

		if (requestParameters.providerControllerTypeId == null) {
			throw new runtime.RequiredError(
				"providerControllerTypeId",
				'Required parameter "providerControllerTypeId" was null or undefined when calling removeMcpServerInstanceFunction().',
			);
		}

		if (requestParameters.providerInstanceId == null) {
			throw new runtime.RequiredError(
				"providerInstanceId",
				'Required parameter "providerInstanceId" was null or undefined when calling removeMcpServerInstanceFunction().',
			);
		}

		const queryParameters: any = {};

		const headerParameters: runtime.HTTPHeaders = {};

		let urlPath = `/api/bridge/v1/mcp-instance/{mcp_server_instance_id}/function/{function_controller_type_id}/{provider_controller_type_id}/{provider_instance_id}`;
		urlPath = urlPath.replace(
			`{${"mcp_server_instance_id"}}`,
			encodeURIComponent(String(requestParameters.mcpServerInstanceId)),
		);
		urlPath = urlPath.replace(
			`{${"function_controller_type_id"}}`,
			encodeURIComponent(String(requestParameters.functionControllerTypeId)),
		);
		urlPath = urlPath.replace(
			`{${"provider_controller_type_id"}}`,
			encodeURIComponent(String(requestParameters.providerControllerTypeId)),
		);
		urlPath = urlPath.replace(
			`{${"provider_instance_id"}}`,
			encodeURIComponent(String(requestParameters.providerInstanceId)),
		);

		const response = await this.request(
			{
				path: urlPath,
				method: "DELETE",
				headers: headerParameters,
				query: queryParameters,
			},
			initOverrides,
		);

		return new runtime.JSONApiResponse(response, (jsonValue) =>
			McpServerInstanceSerializedWithFunctionsFromJSON(jsonValue),
		);
	}

	/**
	 * Remove a function mapping from an MCP server instance
	 * Remove function from MCP server instance
	 */
	async removeMcpServerInstanceFunction(
		requestParameters: V1ApiRemoveMcpServerInstanceFunctionRequest,
		initOverrides?: RequestInit | runtime.InitOverrideFunction,
	): Promise<McpServerInstanceSerializedWithFunctions> {
		const response = await this.removeMcpServerInstanceFunctionRaw(
			requestParameters,
			initOverrides,
		);
		return await response.value();
	}

	/**
	 * Handle OAuth callback to complete user credential brokering flow
	 * OAuth callback
	 */
	async resumeUserCredentialBrokeringRaw(
		requestParameters: V1ApiResumeUserCredentialBrokeringRequest,
		initOverrides?: RequestInit | runtime.InitOverrideFunction,
	): Promise<runtime.ApiResponse<UserCredentialBrokeringResponse>> {
		const queryParameters: any = {};

		if (requestParameters.state != null) {
			queryParameters.state = requestParameters.state;
		}

		if (requestParameters.code != null) {
			queryParameters.code = requestParameters.code;
		}

		if (requestParameters.error != null) {
			queryParameters.error = requestParameters.error;
		}

		if (requestParameters.errorDescription != null) {
			queryParameters.error_description = requestParameters.errorDescription;
		}

		const headerParameters: runtime.HTTPHeaders = {};

		const urlPath = `/api/bridge/v1/generic-oauth-callback`;

		const response = await this.request(
			{
				path: urlPath,
				method: "GET",
				headers: headerParameters,
				query: queryParameters,
			},
			initOverrides,
		);

		return new runtime.JSONApiResponse(response, (jsonValue) =>
			UserCredentialBrokeringResponseFromJSON(jsonValue),
		);
	}

	/**
	 * Handle OAuth callback to complete user credential brokering flow
	 * OAuth callback
	 */
	async resumeUserCredentialBrokering(
		requestParameters: V1ApiResumeUserCredentialBrokeringRequest = {},
		initOverrides?: RequestInit | runtime.InitOverrideFunction,
	): Promise<UserCredentialBrokeringResponse> {
		const response = await this.resumeUserCredentialBrokeringRaw(
			requestParameters,
			initOverrides,
		);
		return await response.value();
	}

	/**
	 * Resync providers, agents, secrets, and environment variables between API server and SDK
	 * Resync SDK
	 */
	async resyncSdkRaw(
		initOverrides?: RequestInit | runtime.InitOverrideFunction,
	): Promise<runtime.ApiResponse<object>> {
		const queryParameters: any = {};

		const headerParameters: runtime.HTTPHeaders = {};

		const urlPath = `/_internal/v1/resync_sdk`;

		const response = await this.request(
			{
				path: urlPath,
				method: "POST",
				headers: headerParameters,
				query: queryParameters,
			},
			initOverrides,
		);

		return new runtime.JSONApiResponse<any>(response);
	}

	/**
	 * Resync providers, agents, secrets, and environment variables between API server and SDK
	 * Resync SDK
	 */
	async resyncSdk(
		initOverrides?: RequestInit | runtime.InitOverrideFunction,
	): Promise<object> {
		const response = await this.resyncSdkRaw(initOverrides);
		return await response.value();
	}

	/**
	 * Handles the OAuth/OIDC callback from the external IdP, exchanges the authorization code for tokens
	 * Authorization callback
	 */
	async routeAuthCallbackRaw(
		requestParameters: V1ApiRouteAuthCallbackRequest,
		initOverrides?: RequestInit | runtime.InitOverrideFunction,
	): Promise<runtime.ApiResponse<void>> {
		const queryParameters: any = {};

		if (requestParameters.code != null) {
			queryParameters.code = requestParameters.code;
		}

		if (requestParameters.state != null) {
			queryParameters.state = requestParameters.state;
		}

		if (requestParameters.error != null) {
			queryParameters.error = requestParameters.error;
		}

		if (requestParameters.errorDescription != null) {
			queryParameters.error_description = requestParameters.errorDescription;
		}

		const headerParameters: runtime.HTTPHeaders = {};

		const urlPath = `/api/identity/v1/auth/callback`;

		const response = await this.request(
			{
				path: urlPath,
				method: "GET",
				headers: headerParameters,
				query: queryParameters,
			},
			initOverrides,
		);

		return new runtime.VoidApiResponse(response);
	}

	/**
	 * Handles the OAuth/OIDC callback from the external IdP, exchanges the authorization code for tokens
	 * Authorization callback
	 */
	async routeAuthCallback(
		requestParameters: V1ApiRouteAuthCallbackRequest = {},
		initOverrides?: RequestInit | runtime.InitOverrideFunction,
	): Promise<void> {
		await this.routeAuthCallbackRaw(requestParameters, initOverrides);
	}

	/**
	 */
	async routeCreateApiKeyRaw(
		requestParameters: V1ApiRouteCreateApiKeyRequest,
		initOverrides?: RequestInit | runtime.InitOverrideFunction,
	): Promise<runtime.ApiResponse<CreateApiKeyResponse>> {
		if (requestParameters.createApiKeyParams == null) {
			throw new runtime.RequiredError(
				"createApiKeyParams",
				'Required parameter "createApiKeyParams" was null or undefined when calling routeCreateApiKey().',
			);
		}

		const queryParameters: any = {};

		const headerParameters: runtime.HTTPHeaders = {};

		headerParameters["Content-Type"] = "application/json";

		const urlPath = `/api/identity/v1/api-key`;

		const response = await this.request(
			{
				path: urlPath,
				method: "POST",
				headers: headerParameters,
				query: queryParameters,
				body: CreateApiKeyParamsToJSON(requestParameters.createApiKeyParams),
			},
			initOverrides,
		);

		return new runtime.JSONApiResponse(response, (jsonValue) =>
			CreateApiKeyResponseFromJSON(jsonValue),
		);
	}

	/**
	 */
	async routeCreateApiKey(
		requestParameters: V1ApiRouteCreateApiKeyRequest,
		initOverrides?: RequestInit | runtime.InitOverrideFunction,
	): Promise<CreateApiKeyResponse> {
		const response = await this.routeCreateApiKeyRaw(
			requestParameters,
			initOverrides,
		);
		return await response.value();
	}

	/**
	 * Create a new STS configuration (e.g., JWT template or dev settings)
	 * Create STS configuration
	 */
	async routeCreateStsConfigRaw(
		requestParameters: V1ApiRouteCreateStsConfigRequest,
		initOverrides?: RequestInit | runtime.InitOverrideFunction,
	): Promise<runtime.ApiResponse<StsTokenConfig>> {
		if (requestParameters.stsTokenConfig == null) {
			throw new runtime.RequiredError(
				"stsTokenConfig",
				'Required parameter "stsTokenConfig" was null or undefined when calling routeCreateStsConfig().',
			);
		}

		const queryParameters: any = {};

		const headerParameters: runtime.HTTPHeaders = {};

		headerParameters["Content-Type"] = "application/json";

		const urlPath = `/api/identity/v1/sts-configuration`;

		const response = await this.request(
			{
				path: urlPath,
				method: "POST",
				headers: headerParameters,
				query: queryParameters,
				body: StsTokenConfigToJSON(requestParameters.stsTokenConfig),
			},
			initOverrides,
		);

		return new runtime.JSONApiResponse(response, (jsonValue) =>
			StsTokenConfigFromJSON(jsonValue),
		);
	}

	/**
	 * Create a new STS configuration (e.g., JWT template or dev settings)
	 * Create STS configuration
	 */
	async routeCreateStsConfig(
		requestParameters: V1ApiRouteCreateStsConfigRequest,
		initOverrides?: RequestInit | runtime.InitOverrideFunction,
	): Promise<StsTokenConfig> {
		const response = await this.routeCreateStsConfigRaw(
			requestParameters,
			initOverrides,
		);
		return await response.value();
	}

	/**
	 * Create a new user auth flow configuration for OAuth/OIDC authorization flows. The configuration will be encrypted before storage.
	 * Create user auth flow configuration
	 */
	async routeCreateUserAuthFlowConfigRaw(
		requestParameters: V1ApiRouteCreateUserAuthFlowConfigRequest,
		initOverrides?: RequestInit | runtime.InitOverrideFunction,
	): Promise<runtime.ApiResponse<CreateUserAuthFlowConfigResponse>> {
		if (requestParameters.createUserAuthFlowConfigParams == null) {
			throw new runtime.RequiredError(
				"createUserAuthFlowConfigParams",
				'Required parameter "createUserAuthFlowConfigParams" was null or undefined when calling routeCreateUserAuthFlowConfig().',
			);
		}

		const queryParameters: any = {};

		const headerParameters: runtime.HTTPHeaders = {};

		headerParameters["Content-Type"] = "application/json";

		const urlPath = `/api/identity/v1/user-auth-flow-config`;

		const response = await this.request(
			{
				path: urlPath,
				method: "POST",
				headers: headerParameters,
				query: queryParameters,
				body: CreateUserAuthFlowConfigParamsToJSON(
					requestParameters.createUserAuthFlowConfigParams,
				),
			},
			initOverrides,
		);

		return new runtime.JSONApiResponse(response, (jsonValue) =>
			CreateUserAuthFlowConfigResponseFromJSON(jsonValue),
		);
	}

	/**
	 * Create a new user auth flow configuration for OAuth/OIDC authorization flows. The configuration will be encrypted before storage.
	 * Create user auth flow configuration
	 */
	async routeCreateUserAuthFlowConfig(
		requestParameters: V1ApiRouteCreateUserAuthFlowConfigRequest,
		initOverrides?: RequestInit | runtime.InitOverrideFunction,
	): Promise<CreateUserAuthFlowConfigResponse> {
		const response = await this.routeCreateUserAuthFlowConfigRaw(
			requestParameters,
			initOverrides,
		);
		return await response.value();
	}

	/**
	 */
	async routeDeleteApiKeyRaw(
		requestParameters: V1ApiRouteDeleteApiKeyRequest,
		initOverrides?: RequestInit | runtime.InitOverrideFunction,
	): Promise<runtime.ApiResponse<any>> {
		if (requestParameters.id == null) {
			throw new runtime.RequiredError(
				"id",
				'Required parameter "id" was null or undefined when calling routeDeleteApiKey().',
			);
		}

		const queryParameters: any = {};

		const headerParameters: runtime.HTTPHeaders = {};

		let urlPath = `/api/identity/v1/api-key/{id}`;
		urlPath = urlPath.replace(
			`{${"id"}}`,
			encodeURIComponent(String(requestParameters.id)),
		);

		const response = await this.request(
			{
				path: urlPath,
				method: "DELETE",
				headers: headerParameters,
				query: queryParameters,
			},
			initOverrides,
		);

		if (this.isJsonMime(response.headers.get("content-type"))) {
			return new runtime.JSONApiResponse<any>(response);
		} else {
			return new runtime.TextApiResponse(response) as any;
		}
	}

	/**
	 */
	async routeDeleteApiKey(
		requestParameters: V1ApiRouteDeleteApiKeyRequest,
		initOverrides?: RequestInit | runtime.InitOverrideFunction,
	): Promise<any> {
		const response = await this.routeDeleteApiKeyRaw(
			requestParameters,
			initOverrides,
		);
		return await response.value();
	}

	/**
	 * Delete an STS configuration by ID
	 * Delete STS configuration
	 */
	async routeDeleteStsConfigRaw(
		requestParameters: V1ApiRouteDeleteStsConfigRequest,
		initOverrides?: RequestInit | runtime.InitOverrideFunction,
	): Promise<runtime.ApiResponse<any>> {
		if (requestParameters.id == null) {
			throw new runtime.RequiredError(
				"id",
				'Required parameter "id" was null or undefined when calling routeDeleteStsConfig().',
			);
		}

		const queryParameters: any = {};

		const headerParameters: runtime.HTTPHeaders = {};

		let urlPath = `/api/identity/v1/sts-configuration/{id}`;
		urlPath = urlPath.replace(
			`{${"id"}}`,
			encodeURIComponent(String(requestParameters.id)),
		);

		const response = await this.request(
			{
				path: urlPath,
				method: "DELETE",
				headers: headerParameters,
				query: queryParameters,
			},
			initOverrides,
		);

		if (this.isJsonMime(response.headers.get("content-type"))) {
			return new runtime.JSONApiResponse<any>(response);
		} else {
			return new runtime.TextApiResponse(response) as any;
		}
	}

	/**
	 * Delete an STS configuration by ID
	 * Delete STS configuration
	 */
	async routeDeleteStsConfig(
		requestParameters: V1ApiRouteDeleteStsConfigRequest,
		initOverrides?: RequestInit | runtime.InitOverrideFunction,
	): Promise<any> {
		const response = await this.routeDeleteStsConfigRaw(
			requestParameters,
			initOverrides,
		);
		return await response.value();
	}

	/**
	 * Delete a user auth flow configuration by ID
	 * Delete user auth flow configuration
	 */
	async routeDeleteUserAuthFlowConfigRaw(
		requestParameters: V1ApiRouteDeleteUserAuthFlowConfigRequest,
		initOverrides?: RequestInit | runtime.InitOverrideFunction,
	): Promise<runtime.ApiResponse<any>> {
		if (requestParameters.id == null) {
			throw new runtime.RequiredError(
				"id",
				'Required parameter "id" was null or undefined when calling routeDeleteUserAuthFlowConfig().',
			);
		}

		const queryParameters: any = {};

		const headerParameters: runtime.HTTPHeaders = {};

		let urlPath = `/api/identity/v1/user-auth-flow-config/{id}`;
		urlPath = urlPath.replace(
			`{${"id"}}`,
			encodeURIComponent(String(requestParameters.id)),
		);

		const response = await this.request(
			{
				path: urlPath,
				method: "DELETE",
				headers: headerParameters,
				query: queryParameters,
			},
			initOverrides,
		);

		if (this.isJsonMime(response.headers.get("content-type"))) {
			return new runtime.JSONApiResponse<any>(response);
		} else {
			return new runtime.TextApiResponse(response) as any;
		}
	}

	/**
	 * Delete a user auth flow configuration by ID
	 * Delete user auth flow configuration
	 */
	async routeDeleteUserAuthFlowConfig(
		requestParameters: V1ApiRouteDeleteUserAuthFlowConfigRequest,
		initOverrides?: RequestInit | runtime.InitOverrideFunction,
	): Promise<any> {
		const response = await this.routeDeleteUserAuthFlowConfigRaw(
			requestParameters,
			initOverrides,
		);
		return await response.value();
	}

	/**
	 * Exchange an external token for internal access and refresh tokens using an STS configuration
	 * Exchange STS token
	 */
	async routeExchangeStsTokenRaw(
		requestParameters: V1ApiRouteExchangeStsTokenRequest,
		initOverrides?: RequestInit | runtime.InitOverrideFunction,
	): Promise<runtime.ApiResponse<NormalizedTokenIssuanceResult>> {
		if (requestParameters.stsConfigId == null) {
			throw new runtime.RequiredError(
				"stsConfigId",
				'Required parameter "stsConfigId" was null or undefined when calling routeExchangeStsToken().',
			);
		}

		const queryParameters: any = {};

		const headerParameters: runtime.HTTPHeaders = {};

		let urlPath = `/api/identity/v1/sts/{sts_config_id}`;
		urlPath = urlPath.replace(
			`{${"sts_config_id"}}`,
			encodeURIComponent(String(requestParameters.stsConfigId)),
		);

		const response = await this.request(
			{
				path: urlPath,
				method: "POST",
				headers: headerParameters,
				query: queryParameters,
			},
			initOverrides,
		);

		return new runtime.JSONApiResponse(response, (jsonValue) =>
			NormalizedTokenIssuanceResultFromJSON(jsonValue),
		);
	}

	/**
	 * Exchange an external token for internal access and refresh tokens using an STS configuration
	 * Exchange STS token
	 */
	async routeExchangeStsToken(
		requestParameters: V1ApiRouteExchangeStsTokenRequest,
		initOverrides?: RequestInit | runtime.InitOverrideFunction,
	): Promise<NormalizedTokenIssuanceResult> {
		const response = await this.routeExchangeStsTokenRaw(
			requestParameters,
			initOverrides,
		);
		return await response.value();
	}

	/**
	 */
	async routeGetJwksRaw(
		initOverrides?: RequestInit | runtime.InitOverrideFunction,
	): Promise<runtime.ApiResponse<JwksResponse>> {
		const queryParameters: any = {};

		const headerParameters: runtime.HTTPHeaders = {};

		const urlPath = `/api/identity/v1/.well-known/jwks.json`;

		const response = await this.request(
			{
				path: urlPath,
				method: "GET",
				headers: headerParameters,
				query: queryParameters,
			},
			initOverrides,
		);

		return new runtime.JSONApiResponse(response, (jsonValue) =>
			JwksResponseFromJSON(jsonValue),
		);
	}

	/**
	 */
	async routeGetJwks(
		initOverrides?: RequestInit | runtime.InitOverrideFunction,
	): Promise<JwksResponse> {
		const response = await this.routeGetJwksRaw(initOverrides);
		return await response.value();
	}

	/**
	 * Get an STS configuration by ID
	 * Get STS configuration
	 */
	async routeGetStsConfigRaw(
		requestParameters: V1ApiRouteGetStsConfigRequest,
		initOverrides?: RequestInit | runtime.InitOverrideFunction,
	): Promise<runtime.ApiResponse<StsTokenConfig>> {
		if (requestParameters.id == null) {
			throw new runtime.RequiredError(
				"id",
				'Required parameter "id" was null or undefined when calling routeGetStsConfig().',
			);
		}

		const queryParameters: any = {};

		const headerParameters: runtime.HTTPHeaders = {};

		let urlPath = `/api/identity/v1/sts-configuration/{id}`;
		urlPath = urlPath.replace(
			`{${"id"}}`,
			encodeURIComponent(String(requestParameters.id)),
		);

		const response = await this.request(
			{
				path: urlPath,
				method: "GET",
				headers: headerParameters,
				query: queryParameters,
			},
			initOverrides,
		);

		return new runtime.JSONApiResponse(response, (jsonValue) =>
			StsTokenConfigFromJSON(jsonValue),
		);
	}

	/**
	 * Get an STS configuration by ID
	 * Get STS configuration
	 */
	async routeGetStsConfig(
		requestParameters: V1ApiRouteGetStsConfigRequest,
		initOverrides?: RequestInit | runtime.InitOverrideFunction,
	): Promise<StsTokenConfig> {
		const response = await this.routeGetStsConfigRaw(
			requestParameters,
			initOverrides,
		);
		return await response.value();
	}

	/**
	 * Get a user auth flow configuration by ID. Returns the encrypted configuration.
	 * Get user auth flow configuration
	 */
	async routeGetUserAuthFlowConfigRaw(
		requestParameters: V1ApiRouteGetUserAuthFlowConfigRequest,
		initOverrides?: RequestInit | runtime.InitOverrideFunction,
	): Promise<runtime.ApiResponse<GetUserAuthFlowConfigResponse>> {
		if (requestParameters.id == null) {
			throw new runtime.RequiredError(
				"id",
				'Required parameter "id" was null or undefined when calling routeGetUserAuthFlowConfig().',
			);
		}

		const queryParameters: any = {};

		const headerParameters: runtime.HTTPHeaders = {};

		let urlPath = `/api/identity/v1/user-auth-flow-config/{id}`;
		urlPath = urlPath.replace(
			`{${"id"}}`,
			encodeURIComponent(String(requestParameters.id)),
		);

		const response = await this.request(
			{
				path: urlPath,
				method: "GET",
				headers: headerParameters,
				query: queryParameters,
			},
			initOverrides,
		);

		return new runtime.JSONApiResponse(response, (jsonValue) =>
			GetUserAuthFlowConfigResponseFromJSON(jsonValue),
		);
	}

	/**
	 * Get a user auth flow configuration by ID. Returns the encrypted configuration.
	 * Get user auth flow configuration
	 */
	async routeGetUserAuthFlowConfig(
		requestParameters: V1ApiRouteGetUserAuthFlowConfigRequest,
		initOverrides?: RequestInit | runtime.InitOverrideFunction,
	): Promise<GetUserAuthFlowConfigResponse> {
		const response = await this.routeGetUserAuthFlowConfigRaw(
			requestParameters,
			initOverrides,
		);
		return await response.value();
	}

	/**
	 */
	async routeImportApiKeyRaw(
		requestParameters: V1ApiRouteImportApiKeyRequest,
		initOverrides?: RequestInit | runtime.InitOverrideFunction,
	): Promise<runtime.ApiResponse<any>> {
		if (requestParameters.encryptedApiKeyConfig == null) {
			throw new runtime.RequiredError(
				"encryptedApiKeyConfig",
				'Required parameter "encryptedApiKeyConfig" was null or undefined when calling routeImportApiKey().',
			);
		}

		const queryParameters: any = {};

		const headerParameters: runtime.HTTPHeaders = {};

		headerParameters["Content-Type"] = "application/json";

		const urlPath = `/api/identity/v1/api-key/import`;

		const response = await this.request(
			{
				path: urlPath,
				method: "POST",
				headers: headerParameters,
				query: queryParameters,
				body: EncryptedApiKeyConfigToJSON(
					requestParameters.encryptedApiKeyConfig,
				),
			},
			initOverrides,
		);

		if (this.isJsonMime(response.headers.get("content-type"))) {
			return new runtime.JSONApiResponse<any>(response);
		} else {
			return new runtime.TextApiResponse(response) as any;
		}
	}

	/**
	 */
	async routeImportApiKey(
		requestParameters: V1ApiRouteImportApiKeyRequest,
		initOverrides?: RequestInit | runtime.InitOverrideFunction,
	): Promise<any> {
		const response = await this.routeImportApiKeyRaw(
			requestParameters,
			initOverrides,
		);
		return await response.value();
	}

	/**
	 * Import an already encrypted user auth flow configuration (idempotent, used for syncing from soma.yaml)
	 * Import user auth flow configuration
	 */
	async routeImportUserAuthFlowConfigRaw(
		requestParameters: V1ApiRouteImportUserAuthFlowConfigRequest,
		initOverrides?: RequestInit | runtime.InitOverrideFunction,
	): Promise<runtime.ApiResponse<any>> {
		if (requestParameters.importUserAuthFlowConfigParams == null) {
			throw new runtime.RequiredError(
				"importUserAuthFlowConfigParams",
				'Required parameter "importUserAuthFlowConfigParams" was null or undefined when calling routeImportUserAuthFlowConfig().',
			);
		}

		const queryParameters: any = {};

		const headerParameters: runtime.HTTPHeaders = {};

		headerParameters["Content-Type"] = "application/json";

		const urlPath = `/api/identity/v1/user-auth-flow-config/import`;

		const response = await this.request(
			{
				path: urlPath,
				method: "POST",
				headers: headerParameters,
				query: queryParameters,
				body: ImportUserAuthFlowConfigParamsToJSON(
					requestParameters.importUserAuthFlowConfigParams,
				),
			},
			initOverrides,
		);

		if (this.isJsonMime(response.headers.get("content-type"))) {
			return new runtime.JSONApiResponse<any>(response);
		} else {
			return new runtime.TextApiResponse(response) as any;
		}
	}

	/**
	 * Import an already encrypted user auth flow configuration (idempotent, used for syncing from soma.yaml)
	 * Import user auth flow configuration
	 */
	async routeImportUserAuthFlowConfig(
		requestParameters: V1ApiRouteImportUserAuthFlowConfigRequest,
		initOverrides?: RequestInit | runtime.InitOverrideFunction,
	): Promise<any> {
		const response = await this.routeImportUserAuthFlowConfigRaw(
			requestParameters,
			initOverrides,
		);
		return await response.value();
	}

	/**
	 */
	async routeInvalidateJwkRaw(
		requestParameters: V1ApiRouteInvalidateJwkRequest,
		initOverrides?: RequestInit | runtime.InitOverrideFunction,
	): Promise<runtime.ApiResponse<void>> {
		if (requestParameters.kid == null) {
			throw new runtime.RequiredError(
				"kid",
				'Required parameter "kid" was null or undefined when calling routeInvalidateJwk().',
			);
		}

		const queryParameters: any = {};

		const headerParameters: runtime.HTTPHeaders = {};

		let urlPath = `/api/identity/v1/jwk/{kid}/invalidate`;
		urlPath = urlPath.replace(
			`{${"kid"}}`,
			encodeURIComponent(String(requestParameters.kid)),
		);

		const response = await this.request(
			{
				path: urlPath,
				method: "POST",
				headers: headerParameters,
				query: queryParameters,
			},
			initOverrides,
		);

		return new runtime.VoidApiResponse(response);
	}

	/**
	 */
	async routeInvalidateJwk(
		requestParameters: V1ApiRouteInvalidateJwkRequest,
		initOverrides?: RequestInit | runtime.InitOverrideFunction,
	): Promise<void> {
		await this.routeInvalidateJwkRaw(requestParameters, initOverrides);
	}

	/**
	 */
	async routeListApiKeysRaw(
		requestParameters: V1ApiRouteListApiKeysRequest,
		initOverrides?: RequestInit | runtime.InitOverrideFunction,
	): Promise<runtime.ApiResponse<ListApiKeysResponse>> {
		if (requestParameters.pageSize == null) {
			throw new runtime.RequiredError(
				"pageSize",
				'Required parameter "pageSize" was null or undefined when calling routeListApiKeys().',
			);
		}

		const queryParameters: any = {};

		if (requestParameters.pageSize != null) {
			queryParameters.page_size = requestParameters.pageSize;
		}

		if (requestParameters.nextPageToken != null) {
			queryParameters.next_page_token = requestParameters.nextPageToken;
		}

		const headerParameters: runtime.HTTPHeaders = {};

		const urlPath = `/api/identity/v1/api-key`;

		const response = await this.request(
			{
				path: urlPath,
				method: "GET",
				headers: headerParameters,
				query: queryParameters,
			},
			initOverrides,
		);

		return new runtime.JSONApiResponse(response, (jsonValue) =>
			ListApiKeysResponseFromJSON(jsonValue),
		);
	}

	/**
	 */
	async routeListApiKeys(
		requestParameters: V1ApiRouteListApiKeysRequest,
		initOverrides?: RequestInit | runtime.InitOverrideFunction,
	): Promise<ListApiKeysResponse> {
		const response = await this.routeListApiKeysRaw(
			requestParameters,
			initOverrides,
		);
		return await response.value();
	}

	/**
	 */
	async routeListJwksRaw(
		requestParameters: V1ApiRouteListJwksRequest,
		initOverrides?: RequestInit | runtime.InitOverrideFunction,
	): Promise<runtime.ApiResponse<JwkResponsePaginatedResponse>> {
		if (requestParameters.pageSize == null) {
			throw new runtime.RequiredError(
				"pageSize",
				'Required parameter "pageSize" was null or undefined when calling routeListJwks().',
			);
		}

		const queryParameters: any = {};

		if (requestParameters.pageSize != null) {
			queryParameters.page_size = requestParameters.pageSize;
		}

		if (requestParameters.nextPageToken != null) {
			queryParameters.next_page_token = requestParameters.nextPageToken;
		}

		const headerParameters: runtime.HTTPHeaders = {};

		const urlPath = `/api/identity/v1/jwk`;

		const response = await this.request(
			{
				path: urlPath,
				method: "GET",
				headers: headerParameters,
				query: queryParameters,
			},
			initOverrides,
		);

		return new runtime.JSONApiResponse(response, (jsonValue) =>
			JwkResponsePaginatedResponseFromJSON(jsonValue),
		);
	}

	/**
	 */
	async routeListJwks(
		requestParameters: V1ApiRouteListJwksRequest,
		initOverrides?: RequestInit | runtime.InitOverrideFunction,
	): Promise<JwkResponsePaginatedResponse> {
		const response = await this.routeListJwksRaw(
			requestParameters,
			initOverrides,
		);
		return await response.value();
	}

	/**
	 * List all STS configurations with optional filtering by type
	 * List STS configurations
	 */
	async routeListStsConfigsRaw(
		requestParameters: V1ApiRouteListStsConfigsRequest,
		initOverrides?: RequestInit | runtime.InitOverrideFunction,
	): Promise<runtime.ApiResponse<StsTokenConfigPaginatedResponse>> {
		if (requestParameters.pageSize == null) {
			throw new runtime.RequiredError(
				"pageSize",
				'Required parameter "pageSize" was null or undefined when calling routeListStsConfigs().',
			);
		}

		const queryParameters: any = {};

		if (requestParameters.pageSize != null) {
			queryParameters.page_size = requestParameters.pageSize;
		}

		if (requestParameters.nextPageToken != null) {
			queryParameters.next_page_token = requestParameters.nextPageToken;
		}

		const headerParameters: runtime.HTTPHeaders = {};

		const urlPath = `/api/identity/v1/sts-configuration`;

		const response = await this.request(
			{
				path: urlPath,
				method: "GET",
				headers: headerParameters,
				query: queryParameters,
			},
			initOverrides,
		);

		return new runtime.JSONApiResponse(response, (jsonValue) =>
			StsTokenConfigPaginatedResponseFromJSON(jsonValue),
		);
	}

	/**
	 * List all STS configurations with optional filtering by type
	 * List STS configurations
	 */
	async routeListStsConfigs(
		requestParameters: V1ApiRouteListStsConfigsRequest,
		initOverrides?: RequestInit | runtime.InitOverrideFunction,
	): Promise<StsTokenConfigPaginatedResponse> {
		const response = await this.routeListStsConfigsRaw(
			requestParameters,
			initOverrides,
		);
		return await response.value();
	}

	/**
	 * List all user auth flow configurations with optional filtering by type
	 * List user auth flow configurations
	 */
	async routeListUserAuthFlowConfigsRaw(
		requestParameters: V1ApiRouteListUserAuthFlowConfigsRequest,
		initOverrides?: RequestInit | runtime.InitOverrideFunction,
	): Promise<runtime.ApiResponse<ListUserAuthFlowConfigResponse>> {
		const queryParameters: any = {};

		if (requestParameters.pageSize != null) {
			queryParameters.page_size = requestParameters.pageSize;
		}

		if (requestParameters.nextPageToken != null) {
			queryParameters.next_page_token = requestParameters.nextPageToken;
		}

		if (requestParameters.type != null) {
			queryParameters.type = requestParameters.type;
		}

		const headerParameters: runtime.HTTPHeaders = {};

		const urlPath = `/api/identity/v1/user-auth-flow-config`;

		const response = await this.request(
			{
				path: urlPath,
				method: "GET",
				headers: headerParameters,
				query: queryParameters,
			},
			initOverrides,
		);

		return new runtime.JSONApiResponse(response, (jsonValue) =>
			ListUserAuthFlowConfigResponseFromJSON(jsonValue),
		);
	}

	/**
	 * List all user auth flow configurations with optional filtering by type
	 * List user auth flow configurations
	 */
	async routeListUserAuthFlowConfigs(
		requestParameters: V1ApiRouteListUserAuthFlowConfigsRequest = {},
		initOverrides?: RequestInit | runtime.InitOverrideFunction,
	): Promise<ListUserAuthFlowConfigResponse> {
		const response = await this.routeListUserAuthFlowConfigsRaw(
			requestParameters,
			initOverrides,
		);
		return await response.value();
	}

	/**
	 * Refreshes an access token using a refresh token from the request body or cookie
	 * Refresh access token
	 */
	async routeRefreshTokenRaw(
		requestParameters: V1ApiRouteRefreshTokenRequest,
		initOverrides?: RequestInit | runtime.InitOverrideFunction,
	): Promise<runtime.ApiResponse<TokenResponse>> {
		const queryParameters: any = {};

		const headerParameters: runtime.HTTPHeaders = {};

		headerParameters["Content-Type"] = "application/json";

		const urlPath = `/api/identity/v1/auth/refresh`;

		const response = await this.request(
			{
				path: urlPath,
				method: "POST",
				headers: headerParameters,
				query: queryParameters,
				body: RefreshTokenRequestToJSON(requestParameters.refreshTokenRequest),
			},
			initOverrides,
		);

		return new runtime.JSONApiResponse(response, (jsonValue) =>
			TokenResponseFromJSON(jsonValue),
		);
	}

	/**
	 * Refreshes an access token using a refresh token from the request body or cookie
	 * Refresh access token
	 */
	async routeRefreshToken(
		requestParameters: V1ApiRouteRefreshTokenRequest = {},
		initOverrides?: RequestInit | runtime.InitOverrideFunction,
	): Promise<TokenResponse> {
		const response = await this.routeRefreshTokenRaw(
			requestParameters,
			initOverrides,
		);
		return await response.value();
	}

	/**
	 * Initiates the OAuth/OIDC authorization flow by redirecting to the external IdP
	 * Start authorization
	 */
	async routeStartAuthorizationRaw(
		requestParameters: V1ApiRouteStartAuthorizationRequest,
		initOverrides?: RequestInit | runtime.InitOverrideFunction,
	): Promise<runtime.ApiResponse<void>> {
		if (requestParameters.configId == null) {
			throw new runtime.RequiredError(
				"configId",
				'Required parameter "configId" was null or undefined when calling routeStartAuthorization().',
			);
		}

		const queryParameters: any = {};

		if (requestParameters.redirectAfterLogin != null) {
			queryParameters.redirect_after_login =
				requestParameters.redirectAfterLogin;
		}

		const headerParameters: runtime.HTTPHeaders = {};

		let urlPath = `/api/identity/v1/auth/authorize/{config_id}`;
		urlPath = urlPath.replace(
			`{${"config_id"}}`,
			encodeURIComponent(String(requestParameters.configId)),
		);

		const response = await this.request(
			{
				path: urlPath,
				method: "GET",
				headers: headerParameters,
				query: queryParameters,
			},
			initOverrides,
		);

		return new runtime.VoidApiResponse(response);
	}

	/**
	 * Initiates the OAuth/OIDC authorization flow by redirecting to the external IdP
	 * Start authorization
	 */
	async routeStartAuthorization(
		requestParameters: V1ApiRouteStartAuthorizationRequest,
		initOverrides?: RequestInit | runtime.InitOverrideFunction,
	): Promise<void> {
		await this.routeStartAuthorizationRaw(requestParameters, initOverrides);
	}

	/**
	 * Returns the current authenticated identity based on the request headers (Authorization header, cookies, or API key)
	 * Get current identity
	 */
	async routeWhoamiRaw(
		initOverrides?: RequestInit | runtime.InitOverrideFunction,
	): Promise<runtime.ApiResponse<Identity>> {
		const queryParameters: any = {};

		const headerParameters: runtime.HTTPHeaders = {};

		const urlPath = `/api/identity/v1/auth/whoami`;

		const response = await this.request(
			{
				path: urlPath,
				method: "GET",
				headers: headerParameters,
				query: queryParameters,
			},
			initOverrides,
		);

		return new runtime.JSONApiResponse(response, (jsonValue) =>
			IdentityFromJSON(jsonValue),
		);
	}

	/**
	 * Returns the current authenticated identity based on the request headers (Authorization header, cookies, or API key)
	 * Get current identity
	 */
	async routeWhoami(
		initOverrides?: RequestInit | runtime.InitOverrideFunction,
	): Promise<Identity> {
		const response = await this.routeWhoamiRaw(initOverrides);
		return await response.value();
	}

	/**
	 * Send a message to a task
	 * Send message
	 */
	async sendMessageRaw(
		requestParameters: V1ApiSendMessageRequest,
		initOverrides?: RequestInit | runtime.InitOverrideFunction,
	): Promise<runtime.ApiResponse<CreateMessageResponse>> {
		if (requestParameters.taskId == null) {
			throw new runtime.RequiredError(
				"taskId",
				'Required parameter "taskId" was null or undefined when calling sendMessage().',
			);
		}

		if (requestParameters.createMessageRequest == null) {
			throw new runtime.RequiredError(
				"createMessageRequest",
				'Required parameter "createMessageRequest" was null or undefined when calling sendMessage().',
			);
		}

		const queryParameters: any = {};

		const headerParameters: runtime.HTTPHeaders = {};

		headerParameters["Content-Type"] = "application/json";

		let urlPath = `/api/task/v1/{task_id}/message`;
		urlPath = urlPath.replace(
			`{${"task_id"}}`,
			encodeURIComponent(String(requestParameters.taskId)),
		);

		const response = await this.request(
			{
				path: urlPath,
				method: "POST",
				headers: headerParameters,
				query: queryParameters,
				body: CreateMessageRequestToJSON(
					requestParameters.createMessageRequest,
				),
			},
			initOverrides,
		);

		return new runtime.JSONApiResponse(response, (jsonValue) =>
			CreateMessageResponseFromJSON(jsonValue),
		);
	}

	/**
	 * Send a message to a task
	 * Send message
	 */
	async sendMessage(
		requestParameters: V1ApiSendMessageRequest,
		initOverrides?: RequestInit | runtime.InitOverrideFunction,
	): Promise<CreateMessageResponse> {
		const response = await this.sendMessageRaw(
			requestParameters,
			initOverrides,
		);
		return await response.value();
	}

	/**
	 * Start the OAuth flow for user credential brokering
	 * Start credential brokering
	 */
	async startUserCredentialBrokeringRaw(
		requestParameters: V1ApiStartUserCredentialBrokeringRequest,
		initOverrides?: RequestInit | runtime.InitOverrideFunction,
	): Promise<runtime.ApiResponse<UserCredentialBrokeringResponse>> {
		if (requestParameters.providerControllerTypeId == null) {
			throw new runtime.RequiredError(
				"providerControllerTypeId",
				'Required parameter "providerControllerTypeId" was null or undefined when calling startUserCredentialBrokering().',
			);
		}

		if (requestParameters.credentialControllerTypeId == null) {
			throw new runtime.RequiredError(
				"credentialControllerTypeId",
				'Required parameter "credentialControllerTypeId" was null or undefined when calling startUserCredentialBrokering().',
			);
		}

		if (requestParameters.startUserCredentialBrokeringParamsInner == null) {
			throw new runtime.RequiredError(
				"startUserCredentialBrokeringParamsInner",
				'Required parameter "startUserCredentialBrokeringParamsInner" was null or undefined when calling startUserCredentialBrokering().',
			);
		}

		const queryParameters: any = {};

		const headerParameters: runtime.HTTPHeaders = {};

		headerParameters["Content-Type"] = "application/json";

		let urlPath = `/api/bridge/v1/available-providers/{provider_controller_type_id}/available-credentials/{credential_controller_type_id}/credential/user-credential/broker`;
		urlPath = urlPath.replace(
			`{${"provider_controller_type_id"}}`,
			encodeURIComponent(String(requestParameters.providerControllerTypeId)),
		);
		urlPath = urlPath.replace(
			`{${"credential_controller_type_id"}}`,
			encodeURIComponent(String(requestParameters.credentialControllerTypeId)),
		);

		const response = await this.request(
			{
				path: urlPath,
				method: "POST",
				headers: headerParameters,
				query: queryParameters,
				body: StartUserCredentialBrokeringParamsInnerToJSON(
					requestParameters.startUserCredentialBrokeringParamsInner,
				),
			},
			initOverrides,
		);

		return new runtime.JSONApiResponse(response, (jsonValue) =>
			UserCredentialBrokeringResponseFromJSON(jsonValue),
		);
	}

	/**
	 * Start the OAuth flow for user credential brokering
	 * Start credential brokering
	 */
	async startUserCredentialBrokering(
		requestParameters: V1ApiStartUserCredentialBrokeringRequest,
		initOverrides?: RequestInit | runtime.InitOverrideFunction,
	): Promise<UserCredentialBrokeringResponse> {
		const response = await this.startUserCredentialBrokeringRaw(
			requestParameters,
			initOverrides,
		);
		return await response.value();
	}

	/**
	 * Get the timeline history of a task with pagination
	 * Get task timeline
	 */
	async taskHistoryRaw(
		requestParameters: V1ApiTaskHistoryRequest,
		initOverrides?: RequestInit | runtime.InitOverrideFunction,
	): Promise<runtime.ApiResponse<TaskTimelineItemPaginatedResponse>> {
		if (requestParameters.pageSize == null) {
			throw new runtime.RequiredError(
				"pageSize",
				'Required parameter "pageSize" was null or undefined when calling taskHistory().',
			);
		}

		if (requestParameters.taskId == null) {
			throw new runtime.RequiredError(
				"taskId",
				'Required parameter "taskId" was null or undefined when calling taskHistory().',
			);
		}

		const queryParameters: any = {};

		if (requestParameters.pageSize != null) {
			queryParameters.page_size = requestParameters.pageSize;
		}

		if (requestParameters.nextPageToken != null) {
			queryParameters.next_page_token = requestParameters.nextPageToken;
		}

		const headerParameters: runtime.HTTPHeaders = {};

		let urlPath = `/api/task/v1/{task_id}/timeline`;
		urlPath = urlPath.replace(
			`{${"task_id"}}`,
			encodeURIComponent(String(requestParameters.taskId)),
		);

		const response = await this.request(
			{
				path: urlPath,
				method: "GET",
				headers: headerParameters,
				query: queryParameters,
			},
			initOverrides,
		);

		return new runtime.JSONApiResponse(response, (jsonValue) =>
			TaskTimelineItemPaginatedResponseFromJSON(jsonValue),
		);
	}

	/**
	 * Get the timeline history of a task with pagination
	 * Get task timeline
	 */
	async taskHistory(
		requestParameters: V1ApiTaskHistoryRequest,
		initOverrides?: RequestInit | runtime.InitOverrideFunction,
	): Promise<TaskTimelineItemPaginatedResponse> {
		const response = await this.taskHistoryRaw(
			requestParameters,
			initOverrides,
		);
		return await response.value();
	}

	/**
	 * Trigger code generation for the SDK
	 * Trigger codegen
	 */
	async triggerCodegenRaw(
		initOverrides?: RequestInit | runtime.InitOverrideFunction,
	): Promise<runtime.ApiResponse<object>> {
		const queryParameters: any = {};

		const headerParameters: runtime.HTTPHeaders = {};

		const urlPath = `/_internal/v1/trigger_codegen`;

		const response = await this.request(
			{
				path: urlPath,
				method: "POST",
				headers: headerParameters,
				query: queryParameters,
			},
			initOverrides,
		);

		return new runtime.JSONApiResponse<any>(response);
	}

	/**
	 * Trigger code generation for the SDK
	 * Trigger codegen
	 */
	async triggerCodegen(
		initOverrides?: RequestInit | runtime.InitOverrideFunction,
	): Promise<object> {
		const response = await this.triggerCodegenRaw(initOverrides);
		return await response.value();
	}

	/**
	 * Update the alias for a data encryption key
	 * Update DEK alias
	 */
	async updateDekAliasRaw(
		requestParameters: V1ApiUpdateDekAliasRequest,
		initOverrides?: RequestInit | runtime.InitOverrideFunction,
	): Promise<runtime.ApiResponse<DataEncryptionKeyAlias>> {
		if (requestParameters.alias == null) {
			throw new runtime.RequiredError(
				"alias",
				'Required parameter "alias" was null or undefined when calling updateDekAlias().',
			);
		}

		if (requestParameters.updateAliasParams == null) {
			throw new runtime.RequiredError(
				"updateAliasParams",
				'Required parameter "updateAliasParams" was null or undefined when calling updateDekAlias().',
			);
		}

		const queryParameters: any = {};

		const headerParameters: runtime.HTTPHeaders = {};

		headerParameters["Content-Type"] = "application/json";

		let urlPath = `/api/encryption/v1/dek/alias/{alias}`;
		urlPath = urlPath.replace(
			`{${"alias"}}`,
			encodeURIComponent(String(requestParameters.alias)),
		);

		const response = await this.request(
			{
				path: urlPath,
				method: "PUT",
				headers: headerParameters,
				query: queryParameters,
				body: UpdateAliasParamsToJSON(requestParameters.updateAliasParams),
			},
			initOverrides,
		);

		return new runtime.JSONApiResponse(response, (jsonValue) =>
			DataEncryptionKeyAliasFromJSON(jsonValue),
		);
	}

	/**
	 * Update the alias for a data encryption key
	 * Update DEK alias
	 */
	async updateDekAlias(
		requestParameters: V1ApiUpdateDekAliasRequest,
		initOverrides?: RequestInit | runtime.InitOverrideFunction,
	): Promise<DataEncryptionKeyAlias> {
		const response = await this.updateDekAliasRaw(
			requestParameters,
			initOverrides,
		);
		return await response.value();
	}

	/**
	 * Update an existing environment variable\'s value
	 * Update environment variable
	 */
	async updateEnvironmentVariableRaw(
		requestParameters: V1ApiUpdateEnvironmentVariableOperationRequest,
		initOverrides?: RequestInit | runtime.InitOverrideFunction,
	): Promise<runtime.ApiResponse<EnvironmentVariable>> {
		if (requestParameters.envVarId == null) {
			throw new runtime.RequiredError(
				"envVarId",
				'Required parameter "envVarId" was null or undefined when calling updateEnvironmentVariable().',
			);
		}

		if (requestParameters.updateEnvironmentVariableRequest == null) {
			throw new runtime.RequiredError(
				"updateEnvironmentVariableRequest",
				'Required parameter "updateEnvironmentVariableRequest" was null or undefined when calling updateEnvironmentVariable().',
			);
		}

		const queryParameters: any = {};

		const headerParameters: runtime.HTTPHeaders = {};

		headerParameters["Content-Type"] = "application/json";

		let urlPath = `/api/environment-variable/v1/{env_var_id}`;
		urlPath = urlPath.replace(
			`{${"env_var_id"}}`,
			encodeURIComponent(String(requestParameters.envVarId)),
		);

		const response = await this.request(
			{
				path: urlPath,
				method: "PUT",
				headers: headerParameters,
				query: queryParameters,
				body: UpdateEnvironmentVariableRequestToJSON(
					requestParameters.updateEnvironmentVariableRequest,
				),
			},
			initOverrides,
		);

		return new runtime.JSONApiResponse(response, (jsonValue) =>
			EnvironmentVariableFromJSON(jsonValue),
		);
	}

	/**
	 * Update an existing environment variable\'s value
	 * Update environment variable
	 */
	async updateEnvironmentVariable(
		requestParameters: V1ApiUpdateEnvironmentVariableOperationRequest,
		initOverrides?: RequestInit | runtime.InitOverrideFunction,
	): Promise<EnvironmentVariable> {
		const response = await this.updateEnvironmentVariableRaw(
			requestParameters,
			initOverrides,
		);
		return await response.value();
	}

	/**
	 * Update an MCP server instance name
	 * Update MCP server instance
	 */
	async updateMcpServerInstanceRaw(
		requestParameters: V1ApiUpdateMcpServerInstanceOperationRequest,
		initOverrides?: RequestInit | runtime.InitOverrideFunction,
	): Promise<runtime.ApiResponse<McpServerInstanceSerializedWithFunctions>> {
		if (requestParameters.mcpServerInstanceId == null) {
			throw new runtime.RequiredError(
				"mcpServerInstanceId",
				'Required parameter "mcpServerInstanceId" was null or undefined when calling updateMcpServerInstance().',
			);
		}

		if (requestParameters.updateMcpServerInstanceRequest == null) {
			throw new runtime.RequiredError(
				"updateMcpServerInstanceRequest",
				'Required parameter "updateMcpServerInstanceRequest" was null or undefined when calling updateMcpServerInstance().',
			);
		}

		const queryParameters: any = {};

		const headerParameters: runtime.HTTPHeaders = {};

		headerParameters["Content-Type"] = "application/json";

		let urlPath = `/api/bridge/v1/mcp-instance/{mcp_server_instance_id}`;
		urlPath = urlPath.replace(
			`{${"mcp_server_instance_id"}}`,
			encodeURIComponent(String(requestParameters.mcpServerInstanceId)),
		);

		const response = await this.request(
			{
				path: urlPath,
				method: "PATCH",
				headers: headerParameters,
				query: queryParameters,
				body: UpdateMcpServerInstanceRequestToJSON(
					requestParameters.updateMcpServerInstanceRequest,
				),
			},
			initOverrides,
		);

		return new runtime.JSONApiResponse(response, (jsonValue) =>
			McpServerInstanceSerializedWithFunctionsFromJSON(jsonValue),
		);
	}

	/**
	 * Update an MCP server instance name
	 * Update MCP server instance
	 */
	async updateMcpServerInstance(
		requestParameters: V1ApiUpdateMcpServerInstanceOperationRequest,
		initOverrides?: RequestInit | runtime.InitOverrideFunction,
	): Promise<McpServerInstanceSerializedWithFunctions> {
		const response = await this.updateMcpServerInstanceRaw(
			requestParameters,
			initOverrides,
		);
		return await response.value();
	}

	/**
	 * Update the function name and description for a function mapping
	 * Update function in MCP server instance
	 */
	async updateMcpServerInstanceFunctionRaw(
		requestParameters: V1ApiUpdateMcpServerInstanceFunctionOperationRequest,
		initOverrides?: RequestInit | runtime.InitOverrideFunction,
	): Promise<runtime.ApiResponse<McpServerInstanceSerializedWithFunctions>> {
		if (requestParameters.mcpServerInstanceId == null) {
			throw new runtime.RequiredError(
				"mcpServerInstanceId",
				'Required parameter "mcpServerInstanceId" was null or undefined when calling updateMcpServerInstanceFunction().',
			);
		}

		if (requestParameters.functionControllerTypeId == null) {
			throw new runtime.RequiredError(
				"functionControllerTypeId",
				'Required parameter "functionControllerTypeId" was null or undefined when calling updateMcpServerInstanceFunction().',
			);
		}

		if (requestParameters.providerControllerTypeId == null) {
			throw new runtime.RequiredError(
				"providerControllerTypeId",
				'Required parameter "providerControllerTypeId" was null or undefined when calling updateMcpServerInstanceFunction().',
			);
		}

		if (requestParameters.providerInstanceId == null) {
			throw new runtime.RequiredError(
				"providerInstanceId",
				'Required parameter "providerInstanceId" was null or undefined when calling updateMcpServerInstanceFunction().',
			);
		}

		if (requestParameters.updateMcpServerInstanceFunctionRequest == null) {
			throw new runtime.RequiredError(
				"updateMcpServerInstanceFunctionRequest",
				'Required parameter "updateMcpServerInstanceFunctionRequest" was null or undefined when calling updateMcpServerInstanceFunction().',
			);
		}

		const queryParameters: any = {};

		const headerParameters: runtime.HTTPHeaders = {};

		headerParameters["Content-Type"] = "application/json";

		let urlPath = `/api/bridge/v1/mcp-instance/{mcp_server_instance_id}/function/{function_controller_type_id}/{provider_controller_type_id}/{provider_instance_id}`;
		urlPath = urlPath.replace(
			`{${"mcp_server_instance_id"}}`,
			encodeURIComponent(String(requestParameters.mcpServerInstanceId)),
		);
		urlPath = urlPath.replace(
			`{${"function_controller_type_id"}}`,
			encodeURIComponent(String(requestParameters.functionControllerTypeId)),
		);
		urlPath = urlPath.replace(
			`{${"provider_controller_type_id"}}`,
			encodeURIComponent(String(requestParameters.providerControllerTypeId)),
		);
		urlPath = urlPath.replace(
			`{${"provider_instance_id"}}`,
			encodeURIComponent(String(requestParameters.providerInstanceId)),
		);

		const response = await this.request(
			{
				path: urlPath,
				method: "PATCH",
				headers: headerParameters,
				query: queryParameters,
				body: UpdateMcpServerInstanceFunctionRequestToJSON(
					requestParameters.updateMcpServerInstanceFunctionRequest,
				),
			},
			initOverrides,
		);

		return new runtime.JSONApiResponse(response, (jsonValue) =>
			McpServerInstanceSerializedWithFunctionsFromJSON(jsonValue),
		);
	}

	/**
	 * Update the function name and description for a function mapping
	 * Update function in MCP server instance
	 */
	async updateMcpServerInstanceFunction(
		requestParameters: V1ApiUpdateMcpServerInstanceFunctionOperationRequest,
		initOverrides?: RequestInit | runtime.InitOverrideFunction,
	): Promise<McpServerInstanceSerializedWithFunctions> {
		const response = await this.updateMcpServerInstanceFunctionRaw(
			requestParameters,
			initOverrides,
		);
		return await response.value();
	}

	/**
	 * Update an existing provider instance configuration
	 * Update provider
	 */
	async updateProviderInstanceRaw(
		requestParameters: V1ApiUpdateProviderInstanceRequest,
		initOverrides?: RequestInit | runtime.InitOverrideFunction,
	): Promise<runtime.ApiResponse<any>> {
		if (requestParameters.providerInstanceId == null) {
			throw new runtime.RequiredError(
				"providerInstanceId",
				'Required parameter "providerInstanceId" was null or undefined when calling updateProviderInstance().',
			);
		}

		if (requestParameters.updateProviderInstanceParamsInner == null) {
			throw new runtime.RequiredError(
				"updateProviderInstanceParamsInner",
				'Required parameter "updateProviderInstanceParamsInner" was null or undefined when calling updateProviderInstance().',
			);
		}

		const queryParameters: any = {};

		const headerParameters: runtime.HTTPHeaders = {};

		headerParameters["Content-Type"] = "application/json";

		let urlPath = `/api/bridge/v1/provider/{provider_instance_id}`;
		urlPath = urlPath.replace(
			`{${"provider_instance_id"}}`,
			encodeURIComponent(String(requestParameters.providerInstanceId)),
		);

		const response = await this.request(
			{
				path: urlPath,
				method: "PATCH",
				headers: headerParameters,
				query: queryParameters,
				body: UpdateProviderInstanceParamsInnerToJSON(
					requestParameters.updateProviderInstanceParamsInner,
				),
			},
			initOverrides,
		);

		if (this.isJsonMime(response.headers.get("content-type"))) {
			return new runtime.JSONApiResponse<any>(response);
		} else {
			return new runtime.TextApiResponse(response) as any;
		}
	}

	/**
	 * Update an existing provider instance configuration
	 * Update provider
	 */
	async updateProviderInstance(
		requestParameters: V1ApiUpdateProviderInstanceRequest,
		initOverrides?: RequestInit | runtime.InitOverrideFunction,
	): Promise<any> {
		const response = await this.updateProviderInstanceRaw(
			requestParameters,
			initOverrides,
		);
		return await response.value();
	}

	/**
	 * Update an existing secret\'s value or metadata
	 * Update secret
	 */
	async updateSecretRaw(
		requestParameters: V1ApiUpdateSecretOperationRequest,
		initOverrides?: RequestInit | runtime.InitOverrideFunction,
	): Promise<runtime.ApiResponse<Secret>> {
		if (requestParameters.secretId == null) {
			throw new runtime.RequiredError(
				"secretId",
				'Required parameter "secretId" was null or undefined when calling updateSecret().',
			);
		}

		if (requestParameters.updateSecretRequest == null) {
			throw new runtime.RequiredError(
				"updateSecretRequest",
				'Required parameter "updateSecretRequest" was null or undefined when calling updateSecret().',
			);
		}

		const queryParameters: any = {};

		const headerParameters: runtime.HTTPHeaders = {};

		headerParameters["Content-Type"] = "application/json";

		let urlPath = `/api/secret/v1/{secret_id}`;
		urlPath = urlPath.replace(
			`{${"secret_id"}}`,
			encodeURIComponent(String(requestParameters.secretId)),
		);

		const response = await this.request(
			{
				path: urlPath,
				method: "PUT",
				headers: headerParameters,
				query: queryParameters,
				body: UpdateSecretRequestToJSON(requestParameters.updateSecretRequest),
			},
			initOverrides,
		);

		return new runtime.JSONApiResponse(response, (jsonValue) =>
			SecretFromJSON(jsonValue),
		);
	}

	/**
	 * Update an existing secret\'s value or metadata
	 * Update secret
	 */
	async updateSecret(
		requestParameters: V1ApiUpdateSecretOperationRequest,
		initOverrides?: RequestInit | runtime.InitOverrideFunction,
	): Promise<Secret> {
		const response = await this.updateSecretRaw(
			requestParameters,
			initOverrides,
		);
		return await response.value();
	}

	/**
	 * Update the status of a task
	 * Update task status
	 */
	async updateTaskStatusRaw(
		requestParameters: V1ApiUpdateTaskStatusOperationRequest,
		initOverrides?: RequestInit | runtime.InitOverrideFunction,
	): Promise<runtime.ApiResponse<any>> {
		if (requestParameters.taskId == null) {
			throw new runtime.RequiredError(
				"taskId",
				'Required parameter "taskId" was null or undefined when calling updateTaskStatus().',
			);
		}

		if (requestParameters.updateTaskStatusRequest == null) {
			throw new runtime.RequiredError(
				"updateTaskStatusRequest",
				'Required parameter "updateTaskStatusRequest" was null or undefined when calling updateTaskStatus().',
			);
		}

		const queryParameters: any = {};

		const headerParameters: runtime.HTTPHeaders = {};

		headerParameters["Content-Type"] = "application/json";

		let urlPath = `/api/task/v1/{task_id}`;
		urlPath = urlPath.replace(
			`{${"task_id"}}`,
			encodeURIComponent(String(requestParameters.taskId)),
		);

		const response = await this.request(
			{
				path: urlPath,
				method: "PUT",
				headers: headerParameters,
				query: queryParameters,
				body: UpdateTaskStatusRequestToJSON(
					requestParameters.updateTaskStatusRequest,
				),
			},
			initOverrides,
		);

		if (this.isJsonMime(response.headers.get("content-type"))) {
			return new runtime.JSONApiResponse<any>(response);
		} else {
			return new runtime.TextApiResponse(response) as any;
		}
	}

	/**
	 * Update the status of a task
	 * Update task status
	 */
	async updateTaskStatus(
		requestParameters: V1ApiUpdateTaskStatusOperationRequest,
		initOverrides?: RequestInit | runtime.InitOverrideFunction,
	): Promise<any> {
		const response = await this.updateTaskStatusRaw(
			requestParameters,
			initOverrides,
		);
		return await response.value();
	}
}
