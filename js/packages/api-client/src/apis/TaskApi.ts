/* tslint:disable */
/* eslint-disable */
/**
 * soma
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: v1
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import * as runtime from '../runtime';
import type {
  ContextInfoPaginatedResponse,
  CreateMessageRequest,
  CreateMessageResponse,
  TaskPaginatedResponse,
  TaskTimelineItemPaginatedResponse,
  TaskWithDetails,
  UpdateTaskStatusRequest,
} from '../models/index';
import {
    ContextInfoPaginatedResponseFromJSON,
    ContextInfoPaginatedResponseToJSON,
    CreateMessageRequestFromJSON,
    CreateMessageRequestToJSON,
    CreateMessageResponseFromJSON,
    CreateMessageResponseToJSON,
    TaskPaginatedResponseFromJSON,
    TaskPaginatedResponseToJSON,
    TaskTimelineItemPaginatedResponseFromJSON,
    TaskTimelineItemPaginatedResponseToJSON,
    TaskWithDetailsFromJSON,
    TaskWithDetailsToJSON,
    UpdateTaskStatusRequestFromJSON,
    UpdateTaskStatusRequestToJSON,
} from '../models/index';

export interface GetTaskByIdRequest {
    taskId: string;
}

export interface ListContextsRequest {
    pageSize: number;
    nextPageToken?: string;
}

export interface ListTasksRequest {
    pageSize: number;
    nextPageToken?: string;
}

export interface ListTasksByContextIdRequest {
    pageSize: number;
    contextId: string;
    nextPageToken?: string;
}

export interface SendMessageRequest {
    taskId: string;
    createMessageRequest: CreateMessageRequest;
}

export interface TaskHistoryRequest {
    pageSize: number;
    taskId: string;
    nextPageToken?: string;
}

export interface UpdateTaskStatusOperationRequest {
    taskId: string;
    updateTaskStatusRequest: UpdateTaskStatusRequest;
}

/**
 * 
 */
export class TaskApi extends runtime.BaseAPI {

    /**
     * Retrieve a task by its unique identifier
     * Get task
     */
    async getTaskByIdRaw(requestParameters: GetTaskByIdRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<TaskWithDetails>> {
        if (requestParameters['taskId'] == null) {
            throw new runtime.RequiredError(
                'taskId',
                'Required parameter "taskId" was null or undefined when calling getTaskById().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};


        let urlPath = `/api/task/v1/{task_id}`;
        urlPath = urlPath.replace(`{${"task_id"}}`, encodeURIComponent(String(requestParameters['taskId'])));

        const response = await this.request({
            path: urlPath,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => TaskWithDetailsFromJSON(jsonValue));
    }

    /**
     * Retrieve a task by its unique identifier
     * Get task
     */
    async getTaskById(requestParameters: GetTaskByIdRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<TaskWithDetails> {
        const response = await this.getTaskByIdRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * List all unique task contexts with pagination
     * List contexts
     */
    async listContextsRaw(requestParameters: ListContextsRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<ContextInfoPaginatedResponse>> {
        if (requestParameters['pageSize'] == null) {
            throw new runtime.RequiredError(
                'pageSize',
                'Required parameter "pageSize" was null or undefined when calling listContexts().'
            );
        }

        const queryParameters: any = {};

        if (requestParameters['pageSize'] != null) {
            queryParameters['page_size'] = requestParameters['pageSize'];
        }

        if (requestParameters['nextPageToken'] != null) {
            queryParameters['next_page_token'] = requestParameters['nextPageToken'];
        }

        const headerParameters: runtime.HTTPHeaders = {};


        let urlPath = `/api/task/v1/context`;

        const response = await this.request({
            path: urlPath,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => ContextInfoPaginatedResponseFromJSON(jsonValue));
    }

    /**
     * List all unique task contexts with pagination
     * List contexts
     */
    async listContexts(requestParameters: ListContextsRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<ContextInfoPaginatedResponse> {
        const response = await this.listContextsRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * List all tasks with pagination
     * List tasks
     */
    async listTasksRaw(requestParameters: ListTasksRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<TaskPaginatedResponse>> {
        if (requestParameters['pageSize'] == null) {
            throw new runtime.RequiredError(
                'pageSize',
                'Required parameter "pageSize" was null or undefined when calling listTasks().'
            );
        }

        const queryParameters: any = {};

        if (requestParameters['pageSize'] != null) {
            queryParameters['page_size'] = requestParameters['pageSize'];
        }

        if (requestParameters['nextPageToken'] != null) {
            queryParameters['next_page_token'] = requestParameters['nextPageToken'];
        }

        const headerParameters: runtime.HTTPHeaders = {};


        let urlPath = `/api/task/v1`;

        const response = await this.request({
            path: urlPath,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => TaskPaginatedResponseFromJSON(jsonValue));
    }

    /**
     * List all tasks with pagination
     * List tasks
     */
    async listTasks(requestParameters: ListTasksRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<TaskPaginatedResponse> {
        const response = await this.listTasksRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * List all tasks for a specific context ID with pagination
     * List tasks by context
     */
    async listTasksByContextIdRaw(requestParameters: ListTasksByContextIdRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<TaskPaginatedResponse>> {
        if (requestParameters['pageSize'] == null) {
            throw new runtime.RequiredError(
                'pageSize',
                'Required parameter "pageSize" was null or undefined when calling listTasksByContextId().'
            );
        }

        if (requestParameters['contextId'] == null) {
            throw new runtime.RequiredError(
                'contextId',
                'Required parameter "contextId" was null or undefined when calling listTasksByContextId().'
            );
        }

        const queryParameters: any = {};

        if (requestParameters['pageSize'] != null) {
            queryParameters['page_size'] = requestParameters['pageSize'];
        }

        if (requestParameters['nextPageToken'] != null) {
            queryParameters['next_page_token'] = requestParameters['nextPageToken'];
        }

        const headerParameters: runtime.HTTPHeaders = {};


        let urlPath = `/api/task/v1/context/{context_id}/task`;
        urlPath = urlPath.replace(`{${"context_id"}}`, encodeURIComponent(String(requestParameters['contextId'])));

        const response = await this.request({
            path: urlPath,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => TaskPaginatedResponseFromJSON(jsonValue));
    }

    /**
     * List all tasks for a specific context ID with pagination
     * List tasks by context
     */
    async listTasksByContextId(requestParameters: ListTasksByContextIdRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<TaskPaginatedResponse> {
        const response = await this.listTasksByContextIdRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Send a message to a task
     * Send message
     */
    async sendMessageRaw(requestParameters: SendMessageRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<CreateMessageResponse>> {
        if (requestParameters['taskId'] == null) {
            throw new runtime.RequiredError(
                'taskId',
                'Required parameter "taskId" was null or undefined when calling sendMessage().'
            );
        }

        if (requestParameters['createMessageRequest'] == null) {
            throw new runtime.RequiredError(
                'createMessageRequest',
                'Required parameter "createMessageRequest" was null or undefined when calling sendMessage().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';


        let urlPath = `/api/task/v1/{task_id}/message`;
        urlPath = urlPath.replace(`{${"task_id"}}`, encodeURIComponent(String(requestParameters['taskId'])));

        const response = await this.request({
            path: urlPath,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: CreateMessageRequestToJSON(requestParameters['createMessageRequest']),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => CreateMessageResponseFromJSON(jsonValue));
    }

    /**
     * Send a message to a task
     * Send message
     */
    async sendMessage(requestParameters: SendMessageRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<CreateMessageResponse> {
        const response = await this.sendMessageRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Get the timeline history of a task with pagination
     * Get task timeline
     */
    async taskHistoryRaw(requestParameters: TaskHistoryRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<TaskTimelineItemPaginatedResponse>> {
        if (requestParameters['pageSize'] == null) {
            throw new runtime.RequiredError(
                'pageSize',
                'Required parameter "pageSize" was null or undefined when calling taskHistory().'
            );
        }

        if (requestParameters['taskId'] == null) {
            throw new runtime.RequiredError(
                'taskId',
                'Required parameter "taskId" was null or undefined when calling taskHistory().'
            );
        }

        const queryParameters: any = {};

        if (requestParameters['pageSize'] != null) {
            queryParameters['page_size'] = requestParameters['pageSize'];
        }

        if (requestParameters['nextPageToken'] != null) {
            queryParameters['next_page_token'] = requestParameters['nextPageToken'];
        }

        const headerParameters: runtime.HTTPHeaders = {};


        let urlPath = `/api/task/v1/{task_id}/timeline`;
        urlPath = urlPath.replace(`{${"task_id"}}`, encodeURIComponent(String(requestParameters['taskId'])));

        const response = await this.request({
            path: urlPath,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => TaskTimelineItemPaginatedResponseFromJSON(jsonValue));
    }

    /**
     * Get the timeline history of a task with pagination
     * Get task timeline
     */
    async taskHistory(requestParameters: TaskHistoryRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<TaskTimelineItemPaginatedResponse> {
        const response = await this.taskHistoryRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Update the status of a task
     * Update task status
     */
    async updateTaskStatusRaw(requestParameters: UpdateTaskStatusOperationRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<any>> {
        if (requestParameters['taskId'] == null) {
            throw new runtime.RequiredError(
                'taskId',
                'Required parameter "taskId" was null or undefined when calling updateTaskStatus().'
            );
        }

        if (requestParameters['updateTaskStatusRequest'] == null) {
            throw new runtime.RequiredError(
                'updateTaskStatusRequest',
                'Required parameter "updateTaskStatusRequest" was null or undefined when calling updateTaskStatus().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';


        let urlPath = `/api/task/v1/{task_id}`;
        urlPath = urlPath.replace(`{${"task_id"}}`, encodeURIComponent(String(requestParameters['taskId'])));

        const response = await this.request({
            path: urlPath,
            method: 'PUT',
            headers: headerParameters,
            query: queryParameters,
            body: UpdateTaskStatusRequestToJSON(requestParameters['updateTaskStatusRequest']),
        }, initOverrides);

        if (this.isJsonMime(response.headers.get('content-type'))) {
            return new runtime.JSONApiResponse<any>(response);
        } else {
            return new runtime.TextApiResponse(response) as any;
        }
    }

    /**
     * Update the status of a task
     * Update task status
     */
    async updateTaskStatus(requestParameters: UpdateTaskStatusOperationRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<any> {
        const response = await this.updateTaskStatusRaw(requestParameters, initOverrides);
        return await response.value();
    }

}
