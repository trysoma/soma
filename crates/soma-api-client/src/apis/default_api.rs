/*
 * utoipa-axum
 *
 * Utoipa's axum bindings for seamless integration for the two
 *
 * The version of the OpenAPI document: 0.2.0
 * Contact: juha7kukkonen@gmail.com
 * Generated by: https://openapi-generator.tech
 */


use reqwest;
use serde::{Deserialize, Serialize, de::Error as _};
use crate::{apis::ResponseContent, models};
use super::{Error, configuration, ContentType};


/// struct for typed errors of method [`agent_card`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum AgentCardError {
    Status500(models::Error),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`create_data_encryption_key`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum CreateDataEncryptionKeyError {
    Status400(models::Error),
    Status500(models::Error),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`create_provider_instance`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum CreateProviderInstanceError {
    Status400(models::Error),
    Status500(models::Error),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`create_resource_server_credential`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum CreateResourceServerCredentialError {
    Status400(models::Error),
    Status500(models::Error),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`create_user_credential`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum CreateUserCredentialError {
    Status400(models::Error),
    Status500(models::Error),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`delete_provider_instance`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum DeleteProviderInstanceError {
    Status400(models::Error),
    Status500(models::Error),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`disable_function`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum DisableFunctionError {
    Status400(models::Error),
    Status500(models::Error),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`enable_function`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum EnableFunctionError {
    Status400(models::Error),
    Status500(models::Error),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`encrypt_resource_server_configuration`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum EncryptResourceServerConfigurationError {
    Status400(models::Error),
    Status500(models::Error),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`encrypt_user_credential_configuration`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum EncryptUserCredentialConfigurationError {
    Status400(models::Error),
    Status500(models::Error),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`extended_agent_card`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ExtendedAgentCardError {
    Status500(models::Error),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_agent_definition`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetAgentDefinitionError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_frontend_env`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetFrontendEnvError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_task_by_id`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetTaskByIdError {
    Status400(models::Error),
    Status401(models::Error),
    Status403(models::Error),
    Status500(models::Error),
    Status502(models::Error),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`invoke_function`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum InvokeFunctionError {
    Status400(models::Error),
    Status500(models::Error),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`json_rpc`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum JsonRpcError {
    Status500(models::Error),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`list_available_providers`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ListAvailableProvidersError {
    Status400(models::Error),
    Status500(models::Error),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`list_contexts`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ListContextsError {
    Status400(models::Error),
    Status401(models::Error),
    Status403(models::Error),
    Status500(models::Error),
    Status502(models::Error),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`list_data_encryption_keys`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ListDataEncryptionKeysError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`list_tasks`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ListTasksError {
    Status400(models::Error),
    Status401(models::Error),
    Status403(models::Error),
    Status500(models::Error),
    Status502(models::Error),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`list_tasks_by_context_id`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ListTasksByContextIdError {
    Status400(models::Error),
    Status401(models::Error),
    Status403(models::Error),
    Status500(models::Error),
    Status502(models::Error),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`resume_user_credential_brokering`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ResumeUserCredentialBrokeringError {
    Status400(models::Error),
    Status500(models::Error),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`send_message`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum SendMessageError {
    Status400(models::Error),
    Status401(models::Error),
    Status403(models::Error),
    Status500(models::Error),
    Status502(models::Error),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`start_user_credential_brokering`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum StartUserCredentialBrokeringError {
    Status400(models::Error),
    Status500(models::Error),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`task_history`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum TaskHistoryError {
    Status400(models::Error),
    Status401(models::Error),
    Status403(models::Error),
    Status500(models::Error),
    Status502(models::Error),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`update_task_status`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum UpdateTaskStatusError {
    Status400(models::Error),
    Status401(models::Error),
    Status403(models::Error),
    Status500(models::Error),
    Status502(models::Error),
    UnknownValue(serde_json::Value),
}


pub async fn agent_card(configuration: &configuration::Configuration, ) -> Result<serde_json::Value, Error<AgentCardError>> {

    let uri_str = format!("{}/api/a2a/v1/.well-known/agent.json", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `serde_json::Value`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `serde_json::Value`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<AgentCardError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

pub async fn create_data_encryption_key(configuration: &configuration::Configuration, create_data_encryption_key_params: models::CreateDataEncryptionKeyParams) -> Result<models::DataEncryptionKey, Error<CreateDataEncryptionKeyError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_create_data_encryption_key_params = create_data_encryption_key_params;

    let uri_str = format!("{}/api/bridge/v1/encryption/data-encryption-key", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    req_builder = req_builder.json(&p_create_data_encryption_key_params);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::DataEncryptionKey`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::DataEncryptionKey`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<CreateDataEncryptionKeyError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

pub async fn create_provider_instance(configuration: &configuration::Configuration, provider_controller_type_id: &str, credential_controller_type_id: &str, create_provider_instance_params_inner: models::CreateProviderInstanceParamsInner) -> Result<models::ProviderInstanceSerialized, Error<CreateProviderInstanceError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_provider_controller_type_id = provider_controller_type_id;
    let p_credential_controller_type_id = credential_controller_type_id;
    let p_create_provider_instance_params_inner = create_provider_instance_params_inner;

    let uri_str = format!("{}/api/bridge/v1/available-providers/{provider_controller_type_id}/available-credentials/{credential_controller_type_id}", configuration.base_path, provider_controller_type_id=crate::apis::urlencode(p_provider_controller_type_id), credential_controller_type_id=crate::apis::urlencode(p_credential_controller_type_id));
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    req_builder = req_builder.json(&p_create_provider_instance_params_inner);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::ProviderInstanceSerialized`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::ProviderInstanceSerialized`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<CreateProviderInstanceError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

pub async fn create_resource_server_credential(configuration: &configuration::Configuration, provider_controller_type_id: &str, credential_controller_type_id: &str, create_resource_server_credential_params_inner: models::CreateResourceServerCredentialParamsInner) -> Result<models::ResourceServerCredentialSerialized, Error<CreateResourceServerCredentialError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_provider_controller_type_id = provider_controller_type_id;
    let p_credential_controller_type_id = credential_controller_type_id;
    let p_create_resource_server_credential_params_inner = create_resource_server_credential_params_inner;

    let uri_str = format!("{}/api/bridge/v1/available-providers/{provider_controller_type_id}/available-credentials/{credential_controller_type_id}/credential/resource-server", configuration.base_path, provider_controller_type_id=crate::apis::urlencode(p_provider_controller_type_id), credential_controller_type_id=crate::apis::urlencode(p_credential_controller_type_id));
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    req_builder = req_builder.json(&p_create_resource_server_credential_params_inner);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::ResourceServerCredentialSerialized`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::ResourceServerCredentialSerialized`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<CreateResourceServerCredentialError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

pub async fn create_user_credential(configuration: &configuration::Configuration, provider_controller_type_id: &str, credential_controller_type_id: &str, create_user_credential_params_inner: models::CreateUserCredentialParamsInner) -> Result<models::UserCredentialSerialized, Error<CreateUserCredentialError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_provider_controller_type_id = provider_controller_type_id;
    let p_credential_controller_type_id = credential_controller_type_id;
    let p_create_user_credential_params_inner = create_user_credential_params_inner;

    let uri_str = format!("{}/api/bridge/v1/available-providers/{provider_controller_type_id}/available-credentials/{credential_controller_type_id}/credential/user-credential", configuration.base_path, provider_controller_type_id=crate::apis::urlencode(p_provider_controller_type_id), credential_controller_type_id=crate::apis::urlencode(p_credential_controller_type_id));
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    req_builder = req_builder.json(&p_create_user_credential_params_inner);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::UserCredentialSerialized`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::UserCredentialSerialized`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<CreateUserCredentialError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

pub async fn delete_provider_instance(configuration: &configuration::Configuration, provider_instance_id: &str) -> Result<serde_json::Value, Error<DeleteProviderInstanceError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_provider_instance_id = provider_instance_id;

    let uri_str = format!("{}/api/bridge/v1/provider/{provider_instance_id}", configuration.base_path, provider_instance_id=crate::apis::urlencode(p_provider_instance_id));
    let mut req_builder = configuration.client.request(reqwest::Method::DELETE, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `serde_json::Value`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `serde_json::Value`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<DeleteProviderInstanceError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

pub async fn disable_function(configuration: &configuration::Configuration, provider_instance_id: &str, function_instance_id: &str) -> Result<serde_json::Value, Error<DisableFunctionError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_provider_instance_id = provider_instance_id;
    let p_function_instance_id = function_instance_id;

    let uri_str = format!("{}/api/bridge/v1/provider/{provider_instance_id}/function/{function_instance_id}/disable", configuration.base_path, provider_instance_id=crate::apis::urlencode(p_provider_instance_id), function_instance_id=crate::apis::urlencode(p_function_instance_id));
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `serde_json::Value`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `serde_json::Value`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<DisableFunctionError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

pub async fn enable_function(configuration: &configuration::Configuration, provider_instance_id: &str, function_controller_type_id: &str, enable_function_params_inner: models::EnableFunctionParamsInner) -> Result<models::FunctionInstanceSerialized, Error<EnableFunctionError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_provider_instance_id = provider_instance_id;
    let p_function_controller_type_id = function_controller_type_id;
    let p_enable_function_params_inner = enable_function_params_inner;

    let uri_str = format!("{}/api/bridge/v1/provider/{provider_instance_id}/available-functions/{function_controller_type_id}/enable", configuration.base_path, provider_instance_id=crate::apis::urlencode(p_provider_instance_id), function_controller_type_id=crate::apis::urlencode(p_function_controller_type_id));
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    req_builder = req_builder.json(&p_enable_function_params_inner);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::FunctionInstanceSerialized`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::FunctionInstanceSerialized`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<EnableFunctionError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

pub async fn encrypt_resource_server_configuration(configuration: &configuration::Configuration, provider_controller_type_id: &str, credential_controller_type_id: &str, encrypt_credential_configuration_params_inner: models::EncryptCredentialConfigurationParamsInner) -> Result<serde_json::Value, Error<EncryptResourceServerConfigurationError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_provider_controller_type_id = provider_controller_type_id;
    let p_credential_controller_type_id = credential_controller_type_id;
    let p_encrypt_credential_configuration_params_inner = encrypt_credential_configuration_params_inner;

    let uri_str = format!("{}/api/bridge/v1/available-providers/{provider_controller_type_id}/available-credentials/{credential_controller_type_id}/credential/resource-server/encrypt", configuration.base_path, provider_controller_type_id=crate::apis::urlencode(p_provider_controller_type_id), credential_controller_type_id=crate::apis::urlencode(p_credential_controller_type_id));
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    req_builder = req_builder.json(&p_encrypt_credential_configuration_params_inner);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `serde_json::Value`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `serde_json::Value`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<EncryptResourceServerConfigurationError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

pub async fn encrypt_user_credential_configuration(configuration: &configuration::Configuration, provider_controller_type_id: &str, credential_controller_type_id: &str, encrypt_credential_configuration_params_inner: models::EncryptCredentialConfigurationParamsInner) -> Result<serde_json::Value, Error<EncryptUserCredentialConfigurationError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_provider_controller_type_id = provider_controller_type_id;
    let p_credential_controller_type_id = credential_controller_type_id;
    let p_encrypt_credential_configuration_params_inner = encrypt_credential_configuration_params_inner;

    let uri_str = format!("{}/api/bridge/v1/available-providers/{provider_controller_type_id}/available-credentials/{credential_controller_type_id}/credential/user-credential/encrypt", configuration.base_path, provider_controller_type_id=crate::apis::urlencode(p_provider_controller_type_id), credential_controller_type_id=crate::apis::urlencode(p_credential_controller_type_id));
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    req_builder = req_builder.json(&p_encrypt_credential_configuration_params_inner);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `serde_json::Value`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `serde_json::Value`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<EncryptUserCredentialConfigurationError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

pub async fn extended_agent_card(configuration: &configuration::Configuration, ) -> Result<serde_json::Value, Error<ExtendedAgentCardError>> {

    let uri_str = format!("{}/api/a2a/v1/agent/authenticatedExtendedCard", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `serde_json::Value`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `serde_json::Value`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<ExtendedAgentCardError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

pub async fn get_agent_definition(configuration: &configuration::Configuration, ) -> Result<models::SomaAgentDefinition, Error<GetAgentDefinitionError>> {

    let uri_str = format!("{}/api/a2a/v1/definition", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::SomaAgentDefinition`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::SomaAgentDefinition`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<GetAgentDefinitionError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

pub async fn get_frontend_env(configuration: &configuration::Configuration, ) -> Result<serde_json::Value, Error<GetFrontendEnvError>> {

    let uri_str = format!("{}/api/frontend/v1/runtime_config", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `serde_json::Value`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `serde_json::Value`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<GetFrontendEnvError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

pub async fn get_task_by_id(configuration: &configuration::Configuration, task_id: &str) -> Result<models::TaskWithDetails, Error<GetTaskByIdError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_task_id = task_id;

    let uri_str = format!("{}/api/task/v1/{task_id}", configuration.base_path, task_id=crate::apis::urlencode(p_task_id));
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::TaskWithDetails`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::TaskWithDetails`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<GetTaskByIdError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

pub async fn invoke_function(configuration: &configuration::Configuration, provider_instance_id: &str, function_instance_id: &str, invoke_function_params_inner: models::InvokeFunctionParamsInner) -> Result<serde_json::Value, Error<InvokeFunctionError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_provider_instance_id = provider_instance_id;
    let p_function_instance_id = function_instance_id;
    let p_invoke_function_params_inner = invoke_function_params_inner;

    let uri_str = format!("{}/api/bridge/v1/provider/{provider_instance_id}/function/{function_instance_id}/invoke", configuration.base_path, provider_instance_id=crate::apis::urlencode(p_provider_instance_id), function_instance_id=crate::apis::urlencode(p_function_instance_id));
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    req_builder = req_builder.json(&p_invoke_function_params_inner);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `serde_json::Value`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `serde_json::Value`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<InvokeFunctionError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

pub async fn json_rpc(configuration: &configuration::Configuration, body: serde_json::Value) -> Result<(), Error<JsonRpcError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_body = body;

    let uri_str = format!("{}/api/a2a/v1", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    req_builder = req_builder.json(&p_body);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        Ok(())
    } else {
        let content = resp.text().await?;
        let entity: Option<JsonRpcError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

pub async fn list_available_providers(configuration: &configuration::Configuration, page_size: i64, next_page_token: Option<&str>) -> Result<models::ProviderControllerSerializedPaginatedResponse, Error<ListAvailableProvidersError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_page_size = page_size;
    let p_next_page_token = next_page_token;

    let uri_str = format!("{}/api/bridge/v1/available-providers", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    req_builder = req_builder.query(&[("page_size", &p_page_size.to_string())]);
    if let Some(ref param_value) = p_next_page_token {
        req_builder = req_builder.query(&[("next_page_token", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::ProviderControllerSerializedPaginatedResponse`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::ProviderControllerSerializedPaginatedResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<ListAvailableProvidersError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

pub async fn list_contexts(configuration: &configuration::Configuration, page_size: i64, next_page_token: Option<&str>) -> Result<models::ContextInfoPaginatedResponse, Error<ListContextsError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_page_size = page_size;
    let p_next_page_token = next_page_token;

    let uri_str = format!("{}/api/task/v1/context", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    req_builder = req_builder.query(&[("page_size", &p_page_size.to_string())]);
    if let Some(ref param_value) = p_next_page_token {
        req_builder = req_builder.query(&[("next_page_token", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::ContextInfoPaginatedResponse`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::ContextInfoPaginatedResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<ListContextsError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

pub async fn list_data_encryption_keys(configuration: &configuration::Configuration, page_size: i64, next_page_token: Option<&str>) -> Result<models::DataEncryptionKeyListItemPaginatedResponse, Error<ListDataEncryptionKeysError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_page_size = page_size;
    let p_next_page_token = next_page_token;

    let uri_str = format!("{}/api/bridge/v1/encryption/data-encryption-key", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    req_builder = req_builder.query(&[("page_size", &p_page_size.to_string())]);
    if let Some(ref param_value) = p_next_page_token {
        req_builder = req_builder.query(&[("next_page_token", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::DataEncryptionKeyListItemPaginatedResponse`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::DataEncryptionKeyListItemPaginatedResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<ListDataEncryptionKeysError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

pub async fn list_tasks(configuration: &configuration::Configuration, page_size: i64, next_page_token: Option<&str>) -> Result<models::TaskPaginatedResponse, Error<ListTasksError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_page_size = page_size;
    let p_next_page_token = next_page_token;

    let uri_str = format!("{}/api/task/v1", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    req_builder = req_builder.query(&[("page_size", &p_page_size.to_string())]);
    if let Some(ref param_value) = p_next_page_token {
        req_builder = req_builder.query(&[("next_page_token", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::TaskPaginatedResponse`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::TaskPaginatedResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<ListTasksError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

pub async fn list_tasks_by_context_id(configuration: &configuration::Configuration, page_size: i64, context_id: &str, next_page_token: Option<&str>) -> Result<models::TaskPaginatedResponse, Error<ListTasksByContextIdError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_page_size = page_size;
    let p_context_id = context_id;
    let p_next_page_token = next_page_token;

    let uri_str = format!("{}/api/task/v1/context/{context_id}/task", configuration.base_path, context_id=crate::apis::urlencode(p_context_id));
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    req_builder = req_builder.query(&[("page_size", &p_page_size.to_string())]);
    if let Some(ref param_value) = p_next_page_token {
        req_builder = req_builder.query(&[("next_page_token", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::TaskPaginatedResponse`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::TaskPaginatedResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<ListTasksByContextIdError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

pub async fn resume_user_credential_brokering(configuration: &configuration::Configuration, state: Option<&str>, code: Option<&str>, error: Option<&str>, error_description: Option<&str>) -> Result<models::UserCredentialBrokeringResponse, Error<ResumeUserCredentialBrokeringError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_state = state;
    let p_code = code;
    let p_error = error;
    let p_error_description = error_description;

    let uri_str = format!("{}/api/bridge/v1/generic-oauth-callback", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = p_state {
        req_builder = req_builder.query(&[("state", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_code {
        req_builder = req_builder.query(&[("code", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_error {
        req_builder = req_builder.query(&[("error", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_error_description {
        req_builder = req_builder.query(&[("error_description", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::UserCredentialBrokeringResponse`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::UserCredentialBrokeringResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<ResumeUserCredentialBrokeringError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

pub async fn send_message(configuration: &configuration::Configuration, task_id: &str, create_message_request: models::CreateMessageRequest) -> Result<models::CreateMessageResponse, Error<SendMessageError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_task_id = task_id;
    let p_create_message_request = create_message_request;

    let uri_str = format!("{}/api/task/v1/{task_id}/message", configuration.base_path, task_id=crate::apis::urlencode(p_task_id));
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    req_builder = req_builder.json(&p_create_message_request);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::CreateMessageResponse`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::CreateMessageResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<SendMessageError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

pub async fn start_user_credential_brokering(configuration: &configuration::Configuration, provider_controller_type_id: &str, credential_controller_type_id: &str, start_user_credential_brokering_params_inner: models::StartUserCredentialBrokeringParamsInner) -> Result<models::UserCredentialBrokeringResponse, Error<StartUserCredentialBrokeringError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_provider_controller_type_id = provider_controller_type_id;
    let p_credential_controller_type_id = credential_controller_type_id;
    let p_start_user_credential_brokering_params_inner = start_user_credential_brokering_params_inner;

    let uri_str = format!("{}/api/bridge/v1/available-providers/{provider_controller_type_id}/available-credentials/{credential_controller_type_id}/credential/user-credential/broker", configuration.base_path, provider_controller_type_id=crate::apis::urlencode(p_provider_controller_type_id), credential_controller_type_id=crate::apis::urlencode(p_credential_controller_type_id));
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    req_builder = req_builder.json(&p_start_user_credential_brokering_params_inner);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::UserCredentialBrokeringResponse`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::UserCredentialBrokeringResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<StartUserCredentialBrokeringError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

pub async fn task_history(configuration: &configuration::Configuration, page_size: i64, task_id: &str, next_page_token: Option<&str>) -> Result<models::TaskTimelineItemPaginatedResponse, Error<TaskHistoryError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_page_size = page_size;
    let p_task_id = task_id;
    let p_next_page_token = next_page_token;

    let uri_str = format!("{}/api/task/v1/{task_id}/timeline", configuration.base_path, task_id=crate::apis::urlencode(p_task_id));
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    req_builder = req_builder.query(&[("page_size", &p_page_size.to_string())]);
    if let Some(ref param_value) = p_next_page_token {
        req_builder = req_builder.query(&[("next_page_token", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::TaskTimelineItemPaginatedResponse`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::TaskTimelineItemPaginatedResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<TaskHistoryError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

pub async fn update_task_status(configuration: &configuration::Configuration, task_id: &str, update_task_status_request: models::UpdateTaskStatusRequest) -> Result<serde_json::Value, Error<UpdateTaskStatusError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_task_id = task_id;
    let p_update_task_status_request = update_task_status_request;

    let uri_str = format!("{}/api/task/v1/{task_id}", configuration.base_path, task_id=crate::apis::urlencode(p_task_id));
    let mut req_builder = configuration.client.request(reqwest::Method::PUT, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    req_builder = req_builder.json(&p_update_task_status_request);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `serde_json::Value`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `serde_json::Value`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<UpdateTaskStatusError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

