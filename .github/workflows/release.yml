name: Create Release

on:
  push:
    branches: [main]
    paths:
      - 'VERSION'
      - 'CHANGELOG.md'
  workflow_dispatch:

permissions:
  contents: write
  id-token: write

jobs:
  prepare-release:
    runs-on: ubuntu-latest
    outputs:
      version: ${{ steps.read-version.outputs.version }}
    steps:
      - name: Checkout repository
        uses: actions/checkout@v5
        with:
          fetch-depth: 0
          token: ${{ secrets.TRY_SOMA_BOT_TOKEN }}

      - name: Read version from VERSION file
        id: read-version
        run: |
          if [ ! -f "VERSION" ]; then
            echo "Error: VERSION file not found"
            exit 1
          fi
          
          VERSION=$(cat VERSION | tr -d '[:space:]')
          if [ -z "$VERSION" ]; then
            echo "Error: VERSION file is empty"
            exit 1
          fi
          
          # Ensure version starts with 'v'
          if [[ ! "$VERSION" =~ ^v ]]; then
            VERSION="v$VERSION"
          fi
          
          echo "Version from VERSION file: $VERSION"
          echo "version=$VERSION" >> $GITHUB_OUTPUT

      - name: Calculate previous version for comparison
        id: prev-version
        run: |
          CURRENT_VERSION="${{ steps.read-version.outputs.version }}"
          
          # Get the latest release tag (excluding prereleases)
          PREV_VERSION=$(git tag -l "v*" | grep -v -E ".*-(snapshot|rc)-" | sort -V | tail -1 || echo "")
          
          # Exclude the current version if it already exists as a tag
          if [ "$PREV_VERSION" = "$CURRENT_VERSION" ]; then
            # Get the second-to-last tag
            PREV_VERSION=$(git tag -l "v*" | grep -v -E ".*-(snapshot|rc)-" | sort -V | tail -2 | head -1 || echo "")
          fi
          
          if [ -z "$PREV_VERSION" ]; then
            echo "Warning: No previous version found, will skip diff generation"
            PREV_VERSION=""
          else
            echo "Previous version for comparison: $PREV_VERSION"
          fi
          
          # Verify the previous version tag exists
          if [ -n "$PREV_VERSION" ] && ! git rev-parse "$PREV_VERSION" >/dev/null 2>&1; then
            echo "Warning: Previous version tag $PREV_VERSION not found, will skip diff generation"
            PREV_VERSION=""
          fi
          
          echo "prev_version=$PREV_VERSION" >> $GITHUB_OUTPUT
          echo "has_prev_version=$([ -n "$PREV_VERSION" ] && echo "true" || echo "false")" >> $GITHUB_OUTPUT

      - name: Install Atlas CLI
        if: steps.prev-version.outputs.has_prev_version == 'true'
        run: |
          curl -sSf https://atlasgo.sh | sh -s -- --community -y
          echo "$HOME/.atlas/bin" >> $GITHUB_PATH

      - name: Download OpenAPI spec from previous version
        if: steps.prev-version.outputs.has_prev_version == 'true'
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          PREV_VERSION="${{ steps.prev-version.outputs.prev_version }}"
          echo "Downloading openapi.json from tag: $PREV_VERSION"
          
          curl -H "Authorization: token $GITHUB_TOKEN" \
                -H "Accept: application/vnd.github.v3.raw" \
                -o ./openapi-prev.json \
                "https://api.github.com/repos/${{ github.repository }}/contents/openapi.json?ref=$PREV_VERSION" || {
            echo "Warning: Could not download openapi.json from $PREV_VERSION, will skip OpenAPI diff"
            touch ./openapi-prev.json
          }

      - name: Check OpenAPI files exist
        if: steps.prev-version.outputs.has_prev_version == 'true'
        id: check-openapi
        run: |
          if [ ! -f ./openapi.json ]; then
            echo "has_current=false" >> $GITHUB_OUTPUT
            echo "Warning: openapi.json not found in current checkout"
          else
            echo "has_current=true" >> $GITHUB_OUTPUT
          fi
          
          if [ ! -f ./openapi-prev.json ] || [ ! -s ./openapi-prev.json ]; then
            echo "has_previous=false" >> $GITHUB_OUTPUT
            echo "Warning: Previous openapi.json not available"
          else
            echo "has_previous=true" >> $GITHUB_OUTPUT
          fi

      - name: Generate OpenAPI diff
        if: |
          steps.prev-version.outputs.has_prev_version == 'true' &&
          steps.check-openapi.outputs.has_current == 'true' &&
          steps.check-openapi.outputs.has_previous == 'true'
        id: openapi-diff
        continue-on-error: true
        uses: oasdiff/oasdiff-action/diff@main
        with:
          base: ./openapi-prev.json
          revision: ./openapi.json

      - name: Run Atlas migrate lint for Soma database
        if: steps.prev-version.outputs.has_prev_version == 'true'
        id: atlas-soma
        continue-on-error: true
        run: |
          PREV_VERSION="${{ steps.prev-version.outputs.prev_version }}"
          echo "Running Atlas migrate lint for Soma database against $PREV_VERSION"
          
          # Fetch the previous version tag
          git fetch origin "refs/tags/$PREV_VERSION:refs/tags/$PREV_VERSION" || git fetch origin "$PREV_VERSION" || true
          
          # Use git-base with the tag name (atlas should handle tags)
          atlas_output=$(atlas migrate lint --env soma --git-base "$PREV_VERSION" 2>&1) || atlas_exit=$?
          if [ -z "$atlas_output" ]; then
            atlas_output="SUCCESS: checksums match, no breaking changes"
          fi
          
          echo "soma_lint_output<<EOF" >> $GITHUB_OUTPUT
          echo "$atlas_output" >> $GITHUB_OUTPUT
          echo "EOF" >> $GITHUB_OUTPUT
          
          if [ -n "${atlas_exit:-}" ]; then
            echo "Atlas lint found issues (exit code: $atlas_exit)"
            echo "$atlas_output"
          fi

      - name: Run Atlas migrate lint for Bridge database
        if: steps.prev-version.outputs.has_prev_version == 'true'
        id: atlas-bridge
        continue-on-error: true
        run: |
          PREV_VERSION="${{ steps.prev-version.outputs.prev_version }}"
          echo "Running Atlas migrate lint for Bridge database against $PREV_VERSION"
          
          # Fetch the previous version tag
          git fetch origin "refs/tags/$PREV_VERSION:refs/tags/$PREV_VERSION" || git fetch origin "$PREV_VERSION" || true
          
          # Use git-base with the tag name (atlas should handle tags)
          atlas_output=$(atlas migrate lint --env bridge --git-base "$PREV_VERSION" 2>&1) || atlas_exit=$?
          if [ -z "$atlas_output" ]; then
            atlas_output="SUCCESS: checksums match, no breaking changes"
          fi
          
          echo "bridge_lint_output<<EOF" >> $GITHUB_OUTPUT
          echo "$atlas_output" >> $GITHUB_OUTPUT
          echo "EOF" >> $GITHUB_OUTPUT
          
          if [ -n "${atlas_exit:-}" ]; then
            echo "Atlas lint found issues (exit code: $atlas_exit)"
            echo "$atlas_output"
          fi

      

      - name: Setup Rust toolchain
        uses: ./.github/actions/setup-rust
        with:
          components: ''
          install-protoc: 'false'

      - name: Update Cargo.lock
        run: |
          echo "Updating Cargo.lock for version ${{ steps.read-version.outputs.version }}"
          cargo update --workspace

      - name: Create release artifact
        run: |
          # Capture all modified files (including any Cargo.toml version changes)
          # Use git status to find all modified/new files
          git add -A

          # Create tarball of all changes using --files-from to handle special characters
          git diff --cached --name-only --diff-filter=ACMR > /tmp/changed-files.txt

          # Also add the frontend dist directory (not tracked by git)
          if [ -d "crates/soma/app/dist" ]; then
            echo "Adding frontend dist directory to artifact"
            find crates/soma/app/dist -type f >> /tmp/changed-files.txt
          fi

          if [ -s /tmp/changed-files.txt ]; then
            echo "Packaging changed files:"
            cat /tmp/changed-files.txt
            tar -czf release-changes.tar.gz --files-from=/tmp/changed-files.txt
          else
            echo "No changes detected, creating empty tarball"
            tar -czf release-changes.tar.gz --files-from /dev/null
          fi

      - name: Upload release changes artifact
        uses: actions/upload-artifact@v4
        with:
          name: release-changes
          path: release-changes.tar.gz
          retention-days: 1

  build-core-js-sdk:
    needs: prepare-release
    uses: ./.github/workflows/common-build-core-js-sdk.yml
    with:
      revision: ${{ github.ref }}
    secrets:
      GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}

  test-sdk-js-macOS-windows-binding:
    needs: build-core-js-sdk
    uses: ./.github/workflows/common-test-sdk-js-macOS-windows-binding.yml
    secrets:
      GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}

  test-linux-js-sdk-binding:
    needs: build-core-js-sdk
    uses: ./.github/workflows/common-test-linux-js-sdk-binding.yml
    secrets:
      GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}

  build-soma:
    needs: prepare-release
    uses: ./.github/workflows/common-build-soma.yml
    with:
      revision: ${{ github.ref }}
    secrets:
      GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
      AWS_INTEGRATION_TESTS_ROLE_ARN: ${{ secrets.AWS_INTEGRATION_TESTS_ROLE_ARN }}

  test-soma-macOS-windows:
    needs: build-soma
    uses: ./.github/workflows/common-test-soma-macOS-windows.yml
    with:
      revision: ${{ github.ref }}
    secrets:
      GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
      AWS_INTEGRATION_TESTS_ROLE_ARN: ${{ secrets.AWS_INTEGRATION_TESTS_ROLE_ARN }}

  test-soma-linux:
    needs: build-soma
    uses: ./.github/workflows/common-test-soma-linux.yml
    with:
      revision: ${{ github.ref }}
    secrets:
      GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
      AWS_INTEGRATION_TESTS_ROLE_ARN: ${{ secrets.AWS_INTEGRATION_TESTS_ROLE_ARN }}

  publish-npm:
    needs:
      - prepare-release
      - build-core-js-sdk
      - build-soma
      - test-sdk-js-macOS-windows-binding
      - test-linux-js-sdk-binding
      - test-soma-macOS-windows
      - test-soma-linux
    uses: ./.github/workflows/common-publish-npm.yml
    with:
      version: ${{ needs.prepare-release.outputs.version }}
      npm-tag: latest
    secrets:
      GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
      NPM_TOKEN: ${{ secrets.NPM_TOKEN }}

  create-github-release:
    needs: [prepare-release, build-soma, build-core-js-sdk, publish-npm]
    uses: ./.github/workflows/common-create-github-release.yml
    with:
      version: ${{ needs.prepare-release.outputs.version }}
      revision: ${{ github.ref }}
      prerelease: false
    secrets:
      GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
      TRY_SOMA_BOT_TOKEN: ${{ secrets.TRY_SOMA_BOT_TOKEN }}

  create-github-issue-on-fail:
    needs:
      - prepare-release
      - build-soma
      - build-core-js-sdk
      # - test-sdk-js-macOS-windows-binding
      # - test-linux-js-sdk-binding
      # - test-soma-macOS-windows
      # - test-soma-linux
      - publish-npm
      - create-github-release
    if: failure()
    uses: ./.github/workflows/common-create-github-issue-on-fail.yml
    with:
      version: ${{ needs.prepare-release.outputs.version }}
      workflow-type: release
      failed-jobs: ${{ needs.prepare-release.result == 'failure' && 'prepare-release' || '' }}${{ needs.build-soma.result == 'failure' && format(',build-soma') || '' }}${{ needs.build-core-js-sdk.result == 'failure' && format(',build-core-js-sdk') || '' }}${{ needs.publish-npm.result == 'failure' && format(',publish-npm') || '' }}${{ needs.create-github-release.result == 'failure' && format(',create-github-release') || '' }}
    secrets:
      GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
