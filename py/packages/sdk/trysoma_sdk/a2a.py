"""
Durable A2A client wrapper that makes all A2A operations replayable via Restate.
All methods are wrapped with ctx.run() for durability.
"""

import logging
from typing import AsyncIterator, TypeVar, Generic, Union, cast, TYPE_CHECKING, TypeAlias

from restate import ObjectContext

logger = logging.getLogger(__name__)

# A2A types - these are the core types from a2a-python
from a2a.types import (
    AgentCard,
    Message,
    Task,
    TaskStatusUpdateEvent,
    TaskArtifactUpdateEvent,
    TaskQueryParams,
    TaskIdParams,
    SendMessageRequest,
    SendStreamingMessageRequest,
    GetTaskRequest,
    CancelTaskRequest,
    TaskResubscriptionRequest,
    SendStreamingMessageResponse,
    MessageSendParams,
    SendMessageSuccessResponse,
    GetTaskSuccessResponse,
    CancelTaskSuccessResponse,
)
from a2a.client import A2AClient as BaseA2AClient

if TYPE_CHECKING:
    from a2a.client import ClientEvent
else:
    # Import at runtime for type alias
    from a2a.client import ClientEvent


# Type for stream events (matching TypeScript A2AStreamEventData)
A2AStreamEventData = Union[
    Message, Task, TaskStatusUpdateEvent, TaskArtifactUpdateEvent
]

# Type alias for stream event types including ClientEvent
StreamEventType: TypeAlias = Union[
    ClientEvent, Message, Task, TaskStatusUpdateEvent, TaskArtifactUpdateEvent
]

T = TypeVar("T")


class DurableStream(Generic[T]):
    """
    Wraps an async generator to make each yielded event durable via Restate.
    Each event is individually journaled with ctx.run().
    """

    def __init__(
        self,
        ctx: ObjectContext,
        stream_name: str,
        stream: AsyncIterator[T],
    ) -> None:
        self._ctx = ctx
        self._stream_name = stream_name
        self._stream: AsyncIterator[T] | None = stream
        self._index = 0

    def __aiter__(self) -> "DurableStream[T]":
        """Return self as async iterator."""
        return self

    async def __anext__(self) -> T:
        """Get next event durably."""
        stream = self._stream
        if stream is None:
            raise StopAsyncIteration

        async def get_next() -> dict[str, object]:
            try:
                event = await stream.__anext__()
                # Serialize event to dict for journaling
                # Check if it's a Pydantic model
                if hasattr(event, "model_dump"):
                    model_dump = getattr(event, "model_dump")
                    if callable(model_dump):
                        return {"done": False, "value": model_dump()}
                if hasattr(event, "__dict__"):
                    return {"done": False, "value": event.__dict__}
                return {"done": False, "value": event}
            except StopAsyncIteration:
                return {"done": True, "value": None}

        result = await self._ctx.run(
            f"{self._stream_name}-event-index-{self._index}",
            get_next,
        )

        # Note: this should never happen during replay if we initially crashed
        # and now are resuming - the journal should have the value
        if result is None:
            raise RuntimeError(
                f"Restated durable stream {self._stream_name} error. "
                "We should never get here. Our journal is out of sync."
            )

        if result.get("done", False):
            raise StopAsyncIteration

        self._index += 1
        return cast(T, result["value"])


class A2AClient:
    """
    Durable A2A client wrapper that makes all A2A operations replayable via Restate.
    All methods are wrapped with ctx.run() for durability.
    """

    def __init__(
        self,
        ctx: ObjectContext,
        client: BaseA2AClient,
        restate_id: str,
    ) -> None:
        self._ctx = ctx
        self._client = client
        self._restate_id = restate_id
        self._request_index = 0

    async def send_message(self, message: Message) -> Message | Task:
        """
        Send a message to the agent (non-streaming, durable).
        The entire request/response cycle is wrapped for durability.
        """
        logger.debug("Sending message to agent %s", self._restate_id)
        index = self._request_index
        self._request_index += 1

        # Convert Message to SendMessageRequest
        request = SendMessageRequest(
            id="",  # Will be generated by client
            jsonrpc="2.0",
            params=MessageSendParams(message=message),
        )

        async def do_send() -> dict[str, object]:
            response = await self._client.send_message(request)
            # Extract result from response
            if hasattr(response, "root") and isinstance(
                response.root, SendMessageSuccessResponse
            ):
                result = response.root.result
                if isinstance(result, (Message, Task)):
                    return cast(dict[str, object], result.model_dump())
            raise RuntimeError("Invalid response from send_message")

        data = await self._ctx.run(
            f"a2a-{self._restate_id}-sendMessage-index-{index}",
            do_send,
        )
        # Try to parse as Task first, then Message
        try:
            result = Task.model_validate(data)
            logger.debug("Sending message to agent %s completed", self._restate_id)
            return result
        except Exception:
            result = Message.model_validate(data)
            logger.debug("Sending message to agent %s completed", self._restate_id)
            return result

    async def send_message_stream(
        self,
        message: Message,
    ) -> AsyncIterator[StreamEventType]:
        """
        Send a message and stream responses.
        Each event from the stream is individually made durable.
        Returns an async generator that yields events durably.
        """
        logger.debug("Starting streaming message to agent %s", self._restate_id)
        index = self._request_index
        self._request_index += 1

        # Convert Message to SendStreamingMessageRequest
        request = SendStreamingMessageRequest(
            id="",  # Will be generated by client
            jsonrpc="2.0",
            params=MessageSendParams(message=message),
        )

        stream = self._client.send_message_streaming(request)
        durable_stream = DurableStream[SendStreamingMessageResponse](
            self._ctx,
            f"a2a-{self._restate_id}-sendMessageStream-index-{index}",
            stream,
        )

        async for event_response in durable_stream:
            # Extract result from SendStreamingMessageResponse
            if hasattr(event_response, "root"):
                from a2a.types import SendStreamingMessageSuccessResponse
                if isinstance(
                    event_response.root, SendStreamingMessageSuccessResponse
                ):
                    result = event_response.root.result
                    yield cast(StreamEventType, result)
                else:
                    yield cast(StreamEventType, event_response)
            else:
                yield cast(StreamEventType, event_response)
        logger.debug("Streaming message to agent %s completed", self._restate_id)

    async def get_task(self, params: TaskQueryParams) -> Task:
        """Get a task by ID (durable)."""
        logger.debug("Getting task %s", params.id)
        index = self._request_index
        self._request_index += 1

        request = GetTaskRequest(
            id="",
            jsonrpc="2.0",
            params=params,
        )

        async def do_get() -> dict[str, object]:
            response = await self._client.get_task(request)
            if hasattr(response, "root") and isinstance(
                response.root, GetTaskSuccessResponse
            ):
                result = response.root.result
                if isinstance(result, Task):
                    return cast(dict[str, object], result.model_dump())
            raise RuntimeError("Invalid response from get_task")

        data = await self._ctx.run(
            f"a2a-{self._restate_id}-getTask-index-{index}",
            do_get,
        )
        result = Task.model_validate(data)
        logger.debug("Getting task %s completed", params.id)
        return result

    async def cancel_task(self, params: TaskIdParams) -> Task:
        """Cancel a task by ID (durable)."""
        logger.debug("Canceling task %s", params.id)
        index = self._request_index
        self._request_index += 1

        request = CancelTaskRequest(
            id="",
            jsonrpc="2.0",
            params=params,
        )

        async def do_cancel() -> dict[str, object]:
            response = await self._client.cancel_task(request)
            if hasattr(response, "root") and isinstance(
                response.root, CancelTaskSuccessResponse
            ):
                result = response.root.result
                if isinstance(result, Task):
                    return cast(dict[str, object], result.model_dump())
            raise RuntimeError("Invalid response from cancel_task")

        data = await self._ctx.run(
            f"a2a-{self._restate_id}-cancelTask-index-{index}",
            do_cancel,
        )
        result = Task.model_validate(data)
        logger.debug("Canceling task %s completed", params.id)
        return result

    async def resubscribe_task(
        self,
        params: TaskIdParams,
    ) -> AsyncIterator[StreamEventType]:
        """
        Resubscribe to a task's event stream.
        Each event from the stream is individually made durable.
        """
        logger.debug("Resubscribing to task %s", params.id)
        index = self._request_index
        self._request_index += 1

        request = TaskResubscriptionRequest(
            id="",
            jsonrpc="2.0",
            params=params,
        )

        stream = self._client.resubscribe(request)
        durable_stream = DurableStream[SendStreamingMessageResponse](
            self._ctx,
            f"a2a-{self._restate_id}-resubscribeTask-index-{index}",
            stream,
        )

        async for event_response in durable_stream:
            # Extract result from SendStreamingMessageResponse
            if hasattr(event_response, "root"):
                from a2a.types import SendStreamingMessageSuccessResponse
                if isinstance(
                    event_response.root, SendStreamingMessageSuccessResponse
                ):
                    result = event_response.root.result
                    yield cast(StreamEventType, result)
                else:
                    yield cast(StreamEventType, event_response)
            else:
                yield cast(StreamEventType, event_response)
        logger.debug("Resubscribing to task %s completed", params.id)

    async def get_agent_card(self) -> AgentCard:
        """Get the agent card (durable)."""
        logger.debug("Getting agent card for %s", self._restate_id)
        index = self._request_index
        self._request_index += 1

        async def do_get_card() -> dict[str, object]:
            result = await self._client.get_card()
            return cast(dict[str, object], result.model_dump())

        data = await self._ctx.run(
            f"a2a-{self._restate_id}-getAgentCard-index-{index}",
            do_get_card,
        )
        result = AgentCard.model_validate(data)
        logger.debug("Getting agent card for %s completed", self._restate_id)
        return result


async def create_a2a_client(
    ctx: ObjectContext,
    card_url: str,
    agent_id: str,
) -> A2AClient:
    """
    Create a durable A2A client from a card URL.

    Args:
        ctx: The Restate ObjectContext for durability
        card_url: The URL to the agent's card.json
        agent_id: A unique identifier for this agent (used for durability keys)

    Returns:
        A durable A2A client instance
    """
    import httpx
    from a2a.client import A2ACardResolver
    from urllib.parse import urlparse

    logger.debug("Creating A2A client for agent %s from %s", agent_id, card_url)

    async def init_client() -> dict[str, object]:
        parsed_url = urlparse(card_url)
        base_url = f"{parsed_url.scheme}://{parsed_url.netloc}"
        httpx_client = httpx.AsyncClient()
        resolver = A2ACardResolver(
            httpx_client=httpx_client,
            base_url=base_url,
        )
        card = await resolver.get_agent_card(relative_card_path=parsed_url.path)
        # Return card data for journaling
        return cast(dict[str, object], card.model_dump())

    # Initialize the client durably
    await ctx.run(f"init-a2a-{agent_id}", init_client)

    # Create the actual client from the card
    # Note: We reconstruct the client each time, but the card resolution is durable
    httpx_client = httpx.AsyncClient()
    base_client = BaseA2AClient(httpx_client=httpx_client)

    logger.debug("Creating A2A client for agent %s completed", agent_id)
    return A2AClient(ctx, base_client, agent_id)


# Re-export types from a2a for convenience
__all__ = [
    # Main client
    "A2AClient",
    "create_a2a_client",
    # Stream types
    "A2AStreamEventData",
    "DurableStream",
    # Re-exported types
    "AgentCard",
    "Message",
    "Task",
    "TaskStatusUpdateEvent",
    "TaskArtifactUpdateEvent",
    "TaskQueryParams",
    "TaskIdParams",
    "ClientEvent",
    # Base client for advanced use cases
    "BaseA2AClient",
]
